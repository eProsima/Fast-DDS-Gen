// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group TypesHeader;

import "com/eprosima/fastdds/idl/templates/eprosima.stg"
import "FastCdrCommon.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx, file=[ctx.filename, ".hpp"], description=["This header file contains the declaration of the described types in the IDL file."])$

#ifndef _FAST_DDS_GENERATED_$ctx.headerGuardName$_HPP_
#define _FAST_DDS_GENERATED_$ctx.headerGuardName$_HPP_

#include <array>
#include <bitset>
#include <cstdint>
#include <map>
#include <string>
#include <utility>
#include <vector>

#include <fastcdr/cdr/fixed_size_string.hpp>
#include <fastcdr/xcdr/external.hpp>
#include <fastcdr/xcdr/optional.hpp>
#include <fastcdr/exceptions/BadParamException.h>

$ctx.directIncludeDependencies : {include | #include "$include$.hpp"}; separator="\n"$

$if(ctx.generateTypeObject)$
#include "$ctx.filename$TypeObject.h"
$endif$

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#define eProsima_user_DllExport __declspec( dllexport )
#else
#define eProsima_user_DllExport
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define eProsima_user_DllExport
#endif  // _WIN32

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#if defined($ctx.fileNameUpper$_SOURCE)
#define $ctx.fileNameUpper$_DllAPI __declspec( dllexport )
#else
#define $ctx.fileNameUpper$_DllAPI __declspec( dllimport )
#endif // $ctx.fileNameUpper$_SOURCE
#else
#define $ctx.fileNameUpper$_DllAPI
#endif  // EPROSIMA_USER_DLL_EXPORT
#else
#define $ctx.fileNameUpper$_DllAPI
#endif // _WIN32

$definitions; separator="\n"$

#endif // _FAST_DDS_GENERATED_$ctx.headerGuardName$_HPP_
$"\n"$

>>

module(ctx, parent, module, definition_list) ::= <<
namespace $module.name$ {

$definition_list$

} // namespace $module.name$
>>

annotation(ctx, annotation) ::= <<
namespace $annotation.name$ {
    $annotation.enums : { enum | $enum_type(ctx=ctx, parent=annotation, enum=enum)$}; separator="\n"$

    $annotation.typeDefs : { typedef | $typedef_decl(ctx=ctx, parent=annotation, typedefs=typedef)$}; separator="\n"$

    $annotation.constDecls : { const | $const_decl(ctx=ctx, parent=annotation, const=const)$}; separator="\n"$

} // namespace $annotation.name$
>>

interface(ctx, parent, interface, export_list) ::= <<
/*!
 * @brief This class represents the interface $interface.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class $ctx.fileNameUpper$_DllAPI $interface.name$ $if(interface.bases)$: $interface.bases : {base |public $base.scopedname$}; separator=", "$$endif$
{
public:

    $export_list$
};
>>

const_decl(ctx, parent, const, const_type) ::= <<
$const_type$
const $const.typeCode.cppTypename$ $const.name$ = $const.value$;
>>

typedef_decl(ctx, parent, typedefs, typedefs_type, declarator_type) ::= <<
$declarator_type$
$typedefs_type$
$typedefs :
{ typedef |
typedef $typedef.typedefContentTypeCode.cppTypename$ $typedef.name$;
}; separator="\n"$
>>

struct_type(ctx, parent, struct, extensions, member_list) ::= <<
$member_list$
/*!
 * @brief This class represents the structure $struct.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class $struct.name$$if(struct.inheritance)$ : public $public_struct_inheritances(struct.inheritance)$$endif$
{
public:

    /*!
     * @brief Default constructor.
     */
    eProsima_user_DllExport $struct.name$()
        $if(struct.inheritance)$
        : $struct_inherit_default_init(struct.inheritance)$
        $endif$
    {
        $if(ctx.generateTypeObject)$
        // Just to register all known types
        register$ctx.filename$Types();
        $endif$
    }

    /*!
     * @brief Default destructor.
     */
    eProsima_user_DllExport ~$struct.name$()
    {
        $struct.members:{ member |$member_destructor(ctx=ctx, member=member)$}; separator="\n"$
    }

    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $struct.name$(
            const $struct.name$& x)
        $if(struct.inheritance)$
        : $struct_inherit_copy_init(struct.inheritance)$
        $endif$
    {
        $if(struct.members)$
        $struct.members:{ member |
            m_$member.name$ = x.m_$member.name$;
        }; separator="\n"$
        $else$
        static_cast<void>(x);
        $endif$
    }

    /*!
     * @brief Move constructor.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $struct.name$(
            $struct.name$&& x) noexcept
        $if(struct.inheritance)$
        : $struct_inherit_move_init(struct.inheritance)$
        $endif$

    {
        $if(struct.members)$
        $struct.members:{ member | $member_move(member=member)$}; separator="\n"$
        $else$
        static_cast<void>(x);
        $endif$
    }

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $struct.name$& operator =(
            const $struct.name$& x)
    {
        $if(struct.inheritance)$$struct.inheritance.scopedname$::operator =(x);$endif$

        $if(struct.members)$
        $struct.members:{ member |
            m_$member.name$ = x.m_$member.name$;
        }; separator="\n"$
        $else$
        static_cast<void>(x);
        $endif$

        return *this;
    }

    /*!
     * @brief Move assignment.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $struct.name$& operator =(
            $struct.name$&& x) noexcept
    {
        $if(struct.inheritance)$$struct.inheritance.scopedname$::operator =(std::move(x));$endif$

        $if(struct.members)$
        $struct.members:{ member | $member_move(member=member)$}; separator="\n"$
        $else$
        static_cast<void>(x);
        $endif$

        return *this;
    }

    /*!
     * @brief Comparison operator.
     * @param x $struct.scopedname$ object to compare.
     */
    eProsima_user_DllExport bool operator ==(
            const $struct.name$& x) const
    {
        $if(struct.inheritance)$if ($struct.inheritance.scopedname$::operator !=(x))
        {
            return false;
        }
        $endif$

        $if(!struct.members)$
        static_cast<void>(x);
        return true;
        $else$
        return ($struct.members:{ member | m_$member.name$ == x.m_$member.name$}; separator=" &&\n           "$);
        $endif$
    }

    /*!
     * @brief Comparison operator.
     * @param x $struct.scopedname$ object to compare.
     */
    eProsima_user_DllExport bool operator !=(
            const $struct.name$& x) const
    {
        return !(*this == x);
    }

    $struct.members:{ member | $public_member_declaration(member)$}; separator="\n"$

    $extensions : { extension | $extension$}; separator="\n"$

private:

    $struct.members:{ member | $private_member_declaration(member=member)$}; separator="\n"$

};
>>

union_type(ctx, parent, union, extensions, switch_type) ::= <<
$switch_type$
/*!
 * @brief This class represents the union $union.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class $union.name$
{
public:

    /*!
     * @brief Default constructor.
     */
    eProsima_user_DllExport $union.name$()
    {
        $if(union.defaultvalue)$
        m__d = $union.defaultvalue$;
        $else$
        m__d = $first(first(union.members).labels)$;
        $endif$
    }

    /*!
     * @brief Default destructor.
     */
    eProsima_user_DllExport ~$union.name$()
    {
    }

    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $union.name$(
            const $union.name$& x)
    {
        m__d = x.m__d;

        switch (m__d)
        {
            $union.members:{ member | $unionmember_copy(member)$}; separator="\n"$
            $unionmemberdefault_copy(union.defaultMember)$
        }
    }

    /*!
     * @brief Move constructor.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $union.name$(
            $union.name$&& x) noexcept
    {
        m__d = x.m__d;

        switch (m__d)
        {
            $union.members:{ member | $unionmember_move(member)$}; separator="\n"$
            $unionmemberdefault_move(union.defaultMember)$
        }
    }

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $union.name$& operator =(
            const $union.name$& x)
    {
        m__d = x.m__d;

        switch (m__d)
        {
            $union.members:{ member | $unionmember_copy(member)$}; separator="\n"$
            $unionmemberdefault_copy(union.defaultMember)$
        }

        return *this;
    }

    /*!
     * @brief Move assignment.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $union.name$& operator =(
            $union.name$&& x) noexcept
    {
        m__d = x.m__d;

        switch (m__d)
        {
            $union.members:{ member | $unionmember_move(member)$}; separator="\n"$
            $unionmemberdefault_move(union.defaultMember)$
        }

        return *this;
    }

    /*!
     * @brief Comparison operator.
     * @param x $union.scopedname$ object to compare.
     */
    eProsima_user_DllExport bool operator ==(
            const $union.name$& x) const
    {
        if (m__d != x.m__d)
        {
            return false;
        }

        switch (m__d)
        {
            $union.members:{ member | $unionmember_compare(member)$}; separator="\n"$
            $unionmemberdefault_compare(union.defaultMember)$
        }
        return false;
    }

    /*!
     * @brief Comparison operator.
     * @param x $union.scopedname$ object to compare.
     */
    eProsima_user_DllExport bool operator !=(
            const $union.name$& x) const
    {
        return !(*this == x);
    }

    /*!
     * @brief This function sets the discriminator value.
     * @param __d New value for the discriminator.
     * @exception eprosima::fastcdr::exception::BadParamException This exception is thrown if the new value doesn't correspond to the selected union member.
     */
    eProsima_user_DllExport void _d(
            $union.discriminator.typecode.cppTypename$ __d)
    {
        bool b = false;

        switch (m__d)
        {
            $union.members:{ member | $unionmember_discriminator_case(member=member, totallabels=union.totallabels)$}; separator="\n"$
            $if(!union.defaultMember)$
            default:
                break;
            $endif$
        }

        if (!b)
        {
            throw eprosima::fastcdr::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
        }

        m__d = __d;
    }

    /*!
     * @brief This function returns the value of the discriminator.
     * @return Value of the discriminator
     */
    eProsima_user_DllExport $union.discriminator.typecode.cppTypename$ _d() const
    {
        return m__d;
    }

    /*!
     * @brief This function returns a reference to the discriminator.
     * @return Reference to the discriminator.
     */
    eProsima_user_DllExport $union.discriminator.typecode.cppTypename$& _d()
    {
        return m__d;
    }

    $union.members:{ member | $public_unionmember_declaration(union, member)$}; separator="\n"$

    $extensions : {extension | $extension$}; separator="\n"$

private:

    $union.discriminator.typecode.cppTypename$ m__d;

    $union.members:{ member | $private_member_declaration(member=member)$}; separator="\n"$
};
>>

bitset_type(ctx, parent, bitset, extensions) ::= <<
/*!
 * @brief This class represents the structure $bitset.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class $bitset.name$$if(bitset.inheritance)$ : public $public_bitset_inheritances(bitset.inheritance)$$endif$
{
public:

    /*!
     * @brief Default constructor.
     */
    eProsima_user_DllExport $bitset.name$()
    $if(bitset.inheritance)$
    : $struct_inherit_default_init(bitset.inheritance)$
    $endif$
    {
        $if(ctx.generateTypeObject)$
        // Just to register all known types
        register$ctx.filename$Types();
        $endif$
    }

    /*!
     * @brief Default destructor.
     */
    eProsima_user_DllExport ~$bitset.name$()
    {
    }

    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $bitset.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $bitset.name$(
            const $bitset.name$& x)
    $if(bitset.inheritance)$
    : $struct_inherit_copy_init(bitset.inheritance)$
    $endif$
    {
        m_bitset = x.m_bitset;
    }

    /*!
     * @brief Move constructor.
     * @param x Reference to the object $bitset.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $bitset.name$(
            $bitset.name$&& x) noexcept
    $if(bitset.inheritance)$
    : $struct_inherit_move_init(bitset.inheritance)$
    $endif$
    {
        m_bitset = x.m_bitset;
    }

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $bitset.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $bitset.name$& operator =(
            const $bitset.name$& x)
    {
        $if(bitset.inheritance)$    $bitset.inheritance.scopedname$::operator =(x);$endif$

        m_bitset = x.m_bitset;

        return *this;
    }

    /*!
     * @brief Move assignment.
     * @param x Reference to the object $bitset.scopedname$ that will be copied.
     */
    eProsima_user_DllExport $bitset.name$& operator =(
            $bitset.name$&& x) noexcept
    {
        $if(bitset.inheritance)$    $bitset.inheritance.scopedname$::operator =(std::move(x));$endif$

        m_bitset = x.m_bitset;

        return *this;
    }

    /*!
     * @brief Comparison operator.
     * @param x $bitset.scopedname$ object to compare.
     */
    eProsima_user_DllExport bool operator ==(
            const $bitset.name$& x) const
    {
        $if(bitset.inheritance)$    if ($bitset.inheritance.scopedname$::operator !=(x)) return false;$endif$

        return m_bitset == x.m_bitset;
    }

    /*!
     * @brief Comparison operator.
     * @param x $bitset.scopedname$ object to compare.
     */
    eProsima_user_DllExport bool operator !=(
            const $bitset.name$& x) const
    {
        return !(*this == x);
    }

    $bitset.bitfields:{ bitset | $public_bitfield_declaration(bitset)$}; separator="\n"$

    eProsima_user_DllExport std::bitset<$bitset.fullBitSize$> bitset() const
    {
        std::string str_value;

        $if(bitset.inheritance)$
        str_value = static_cast<const $bitset.inheritance.scopedname$*>(this)->bitset().to_string() + str_value;
        $endif$

        str_value = m_bitset.to_string() + str_value;

        return std::bitset<$bitset.fullBitSize$>(str_value);
    }

    eProsima_user_DllExport void bitset(
            const std::bitset<$bitset.fullBitSize$>& bitset)
    {
        std::string str_value {bitset.to_string()};
        size_t base_diff {0};
        size_t last_post {std::string::npos};

        $if(bitset.inheritance)$
        {
            base_diff += $bitset.inheritance.fullBitSize$;
            std::bitset<$bitset.inheritance.fullBitSize$> internal_bitset(str_value.substr(str_value.length() - base_diff, last_post));
            static_cast<$bitset.inheritance.scopedname$*>(this)->bitset(internal_bitset);
            last_post = base_diff;
        }
        $endif$

        base_diff += $bitset.bitSize$;
        m_bitset = std::bitset<$bitset.bitSize$>(str_value.substr(str_value.length() - base_diff, last_post));
    }

    $extensions : { extension | $extension$}; separator="\n"$

private:

    std::bitset<$bitset.bitSize$> m_bitset;
};
>>

enum_type(ctx, parent, enum) ::= <<
/*!
 * @brief This class represents the enumeration $enum.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
enum $enum.name$ : uint32_t
{
    $enum.members:{ member | $member.name$}; separator=",\n"$
};
>>

bitmask_type(ctx, parent, bitmask) ::= <<
/*!
 * @brief This enumeration represents the $bitmask.name$ bitflags defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
enum $bitmask.name$Bits$bitmask.boundType$
{
    $bitmask.members:{ member | $member.name$ = 0x01ull << $member.position$}; separator=",\n"$
};
typedef $bitmask.castingType$ $bitmask.name$;
>>

fwd_decl(ctx, parent, type) ::= <<
class $type.name$;

>>

/***** Utils *****/

public_struct_inheritances(parent) ::= <<$parent.scopedname$>>

public_bitset_inheritances(parent) ::= <<$parent.scopedname$>>

public_member_declaration(member) ::= <<
$if(member.annotationOptional || member.annotationExternal)$
$public_member_common_declaration(member=member)$
$elseif(member.typecode.primitive)$
$public_member_primitive_declaration(member=member)$
$else$
$public_member_common_declaration(member=member)$
$endif$
>>

public_member_primitive_declaration(member) ::= <<
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
eProsima_user_DllExport void $member.name$(
        $member_type_declaration(member)$ _$member.name$)
{
   $\ $m_$member.name$ = _$member.name$;
}

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 */
eProsima_user_DllExport $member_type_declaration(member)$ $member.name$() const
{
    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
eProsima_user_DllExport $member_type_declaration(member)$& $member.name$()
{
    return m_$member.name$;
}
>>

public_member_common_declaration(member) ::= <<
/*!
 * @brief This function copies the value in member $member.name$
 * @param _$member.name$ New value to be copied in member $member.name$
 */
eProsima_user_DllExport void $member.name$(
        const $member_type_declaration(member)$& _$member.name$)
{
   $\ $m_$member.name$ = _$member.name$;
}

/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
eProsima_user_DllExport void $member.name$(
        $member_type_declaration(member)$&& _$member.name$)
{
   $\ $m_$member.name$ = std::move(_$member.name$);
}

/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 */
eProsima_user_DllExport const $member_type_declaration(member)$& $member.name$() const
{
    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
eProsima_user_DllExport $member_type_declaration(member)$& $member.name$()
{
    return m_$member.name$;
}
>>

public_bitfield_declaration(member) ::= <<
$if(member.name)$
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
eProsima_user_DllExport void $member.name$(
        $member.spec.cppTypename$ _$member.name$)
{
    int base = $member.basePosition$;
$if(member.spec.typecode.isType_7)$
    m_bitset.set(base, _$member.name$);
$else$
    int size = $member.spec.bitSize$;
    for (int i = base; i < base + size; ++i)
    {
        m_bitset.set(i, !!(_$member.name$ & 0x01));
        _$member.name$ = _$member.name$ \>> 1;
    }
$endif$

}

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 */
eProsima_user_DllExport $member.spec.cppTypename$ $member.name$() const
{
    int base = $member.basePosition$;
$if(member.spec.typecode.isType_7)$
    return m_bitset.test(base);
$else$
    int size = $member.spec.bitSize$;
    std::bitset<$member.spec.bitSize$> aux;
    for (int i = 0; i < size; ++i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<$member.spec.cppTypename$>(aux.to_ullong());
$endif$

}
$endif$
>>

private_member_declaration(member) ::= <<
$member_type_declaration(member)$ m_$member.name$$member_default_init(member)$;
>>

public_unionmember_declaration(union, member) ::= <<
$if(member.annotationExternal)$
$public_unionmember_common_declaration(union, member)$
$elseif(member.typecode.primitive)$
$public_unionmember_primitive_declaration(union, member)$
$else$
$public_unionmember_common_declaration(union, member)$
$endif$
>>

public_unionmember_primitive_declaration(union, member) ::= <<
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
eProsima_user_DllExport void $member.name$(
        $member.typecode.cppTypename$ _$member.name$)
{
    m_$member.name$ = _$member.name$;
    $unionmember_set_discriminator(member=member, defaultvalue=union.defaultvalue)$
}

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 * @exception eprosima::fastcdr::exception::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
eProsima_user_DllExport $member.typecode.cppTypename$ $member.name$() const
{
    $unionmember_check_case_list(member=member, totallabels=union.totallabels)$

    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 * @exception eprosima::fastcdr::exception::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
eProsima_user_DllExport $member.typecode.cppTypename$& $member.name$()
{
    $unionmember_check_case_list(member=member, totallabels=union.totallabels)$

    return m_$member.name$;
}
>>

public_unionmember_common_declaration(union, member) ::= <<
/*!
 * @brief This function copies the value in member $member.name$
 * @param _$member.name$ New value to be copied in member $member.name$
 */
eProsima_user_DllExport void $member.name$(
        const $member_type_declaration(member)$& _$member.name$)
{
    m_$member.name$ = _$member.name$;
    $unionmember_set_discriminator(member=member, defaultvalue=union.defaultvalue)$
}

/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
eProsima_user_DllExport void $member.name$(
        $member_type_declaration(member)$&& _$member.name$)
{
    m_$member.name$ = std::move(_$member.name$);
    $unionmember_set_discriminator(member=member, defaultvalue=union.defaultvalue)$
}

/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 * @exception eprosima::fastcdr::exception::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
eProsima_user_DllExport const $member_type_declaration(member)$& $member.name$() const
{
    $unionmember_check_case_list(member=member, totallabels=union.totallabels)$

    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 * @exception eprosima::fastcdr::exception::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
eProsima_user_DllExport $member_type_declaration(member)$& $member.name$()
{
    $unionmember_check_case_list(member=member, totallabels=union.totallabels)$

    return m_$member.name$;
}
>>

member_default_init(member) ::= <%
$if(member.annotationDefault)$
 {$member.annotationDefaultValue$}
$elseif(!member.annotationOptional && !member.annotationExternal)$
$if(member.typecode.initialValue)$
 {$member.typecode.initialValue$}
$endif$
$endif$
%>

member_move(member) ::= <%
$if(member.typecode.primitive)$
m_$member.name$ = x.m_$member.name$;
$else$
m_$member.name$ = std::move(x.m_$member.name$);
$endif$
%>

unionmember_discriminator_case(member, totallabels) ::= <<
$if(member.default)$
default:
    b = true;
    switch (__d)
    {
        $totallabels:{ label | case $label$:}; separator="\n"$
            b = false;
            break;
        default:
            break;
    }
    break;
$else$
$member.labels:{ label | case $label$:}; separator="\n"$
    switch (__d)
    {
        $member.labels:{ label | case $label$:}; separator="\n"$
            b = true;
            break;
        default:
            break;
    }
    break;
$endif$
>>

unionmember_copy(member) ::= <<
$if(member.labels)$
$member.labels:{ label | case $label$:}; separator="\n"$
    m_$member.name$ = x.m_$member.name$;
    break;
$endif$
>>

unionmemberdefault_copy(member) ::= <<
default:
$if(member)$
$if(member.default)$
    m_$member.name$ = x.m_$member.name$;
$endif$
$endif$

    break;
>>

unionmember_move(member) ::= <<
$if(member.labels)$
$member.labels:{ label | case $label$:}; separator="\n"$
$if(member.typecode.primitive)$
    m_$member.name$ = x.m_$member.name$;
$else$
    m_$member.name$ = std::move(x.m_$member.name$);
$endif$

    break;
$endif$
>>

unionmemberdefault_move(member) ::= <<
default:
$if(member)$
$if(member.default)$
$if(member.typecode.primitive)$
    m_$member.name$ = x.m_$member.name$;
$else$
    m_$member.name$ = std::move(x.m_$member.name$);
$endif$
$endif$
$endif$

    break;
>>

unionmember_compare(member) ::= <<
$if(member.labels)$
$member.labels:{ label | case $label$:}; separator="\n"$
    return (m_$member.name$ == x.m_$member.name$);
    break;
$endif$
>>

unionmemberdefault_compare(member) ::= <<
default:
$if(member)$
$if(member.default)$
    return m_$member.name$ == x.m_$member.name$;
$endif$
$endif$

    break;
>>

unionmember_set_discriminator(member, defaultvalue) ::= <<
$if(member.default)$
m__d = $defaultvalue$;
$else$
m__d = $first(member.labels)$;
$endif$
>>

unionmember_check_case_list(member, totallabels) ::= <<
$if(member.default)$
bool b = true;

switch (m__d)
{
    $totallabels:{ label | case $label$:}; separator="\n"$
        b = false;
        break;
    default:
        break;
}
$else$
bool b = false;

switch (m__d)
{
    $member.labels:{ label | case $label$:}; separator="\n"$
        b = true;
        break;
    default:
        break;
}
$endif$

if (!b)
{
    throw eprosima::fastcdr::exception::BadParamException("This member has not been selected");
}
>>

//{ Fast DDS-Gen extensions
module_conversion(ctx, parent, modules, definition_list) ::= <<
$modules : { module |
namespace $module.name$ {
}; separator="\n"$

$definition_list$

$reverse(modules) : { module |
\} // namespace $module.name$
}; separator="\n"$
>>
//}
