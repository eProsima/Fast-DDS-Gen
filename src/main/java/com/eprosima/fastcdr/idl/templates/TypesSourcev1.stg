// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group TypesSource;

import "com/eprosima/fastdds/idl/templates/eprosima.stg"
import "FastCdrCommon.stg"

main(ctx, definitions, extensions) ::= <<
$fileHeader(ctx=ctx, file=[ctx.filename, ".cpp"], description=["This source file contains the implementation of the described types in the IDL file."])$

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "$ctx.filename$.h"

$if(ctx.cdr_both)$
#if FASTCDR_VERSION_MAJOR == 1
$endif$

$if(ctx.generateTypeObject)$
#include "$ctx.filename$TypeObject.h"
$endif$

$if(ctx.cdr)$
#include <fastcdr/Cdr.h>

$endif$

$if(ctx.fastcdr)$
#include <fastcdr/FastCdr.h>

$endif$

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace helper { namespace internal {

enum class Size {
    UInt8,
    UInt16,
    UInt32,
    UInt64,
};

constexpr Size get_size(int s) {
    return (s <= 8 ) ? Size::UInt8:
           (s <= 16) ? Size::UInt16:
           (s <= 32) ? Size::UInt32: Size::UInt64;
}

template<Size s>
struct FindTypeH;

template<>
struct FindTypeH<Size::UInt8> {
    using type = std::uint8_t;
};

template<>
struct FindTypeH<Size::UInt16> {
    using type = std::uint16_t;
};

template<>
struct FindTypeH<Size::UInt32> {
    using type = std::uint32_t;
};

template<>
struct FindTypeH<Size::UInt64> {
    using type = std::uint64_t;
};
}

template<int S>
struct FindType {
    using type = typename internal::FindTypeH<internal::get_size(S)>::type;
};
}

$if(ctx.anyCdr)$
$ctx.setCdrv1Templates$
$ctx.types:{ type | $if(type.typeCode.isStructType)$#define $type.typeCode.cScopedname$_max_cdr_typesize $type.typeCode.maxSerializedSize$ULL;$endif$}; separator="\n"$
$ctx.unsetCdrv1Templates$
$endif$

$extensions : { extension | $extension$}; separator="\n"$

$if(ctx.generateTypesC)$
$ctx.typeCodesToDefine : { type |
$sequences_definition(type.value)$
}; separator="\n"$
$endif$

$definitions; separator="\n"$

$if(ctx.cdr_both)$
#endif // FASTCDR_VERSION_MAJOR == 1
$endif$
>>

module(ctx, parent, module, definition_list) ::= <<
namespace $module.name$ {

$definition_list$

} // namespace $module.name$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$

>>

annotation(ctx, annotation) ::= <<>>

interface(ctx, parent, interface, export_list) ::= <<
$export_list$
>>

export_list(exports) ::= <<
$exports; separator="\n"$

>>

exception(ctx, parent, exception) ::= <<
$if(ctx.printexception)$
$exception.name$::$exception.name$()
    : UserException()
{
    $exception.members : { member |$member_default_init(ctx=ctx, member=member, loopvar=ctx.newLoopVarName)$}; separator="\n"$
}

$exception.name$::$exception.name$(
        const $exception.name$& x)
    : UserException(x)
{
    $exception.members : { member |$member_copy(ctx=ctx, member=member)$}; separator="\n"$
}

$exception.name$::$exception.name$(
        $exception.name$&& x)
    : UserException(std::move(x))
{
    $exception.members : { member |$member_move(member=member)$}; separator="\n"$
}

$exception.name$& $exception.name$::operator =(
        const $exception.name$& x)
{
    UserException::operator =(x);
    $exception.members : { member |$member_copy(ctx=ctx, member=member)$}; separator="\n"$
    return *this;
}

$exception.name$& $exception.name$::operator =(
        $exception.name$&& x)
{
    UserException::operator =(std::move(x));
    $exception.members : { member |$member_move(member=member)$}; separator="\n"$
    return *this;
}

$exception.name$::~$exception.name$() throw()
{
    $exception.members : { member |$varDel(variable=member)$}; separator="\n"$
}

void $exception.name$::raise() const
{
    throw *this;
}

$if(ctx.anyCdr)$
size_t $exception.name$::getCdrSerializedSize(
        const $exception.name$& data,
        size_t current_alignment)
{
    static_cast<void>(data);
    size_t initial_alignment = current_alignment;

    $exception.members : { member |$serialized_size(ctx=ctx, object=member, data="data", var="current_alignment")$}; separator="\n"$

    return current_alignment - initial_alignment;
}

$endif$

$if(ctx.cdr)$
void $exception.name$::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    $exception.members : { member |$object_serialization(ctx=ctx, object=member, preffix="m_")$}; separator=""$
}

void $exception.name$::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    $exception.members : { member |$object_deserialization(ctx=ctx, object=member, preffix="m_")$}; separator="\n"$
}

$endif$

$if(ctx.fastcdr)$
void $exception.name$::serialize(
        eprosima::fastcdr::FastCdr& scdr) const
{
    $exception.members : { member |$object_serialization(ctx=ctx, object=member, preffix="m_")$}; separator=""$
}

void $exception.name$::deserialize(
        eprosima::fastcdr::FastCdr& dcdr)
{
    $exception.members : { member |$object_deserialization(ctx=ctx, object=member, preffix="m_")$}; separator="\n"$
}

$endif$

$endif$
>>

operation(ctx, parent, operation, param_list) ::= <<>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

const_decl(ctx, parent, const, const_type) ::= <<
$ctx.setCdrv1Templates$
$const_type$
$if(const.parent)$
$if(const.parent.isInterface)$
$if(const.typeCode.isType_5)$
const $const.typeCode.cppTypename$ $const.parent.scopedname$::$const.name$ = $const.value$;
$elseif(const.typeCode.isType_6)$
const $const.typeCode.cppTypename$ $const.parent.scopedname$::$const.name$ = $const.value$;
$endif$
$endif$
$endif$
$ctx.unsetCdrv1Templates$
>>

fwd_decl(ctx, parent, type) ::= <<>>

typedef_decl(ctx, parent, typedefs, typedefs_type, declarator_type) ::= <<
$ctx.setCdrv1Templates$
$declarator_type$
$typedefs_type$
$typedefs :
{ typedef |
$if(ctx.generateTypesC)$
$if(typedef.typedefContentTypeCode.isSequenceType)$
$sequences_definition_impl(typecode=typedef.typedefContentTypeCode, scopedtypename=typedef.scopedname, typename=typedef.name)$
$endif$
$endif$
}; separator="\n"$
$ctx.unsetCdrv1Templates$
>>

struct_type(ctx, parent, struct, extensions, member_list) ::= <<
$ctx.setCdrv1Templates$
$member_list$
$struct.name$::$struct.name$()
    $if(struct.inheritance)$
    : $struct_inherit_default_init(struct.inheritance)$
    $endif$
{
    $struct.members:{ member |$member_default_init(ctx=ctx, member=member, loopvar=ctx.newLoopVarName)$}; separator="\n"$

    $if(ctx.generateTypeObject)$
    // Just to register all known types
    register$ctx.filename$Types();
    $endif$
}

$struct.name$::~$struct.name$()
{
    $struct.members:{ member |$member_destructor(ctx=ctx, member=member)$}; separator="\n"$
}

$struct.name$::$struct.name$(
        const $struct.name$& x)
    $if(struct.inheritance)$
    : $struct_inherit_copy_init(struct.inheritance)$
    $endif$
{
    $if(struct.members)$
    $struct.members:{ member | $member_copy(ctx=ctx, member=member)$}; separator="\n"$
    $else$
    static_cast<void>(x);
    $endif$
}

$struct.name$::$struct.name$(
        $struct.name$&& x) noexcept
    $if(struct.inheritance)$
    : $struct_inherit_move_init(struct.inheritance)$
    $endif$
{
    $if(struct.members)$
    $struct.members:{ member | $member_move(member=member)$}; separator="\n"$
    $else$
    static_cast<void>(x);
    $endif$
}

$struct.name$& $struct.name$::operator =(
        const $struct.name$& x)
{
    $if(struct.inheritance)$
        $struct.inheritance.scopedname$::operator =(x);
    $endif$

    $if(struct.members)$
    $struct.members:{ member | $member_copy(ctx=ctx, member=member)$}; separator="\n"$
    $else$
    static_cast<void>(x);
    $endif$

    return *this;
}

$struct.name$& $struct.name$::operator =(
        $struct.name$&& x) noexcept
{
    $if(struct.inheritance)$
        $struct.inheritance.scopedname$::operator =(std::move(x));
    $endif$

    $if(struct.members)$
    $struct.members:{ member | $member_move(member=member)$}; separator="\n"$
    $else$
    static_cast<void>(x);
    $endif$

    return *this;
}

bool $struct.name$::operator ==(
        const $struct.name$& x) const
{
    $if(struct.inheritance)$
        if ($struct.inheritance.scopedname$::operator !=(x)) return false;
    $endif$

    $if(!struct.members)$
    static_cast<void>(x);
    return true;
    $else$
    return ($struct.members:{ member | m_$member.name$ == x.m_$member.name$}; separator=" &&\n           "$);
    $endif$
}

bool $struct.name$::operator !=(
        const $struct.name$& x) const
{
    return !(*this == x);
}

$if(ctx.anyCdr)$
size_t $struct.name$::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return $struct.cScopedname$_max_cdr_typesize;
}

size_t $struct.name$::getCdrSerializedSize(
        const $struct.name$& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    $if(struct.inheritance)$
        current_alignment += $struct.inheritance.scopedname$::getCdrSerializedSize(data, current_alignment);
    $endif$

    $struct.members : { member |$if(!member.annotationNonSerialized)$$serialized_size(ctx=ctx, object=member, data="data", var="current_alignment")$$endif$}; separator="\n"$

    return current_alignment - initial_alignment;
}

$endif$

$if(ctx.cdr)$
void $struct.name$::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    $if(struct.inheritance)$
        $struct.inheritance.scopedname$::serialize(scdr);
    $endif$

    $if(struct.members)$
    $struct.members : { member |$if(!member.annotationNonSerialized)$$object_serialization(ctx=ctx, object=member, preffix="m_")$$endif$}; separator=""$
    $else$
    static_cast<void>(scdr);
    $endif$
}

void $struct.name$::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    $if(struct.inheritance)$
        $struct.inheritance.scopedname$::deserialize(dcdr);
    $endif$

    $if(struct.members)$
    $struct.members : { member |$if(!member.annotationNonSerialized)$$object_deserialization(ctx=ctx, object=member, preffix="m_")$$endif$}; separator="\n"$
    $else$
    static_cast<void>(dcdr);
    $endif$
}

$endif$

$if(ctx.fastcdr)$
void $struct.name$::serialize(
        eprosima::fastcdr::FastCdr &scdr) const
{
    $if(struct.inheritance)$
        $struct.inheritance.scopedname$::serialize(scdr);
    $endif$

    $struct.members : { member |$if(!member.annotationNonSerialized)$$object_serialization(ctx=ctx, object=member, preffix="m_")$$endif$}; separator=""$
}

void $struct.name$::deserialize(
        eprosima::fastcdr::FastCdr& dcdr)
{
    $if(struct.inheritance)$
        $struct.inheritance.scopedname$::deserialize(dcdr);
    $endif$

    $struct.members : { member |$if(!member.annotationNonSerialized)$$object_deserialization(ctx=ctx, object=member, preffix="m_")$$endif$}; separator="\n"$
}

$endif$

bool $struct.name$::isKeyDefined()
{
    $if(struct.inheritance)$
    if ($struct.inheritance.scopedname$::isKeyDefined())
        return true;
    $endif$

    return $if(struct.hasKey)$true$else$false$endif$;
}

void $struct.name$::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
    $if(struct.inheritance)$ $struct.inheritance.scopedname$::serializeKey(scdr);$endif$
    $if(struct.hasKey)$ $struct.members : { member | $if(member.annotationKey)$ $if(member.typecode.isStructType)$ $if(member.typecode.hasKey)$ m_$member.name$.serializeKey(scdr); $else$ m_$member.name$.serialize(scdr); $endif$ $else$ $object_serialization(ctx=ctx, object=member, preffix="m_")$ $endif$ $endif$ }; separator="\n"$ $endif$
}

$struct.members:{ member | $public_member_declaration(class=struct.name, member=member)$}; separator="\n"$

$extensions : { extension | $extension$}; separator="\n"$
$ctx.unsetCdrv1Templates$
>>

bitset_type(ctx, parent, bitset) ::= <<
$bitset.name$::$bitset.name$()
    $if(bitset.inheritance)$
    : $bitset_inherit_default_init(bitset.inheritance)$
    $endif$
{
    $if(ctx.generateTypeObject)$
    // Just to register all known types
    register$ctx.filename$Types();
    $endif$
}

$bitset.name$::~$bitset.name$()
{
}

$bitset.name$::$bitset.name$(
        const $bitset.name$& x)
    $if(bitset.inheritance)$
    : $bitset_inherit_copy_init(bitset.inheritance)$
    $endif$
{
    m_bitset = x.m_bitset;
}

$bitset.name$::$bitset.name$(
        $bitset.name$&& x) noexcept
    $if(bitset.inheritance)$
    : $bitset_inherit_move_init(bitset.inheritance)$
    $endif$
{
    m_bitset = x.m_bitset;
}

$bitset.name$& $bitset.name$::operator =(
        const $bitset.name$& x)
{
    $if(bitset.inheritance)$
        $bitset.inheritance.scopedname$::operator =(x);
    $endif$

    m_bitset = x.m_bitset;

    return *this;
}

$bitset.name$& $bitset.name$::operator =(
        $bitset.name$&& x) noexcept
{
    $if(bitset.inheritance)$
        $bitset.inheritance.scopedname$::operator =(std::move(x));
    $endif$

    m_bitset = x.m_bitset;

    return *this;
}

bool $bitset.name$::operator ==(
        const $bitset.name$& x) const
{
    $if(bitset.inheritance)$
        if ($bitset.inheritance.scopedname$::operator !=(x)) return false;
    $endif$

    return m_bitset == x.m_bitset;
}

bool $bitset.name$::operator !=(
        const $bitset.name$& x) const
{
    return !(*this == x);
}

$if(ctx.anyCdr)$
size_t $bitset.name$::getCdrSerializedSize(
        const $bitset.name$&,
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += sizeof(helper::FindType<$bitset.fullBitSize$>::type)$if(ctx.cdr)$ +
        eprosima::fastcdr::Cdr::alignment(current_alignment, sizeof(helper::FindType<$bitset.fullBitSize$>::type))$endif$;

    return current_alignment - initial_alignment;
}

$endif$

$if(ctx.cdr)$
void $bitset.name$::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    $if(!bitset.scope.empty)$
    using namespace $bitset.scope$;
    $endif$

    helper::FindType<$bitset.fullBitSize$>::type bits = static_cast<helper::FindType<$bitset.fullBitSize$>::type>(bitset().to_ullong());
    scdr << bits;
}

void $bitset.name$::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    $if(!bitset.scope.empty)$
    using namespace $bitset.scope$;
    $endif$

    helper::FindType<$bitset.fullBitSize$>::type bits;
    dcdr \>> bits;
    bitset(std::bitset<$bitset.fullBitSize$>(bits));
}

$endif$

$if(ctx.fastcdr)$
void $bitset.name$::serialize(
        eprosima::fastcdr::FastCdr& scdr) const
{
    $if(!bitset.scope.empty)$
    using namespace $bitset.scope$;
    $endif$

    helper::FindType<$bitset.fullBitSize$>::type bits = static_cast<helper::FindType<$bitset.fullBitSize$>::type>(bitset().to_ullong());
    scdr << bits;
}

void $bitset.name$::deserialize(
        eprosima::fastcdr::FastCdr& dcdr)
{
    $if(!bitset.scope.empty)$
    using namespace $bitset.scope$;
    $endif$

    helper::FindType<$bitset.fullBitSize$>::type bits;
    dcdr \>> bits;
    bitset(std::bitset<$bitset.fullBitSize$>(bits));
}

$endif$


$bitset.bitfields:{ bitfield | $public_bitfield_definition(bitfield)$}; separator="\n"$

std::bitset<$bitset.fullBitSize$> $bitset.name$::bitset() const
{
    std::string str_value;

    $if(bitset.inheritance)$
    str_value = static_cast<const $bitset.inheritance.scopedname$*>(this)->bitset().to_string() + str_value;
    $endif$

    str_value = m_bitset.to_string() + str_value;

    return std::bitset<$bitset.fullBitSize$>(str_value);
}

void $bitset.name$::bitset(
        const std::bitset<$bitset.fullBitSize$>& bitset)
{
    std::string str_value {bitset.to_string()};
    size_t base_diff {0};
    size_t last_post {std::string::npos};

    $if(bitset.inheritance)$
    {
        base_diff += $bitset.inheritance.fullBitSize$;
        std::bitset<$bitset.inheritance.fullBitSize$> internal_bitset(str_value.substr(str_value.length() - base_diff, last_post));
        static_cast<$bitset.inheritance.scopedname$*>(this)->bitset(internal_bitset);
        last_post = base_diff;
    }
    $endif$

    base_diff += $bitset.bitSize$;
    m_bitset = std::bitset<$bitset.bitSize$>(str_value.substr(str_value.length() - base_diff, last_post));
}

>>

public_bitfield_definition(member) ::= <<
$if(member.name)$
void $bitset.scopedname$::$member.name$(
        $member.spec.cppTypename$ _$member.name$)
{
    int base = $member.basePosition$;
$if(member.spec.typecode.isType_7)$
    m_bitset.set(base, _$member.name$);
$else$
    int size = $member.spec.bitSize$;
    for (int i = base; i < base + size; ++i)
    {
        m_bitset.set(i, !!(_$member.name$ & 0x01));
        _$member.name$ = _$member.name$ \>> 1;
    }
$endif$

}

$member.spec.cppTypename$ $bitset.scopedname$::$member.name$() const
{
    int base = $member.basePosition$;
$if(member.spec.typecode.isType_7)$
    return m_bitset.test(base);
$else$
    int size = $member.spec.bitSize$;
    std::bitset<$member.spec.bitSize$> aux;
    for (int i = 0; i < size; ++i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<$member.spec.cppTypename$>(aux.to_ullong());
$endif$

}
$endif$

>>

union_type(ctx, parent, union, extensions, switch_type) ::= <<
$ctx.setCdrv1Templates$
$switch_type$
$union.name$::$union.name$()
{
    $if(union.defaultvalue)$
    m__d = $union.defaultvalue$;
    $else$
    m__d = $first(first(union.members).labels)$;
    $endif$
    $union.members:{ member |$member_default_init(ctx=ctx, member=member, loopvar=ctx.newLoopVarName)$}; separator="\n"$
}

$union.name$::~$union.name$()
{
}

$union.name$::$union.name$(
        const $union.name$& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        $union.members:{ member | $unionmember_copy(member)$}; separator="\n"$
        $unionmemberdefault_copy(union.defaultMember)$
    }
}

$union.name$::$union.name$(
        $union.name$&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        $union.members:{ member | $unionmember_move(member)$}; separator="\n"$
        $unionmemberdefault_move(union.defaultMember)$
    }
}

$union.name$& $union.name$::operator =(
        const $union.name$& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        $union.members:{ member | $unionmember_copy(member)$}; separator="\n"$
        $unionmemberdefault_copy(union.defaultMember)$
    }

    return *this;
}

$union.name$& $union.name$::operator =(
        $union.name$&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        $union.members:{ member | $unionmember_move(member)$}; separator="\n"$
        $unionmemberdefault_move(union.defaultMember)$
    }

    return *this;
}

bool $union.name$::operator ==(
        const $union.name$& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        $union.members:{ member | $unionmember_compare(member)$}; separator="\n"$
        $unionmemberdefault_compare(union.defaultMember)$
    }
    return false;
}

bool $union.name$::operator !=(
        const $union.name$& x) const
{
    return !(*this == x);
}

void $union.name$::_d(
        $union.discriminator.cppTypename$ __d)
{
    bool b = false;

    switch(m__d)
    {
        $union.members:{ member | $unionmember_discriminator_case(member=member, totallabels=union.totallabels)$}; separator="\n"$
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

$union.discriminator.cppTypename$ $union.name$::_d() const
{
    return m__d;
}

$union.discriminator.cppTypename$& $union.name$::_d()
{
    return m__d;
}

$union.members:{ member | $public_unionmember_declaration(class=union.name, member=member, defaultvalue=union.defaultvalue, totallabels=union.totallabels)$}; separator="\n"$

$if(ctx.anyCdr)$
// TODO(Ricardo) Review
size_t $union.name$::getCdrSerializedSize(
        const $union.name$& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    $serialized_size_type(ctx=ctx, typecode=union.discriminator, var="current_alignment")$

    switch(data.m__d)
    {
        $union.members:{ member |$unionmember_case_selection_sesize(ctx=ctx, member=member, data="data", var="current_alignment")$}; separator="\n"$
        $unionmemberdefault_case_selection_sesize(ctx=ctx, member=union.defaultMember, data="data", var="current_alignment")$
    }

    return current_alignment - initial_alignment;
}

$endif$

$if(ctx.cdr)$
void $union.name$::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << $serializeCasting(typecode=union.discriminator)$m__d;

    switch(m__d)
    {
        $union.members:{ member |$unionmember_case_selection_se(ctx=ctx, member=member)$}; separator="\n"$
        $unionmemberdefault_case_selection_se(ctx=ctx, member=union.defaultMember)$
    }
}

void $union.name$::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    $deserializePossibleEnum(typecode=union.discriminator, name="m__d", preffix="")$

    switch(m__d)
    {
        $union.members:{ member |$unionmember_case_selection_de(ctx=ctx, member=member)$}; separator="\n"$
        $unionmemberdefault_case_selection_de(ctx=ctx, member=union.defaultMember)$
    }
}

$endif$

$if(ctx.fastcdr)$
void $union.name$::serialize(
        eprosima::fastcdr::FastCdr& scdr) const
{
    scdr << $serializeCasting(typecode=union.discriminator)$m__d;

    switch(m__d)
    {
        $union.members:{ member |$unionmember_case_selection_se(ctx=ctx, member=member)$}; separator="\n"$
        $unionmemberdefault_case_selection_se(ctx=ctx, member=union.defaultMember)$
    }
}

void $union.name$::deserialize(
        eprosima::fastcdr::FastCdr& dcdr)
{
    $deserializePossibleEnum(typecode=union.discriminator, name="m__d", preffix="")$

    switch(m__d)
    {
        $union.members:{ member |$unionmember_case_selection_de(ctx=ctx, member=member)$}; separator="\n"$
        $unionmemberdefault_case_selection_de(ctx=ctx, member=union.defaultMember)$
    }
}

$endif$

$ctx.unsetCdrv1Templates$
>>

enum_type(ctx, parent, enum) ::= <<>>

bitmask_type(ctx, parent, bitmask) ::= <<>>

sequence_type(ctx, sequence, type_sequence) ::= <<

$type_sequence$

>>

map_type(ctx, map, key_type, value_type) ::= <<

$key_type$
$value_type$

>>

string_type(ctx, string) ::= <<>>

wide_string_type(ctx, wstring) ::= <<>>

array_declarator(ctx, array, array_type) ::= <<>>

member_type(ctx, member, type_member, declarators) ::= <<

$type_member$
$declarators$

>>

element_type(ctx, element, type_element, declarator) ::= <<

$type_element$
$declarator$

>>

/***** Utils *****/

public_member_declaration(class, member) ::= <<
$if(member.typecode.primitive)$
$public_primitive_member_declaration(class=class, member=member)$
$elseif(ctx.generateTypesC)$
$if(member.typecode.isStringType)$
$public_cstring_member_declaration(class=class, member=member)$
$else$
$public_object_member_declaration(class=class, member=member)$
$endif$
$else$
$public_object_member_declaration(class=class, member=member)$
$endif$
>>

public_primitive_member_declaration(class, member) ::= <<
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
void $class$::$member.name$(
        $member.typecode.cppTypename$ _$member.name$)
{
    m_$member.name$ = _$member.name$;
}

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 */
$member.typecode.cppTypename$ $class$::$member.name$() const
{
    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
$member.typecode.cppTypename$& $class$::$member.name$()
{
    return m_$member.name$;
}
>>

public_cstring_member_declaration(class, member) ::= <<
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
void $class$::$member.name$(
        const $member.typecode.cppTypename$ _$member.name$)
{
    free(m_$member.name$);
    m_$member.name$ = (char*)malloc(sizeof(char) * (strlen(_$member.name$) + 1));
    strncpy(m_$member.name$, _$member.name$, strlen(_$member.name$) + 1);
}

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 */
const $member.typecode.cppTypename$ $class$::$member.name$() const
{
    return m_$member.name$;
}
>>

public_object_member_declaration(class, member) ::= <<
/*!
 * @brief This function copies the value in member $member.name$
 * @param _$member.name$ New value to be copied in member $member.name$
 */
void $class$::$member.name$(
        const $member.typecode.cppTypename$& _$member.name$)
{
    m_$member.name$ = _$member.name$;
}

/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
void $class$::$member.name$(
        $member.typecode.cppTypename$&& _$member.name$)
{
    m_$member.name$ = std::move(_$member.name$);
}

/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 */
const $member.typecode.cppTypename$& $class$::$member.name$() const
{
    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
$member.typecode.cppTypename$& $class$::$member.name$()
{
    return m_$member.name$;
}
>>

public_unionmember_declaration(class, member, totallabels, defaultvalue) ::= <<
$if(ctx.generateTypesC)$$if(member.typecode.isStringType)$$unionmember_cstring_declaration(class=class, member=member, totallabels=totallabels, defaultvalue=defaultvalue)$$else$$public_unionmember_cpp_declaration(class=class, member=member, totallabels=totallabels, defaultvalue=defaultvalue)$$endif$$else$$public_unionmember_cpp_declaration(class=class, member=member, totallabels=totallabels, defaultvalue=defaultvalue)$$endif$
>>

unionmember_cstring_declaration(class, member, totallabels, defaultvalue) ::= <<
void $class$::$member.name$(
        const char* _$member.name$)
{
    free(m_$member.name$);
    m_$member.name$ = (char*)malloc(sizeof(char) * (strlen(_$member.name$) + 1));
    strncpy(m_$member.name$, _$member.name$, strlen(_$member.name$));
    $unionmember_set_discriminator(member=member, defaultvalue=defaultvalue)$
}

const char* $class$::$member.name$() const
{
    $unionmember_check_case_list(member=member, totallabels=totallabels)$

    return m_$member.name$;
}
>>

public_unionmember_cpp_declaration(class, member, totallabels, defaultvalue) ::= <<
$if(member.typecode.primitive)$
void $class$::$member.name$(
        $member.typecode.cppTypename$ _$member.name$)
{
    m_$member.name$ = _$member.name$;
    $unionmember_set_discriminator(member=member, defaultvalue=defaultvalue)$
}

$member.typecode.cppTypename$ $class$::$member.name$() const
{
    $unionmember_check_case_list(member=member, totallabels=totallabels)$

    return m_$member.name$;
}

$member.typecode.cppTypename$& $class$::$member.name$()
{
    $unionmember_check_case_list(member=member, totallabels=totallabels)$

    return m_$member.name$;
}
$else$
void $class$::$member.name$(
        const $member.typecode.cppTypename$& _$member.name$)
{
    m_$member.name$ = _$member.name$;
    $unionmember_set_discriminator(member=member, defaultvalue=defaultvalue)$
}

void $class$::$member.name$(
        $member.typecode.cppTypename$&& _$member.name$)
{
    m_$member.name$ = std::move(_$member.name$);
    $unionmember_set_discriminator(member=member, defaultvalue=defaultvalue)$
}

const $member.typecode.cppTypename$& $class$::$member.name$() const
{
    $unionmember_check_case_list(member=member, totallabels=totallabels)$

    return m_$member.name$;
}

$member.typecode.cppTypename$& $class$::$member.name$()
{
    $unionmember_check_case_list(member=member, totallabels=totallabels)$

    return m_$member.name$;
}
$endif$
>>

member_copy(ctx, member) ::= <<
$if(ctx.generateTypesC)$
$if(member.typecode.isStringType)$
free(m_$member.name$);
m_$member.name$ = (char*)malloc(sizeof(char) * (strlen(x.m_$member.name$) + 1));
strncpy(m_$member.name$, x.m_$member.name$, strlen(x.m_$member.name$) + 1);
$else$
m_$member.name$ = x.m_$member.name$;
$endif$
$else$
m_$member.name$ = x.m_$member.name$;
$endif$
>>

member_move(member) ::= <<
$if(member.typecode.primitive)$
m_$member.name$ = x.m_$member.name$;
$else$
m_$member.name$ = std::move(x.m_$member.name$);
$endif$
>>

// TODO Mirar si el default: esta delante de otros casos, el resto no se ejecuta.
unionmember_discriminator_case(member, totallabels) ::= <<
$if(member.default)$
default:
b = true;
switch(__d)
{
    $totallabels:{ label | case $label$:}; separator="\n"$
    b = false;
    break;
    default:
    break;
}
break;
$else$
$member.labels:{ label | case $label$:}; separator="\n"$
switch(__d)
{
    $member.labels:{ label | case $label$:}; separator="\n"$
    b = true;
    break;
    default:
    break;
}
break;
$endif$
>>

unionmember_copy(member) ::= <<
$if(member.labels)$
$member.labels:{ label | case $label$:}; separator="\n"$
m_$member.name$ = x.m_$member.name$;
break;
$endif$
>>

unionmemberdefault_copy(member) ::= <<
default:
$if(member)$
$if(member.default)$
m_$member.name$ = x.m_$member.name$;
$endif$
$endif$

break;
>>

unionmember_move(member) ::= <<
$if(member.labels)$
$member.labels:{ label | case $label$:}; separator="\n"$
$if(member.typecode.primitive)$
m_$member.name$ = x.m_$member.name$;
$else$
m_$member.name$ = std::move(x.m_$member.name$);
$endif$

break;
$endif$
>>

unionmemberdefault_move(member) ::= <<
default:
$if(member)$
$if(member.default)$
$if(member.typecode.primitive)$
m_$member.name$ = x.m_$member.name$;
$else$
m_$member.name$ = std::move(x.m_$member.name$);
$endif$
$endif$
$endif$

break;
>>

unionmember_compare(member) ::= <<
$if(member.labels)$
$member.labels:{ label | case $label$:}; separator="\n"$
    return (m_$member.name$ == x.m_$member.name$);
    break;
$endif$
>>

unionmemberdefault_compare(member) ::= <<
default:
$if(member)$
$if(member.default)$
return m_$member.name$ == x.m_$member.name$;
$endif$
$endif$

break;
>>

unionmember_set_discriminator(member, defaultvalue) ::= <<
$if(member.default)$
m__d = $defaultvalue$;
$else$
m__d = $first(member.labels)$;
$endif$
>>

unionmember_check_case_list(member, totallabels) ::= <<
$if(member.default)$
bool b = true;

switch(m__d)
{
    $totallabels:{label | case $label$:}; separator="\n"$
    b = false;
    break;
    default:
    break;
}
$else$
bool b = false;

switch(m__d)
{
    $member.labels:{ label | case $label$:}; separator="\n"$
    b = true;
    break;
    default:
    break;
}
$endif$

if(!b)
{
    throw BadParamException("This member has not been selected");
}
>>

unionmember_case_selection_se(ctx, member) ::= <<
$if(member.labels)$
$member.labels:{ label |case $label$:}; separator="\n"$
$object_serialization(ctx=ctx, object=member, preffix="m_")$
break;
$endif$
>>

unionmemberdefault_case_selection_se(ctx, member) ::= <<
default:
$if(member)$
$if(member.default)$
$object_serialization(ctx=ctx, object=member, preffix="m_")$
$endif$
$endif$

break;
>>

unionmember_case_selection_de(ctx, member) ::= <<
$if(member.labels)$
$member.labels:{ label |case $label$:}; separator="\n"$
$object_deserialization(ctx=ctx, object=member, preffix="m_")$
break;
$endif$
>>

unionmemberdefault_case_selection_de(ctx, member) ::= <<
default:
$if(member)$
$if(member.default)$
$object_deserialization(ctx=ctx, object=member, preffix="m_")$
$endif$
$endif$

break;
>>

unionmember_case_selection_sesize(ctx, member, data, var) ::= <<
$if(member.labels)$
$member.labels:{ label |case $label$:}; separator="\n"$
$serialized_size(ctx=ctx, object=member, data=data, var=var)$
break;
$endif$
>>

unionmemberdefault_case_selection_sesize(ctx, member, data, var) ::= <<
default:
$if(member)$
$if(member.default)$
$serialized_size(ctx=ctx, object=member, data=data, var=var)$
$endif$
$endif$

break;
>>

sequences_definition(typecode) ::= <<
$sequences_definition_impl(typecode=typecode, scopedtypename=typecode.cppTypename, typename=typecode.cppTypename)$
>>

sequences_definition_impl(typecode, scopedtypename, typename) ::= <<

$scopedtypename$::$typename$()
{
    // value_ = new $typecode.contentTypeCode.cppTypename$[maximum_];
    value_ = nullptr;
}

$scopedtypename$::$typename$(
        uint32_t maximum)
    : maximum_(maximum)
{
    // value_ = new $typecode.contentTypeCode.cppTypename$[maximum_];
    value_ = nullptr;
}

$scopedtypename$::$typename$(
        uint32_t length,
        $typecode.contentTypeCode.cppTypename$* data,
        bool release)
    : length_(length)
    , value_(data)
    , release_(release)
{
}

$scopedtypename$::$typename$(
        const $typename$& $typename$_)
    : maximum_($typename$_.maximum_)
    , length_($typename$_.length_)
    , release_(true)
{
    value_ = new $typecode.contentTypeCode.cppTypename$[length_];
    for (uint32_t i = 0; i < length_; ++i)
    {
        $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
        strncpy(value_[i], $typename$_.value_[i], strlen($typename$_.value_[i]) + 1);
        $else$
        value_[i] = $typename$_.value_[i];$endif$$else$
        value_[i] = $typename$_.value_[i];$endif$
    }
}

$scopedtypename$& $scopedtypename$::operator =(
        const $typename$& $typename$_)
{
    maximum_ = $typename$_.maximum_;
    length_ = $typename$_.length_;
    free_memory();
    release_ = true;

    value_ = new $typecode.contentTypeCode.cppTypename$[length_];
    for (uint32_t i = 0; i < length_; ++i)
    {
        $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
        strncpy(value_[i], $typename$_.value_[i], strlen($typename$_.value_[i]) + 1);
        $else$
        value_[i] = $typename$_.value_[i];$endif$$else$
        value_[i] = $typename$_.value_[i];$endif$
    }

    return *this;
}

$scopedtypename$::~$typename$()
{
    free_memory();
}

$typecode.contentTypeCode.cppTypename$$if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$$else$&$endif$$else$&$endif$ $scopedtypename$::operator[](
        uint32_t index)
{
    if (value_ == nullptr)
    {
        if (maximum_ == 0)
        {
            if (length_ != 0) // Must be set. If not, will return nullptr[index] and crash.
            {
                value_ = new $typecode.contentTypeCode.cppTypename$[length_];
            }
        }
        else
        {
            value_ = new $typecode.contentTypeCode.cppTypename$[maximum_];
        }

        $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
        for (uint32_t count = 0; count < length_; ++count)
        {
            value_[count] = nullptr;
        }
        $else$$endif$$else$$endif$
    }

    return value_[index];
}

const $typecode.contentTypeCode.cppTypename$$if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$$else$&$endif$$else$&$endif$ $scopedtypename$::operator[](
        uint32_t index) const
{
    if (value_ == nullptr)
    {
        if (maximum_ == 0)
        {
            if (length_ != 0) // Must be set. If not, will return nullptr[index] and crash.
            {
                value_ = new $typecode.contentTypeCode.cppTypename$[length_];
            }
        }
        else
        {
            value_ = new $typecode.contentTypeCode.cppTypename$[maximum_];
        }

        $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
        for (uint32_t count = 0; count < length_; ++count)
        {
            value_[count] = nullptr;
        }
        $else$$endif$$else$$endif$
    }

    return value_[index];
}

void $scopedtypename$::size(
        uint32_t size)
{
    if (maximum_ == 0)
    {
        if(value_ != nullptr && size > length_)
        {
            $typecode.contentTypeCode.cppTypename$* temp = new $typecode.contentTypeCode.cppTypename$[size];
            for (uint32_t i = 0; i < length_; ++i)
            {
                $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
                if (value_[i] != nullptr)
                {
                    strncpy(temp[i], value_[i], strlen(value_[i]) + 1);
                }
                else
                {
                    temp[i] = nullptr;
                }
                $else$
                temp[i] = value_[i];$endif$$else$
                temp[i] = value_[i];$endif$
            }
            free_memory();
            value_ = temp;
            release_ = true;
        }
    }
    else
    {
        if(size > maximum_)
        {
            throw BadParamException("Length is greater than maximum length of the sequence");
        }
    }

    length_ = size;
}

uint32_t $scopedtypename$::size() const
{
    return length_;
}

void $scopedtypename$::length(
        uint32_t length)
{
    if (maximum_ == 0)
    {
        if(value_ != nullptr && length > length_)
        {
            $typecode.contentTypeCode.cppTypename$* temp = new $typecode.contentTypeCode.cppTypename$[length];
            for (uint32_t i = 0; i < length_; ++i)
            {
                $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
                if (value_[i] != nullptr)
                {
                    strncpy(temp[i], value_[i], strlen(value_[i]) + 1);
                }
                else
                {
                    temp[i] = nullptr;
                }
                $else$
                temp[i] = value_[i];$endif$$else$
                temp[i] = value_[i];$endif$
            }
            free_memory();
            value_ = temp;
            release_ = true;
        }
    }
    else
    {
        if(length > maximum_)
        {
            throw BadParamException("Length is greater than maximum length of the sequence");
        }
    }

    length_ = length;
}

uint32_t $scopedtypename$::length() const
{
    return length_;
}

uint32_t $scopedtypename$::maximum() const
{
    if (maximum_ == 0)
    {
        return length_;
    }
    else
    {
        return maximum_;
    }
}

void $scopedtypename$::value(
        $typecode.contentTypeCode.cppTypename$* value)
{
    free_memory();
    value_ = value;
}

$typecode.contentTypeCode.cppTypename$* $scopedtypename$::value(
        bool orphan)
{
    if (orphan && !release_)
    {
        return nullptr;
    }

    if (value_ == nullptr)
    {
        if (maximum_ == 0)
        {
            if (length_ == 0) // Not yet set
            {
                return nullptr; // To be coherent with accessing value[length];
            }
            value_ = new $typecode.contentTypeCode.cppTypename$[length_];
        }
        else
        {
            value_ = new $typecode.contentTypeCode.cppTypename$[maximum_];
        }

        $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
        for (uint32_t count = 0; count < length_; ++count)
        {
            value_[count] = nullptr;
        }
        $else$$endif$$else$$endif$
    }

    if (orphan)
    {
        release_ = false;
    }

    return value_;
}

const $typecode.contentTypeCode.cppTypename$$if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$ const$else$$endif$$else$$endif$* $scopedtypename$::value() const
{
    if (value_ == nullptr)
    {
        if (maximum_ == 0)
        {
            if (length_ == 0) // Not yet set
            {
                return nullptr; // To be coherent with accessing value[length];
            }
            value_ = new $typecode.contentTypeCode.cppTypename$[length_];
        }
        else
        {
            value_ = new $typecode.contentTypeCode.cppTypename$[maximum_];
        }

        $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
        for (uint32_t count = 0; count < length_; ++count)
        {
            value_[count] = nullptr;
        }
        $else$$endif$$else$$endif$
    }

    return value_;
}

void $scopedtypename$::release(
        bool release)
{
    release_ = release;
}

bool $scopedtypename$::release() const
{
    return release_;
}

bool& $scopedtypename$::release()
{
    return release_;
}

$if(ctx.anyCdr)$
size_t $scopedtypename$::getCdrSerializedSize(
        const $scopedtypename$& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment(current_alignment, 4)$endif$;

    $sequence_serialized_size(ctx=ctx, typecodeSeq=typecode, data="data", var="current_alignment", loopvar=ctx.newLoopVarName)$

    return current_alignment - initial_alignment;
}

$endif$

$if(ctx.cdr)$
void $scopedtypename$::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr <<  length_;

    if (value_ == nullptr && length_ > 0)
    {
        uint32_t size = (maximum_ == 0) ? length_ : maximum_;
        value_ = new $typecode.contentTypeCode.cppTypename$[size];

        $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
        for (uint32_t count = 0; count < length_; ++count)
        {
            value_[count] = nullptr;
        }
        $else$$endif$$else$$endif$
    }

    for (uint32_t count = 0; count < length_; ++count)
    {
        scdr << value_[count];
    }
}

void $scopedtypename$::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    uint32_t old_length = length_;
    uint32_t new_length;

    dcdr \>>  new_length;

    if (maximum_ != 0 && new_length > maximum_)
    {
        throw BadParamException("Deserialized length is greater than maximum length of the sequence. Incompatible \
            sequences.");
    }

    if ((value_ == nullptr && new_length > 0) || (old_length < new_length))
    {
        free_memory();

        uint32_t size = (maximum_ == 0) ? new_length : maximum_;
        value_ = new $typecode.contentTypeCode.cppTypename$[size];
    }

    length_ = new_length;

    for (uint32_t count = 0; count < length_; ++count)
    {
        $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
        {
            std::string temp;
            dcdr \>> temp;
            value_[count] = (char*)malloc(temp.size() + 1);
            strncpy(value_[count], temp.c_str(), temp.size() + 1);
        }
        $else$
        dcdr \>> value_[count];$endif$$else$
        dcdr \>> value_[count];$endif$
    }
}

void $scopedtypename$::free_memory()
{
    if (release_)
    {
        $if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$
        for (uint32_t count = 0; count < length_; ++count)
        {
            free(value_[count]);
            value_[count] = nullptr;
        }
        $else$$endif$$else$$endif$
        delete[](value_);
    }
    value_ = nullptr;
}

$endif$
>>

object_serialization(ctx, object, preffix) ::= <<
$if(object.typecode.isType_f)$
$object_array_serialization(ctx=ctx, object=object, preffix=preffix)$
$elseif(object.typecode.isType_e)$
$object_seq_serialization(ctx=ctx, object=object, preffix=preffix)$
$elseif(object.typecode.isMapType)$
$object_map_serialization(ctx=ctx, object=object, preffix=preffix)$
$else$
scdr << $serializeCasting(typecode=object.typecode)$$preffix$$object.name$$if(object.typecode.isStringType)$.c_str()$endif$;
$endif$
>>

object_array_serialization(ctx, object, preffix) ::= <<
$if(object.typecode.contentTypeCode.isStringType)$
$string_collection_serialization(ctx=ctx, object=object, preffix=preffix)$
$elseif(rest(object.typecode.dimensions))$
$recursive_array_array_serialization(ctx=ctx, name=cdrMemberName(name=object.name, preffix=preffix),  loopvar=ctx.nextLoopVarName, dims=object.typecode.dimensions, object=object)$
$elseif(object.typecode.contentTypeCode.isType_c)$
scdr.serializeArray(reinterpret_cast<const uint32_t*>($preffix$$object.name$.data()), $preffix$$object.name$.size());
$else$
scdr << $serializeCasting(typecode=object.typecode)$$preffix$$object.name$;
$endif$
>>

object_seq_serialization(ctx, object, preffix) ::= <<
$if(object.typecode.contentTypeCode.isType_c)$
scdr << static_cast<uint32_t>($preffix$$object.name$.size());
scdr.serializeArray(reinterpret_cast<const uint32_t*>($preffix$$object.name$.data()), $preffix$$object.name$.size());
$elseif(object.typecode.contentTypeCode.isStringType)$
$string_collection_serialization(ctx=ctx, object=object, preffix=preffix)$
$else$
scdr << $serializeCasting(typecode=object.typecode)$$preffix$$object.name$;
$endif$
>>

object_map_serialization(ctx, object, preffix) ::= <<
scdr << static_cast<uint32_t>($preffix$$object.name$.size());
for (const auto& pair : $preffix$$object.name$)
{
$if(object.typecode.keyTypeCode.isType_c)$
    scdr << static_cast<uint32_t>(pair.first);
$elseif(object.typecode.keyTypeCode.isType_d ||
        object.typecode.keyTypeCode.isStringType ||
        object.typecode.keyTypeCode.isWStringType)$
    scdr << pair.first$if(object.typecode.keyTypeCode.isStringType)$.c_str()$endif$;
$else$
    scdr << pair.first;
$endif$
$if(object.typecode.valueTypeCode.isType_c)$
    scdr << static_cast<uint32_t>(pair.second);
$elseif(object.typecode.valueTypeCode.isType_d ||
        object.typecode.valueTypeCode.isStringType ||
        object.typecode.valueTypeCode.isWStringType)$
    scdr << pair.second$if(object.typecode.valueTypeCode.isStringType)$.c_str()$endif$;
$else$
    scdr << pair.second;
$endif$
}
>>

string_collection_serialization(ctx, object, preffix) ::= <<
$if(object.typecode.isType_f)$
$recursive_string_array_serialization(ctx=ctx, name=cdrMemberName(name=object.name, preffix=preffix),  loopvar=ctx.nextLoopVarName, dims=object.typecode.dimensions, object=object)$
$elseif(ctx.generateTypesC)$
$if(object.typecode.isType_e)$
{
    scdr << $preffix$$object.name$;
}
$else$
{
    std::vector<std::string> temp_$object.name$;
    for (char* str : $preffix$$object.name$)
    {
        temp_$object.name$.push_back(std::string(str != nullptr ? str : ""));
    }
    scdr << temp_$object.name$;
}
$endif$

$elseif(object.typecode.contentTypeCode.isStringType)$
$if(object.typecode.contentTypeCode.isBounded)$
{
$if(object.typecode.isType_e)$
    scdr << static_cast<uint32_t>($preffix$$object.name$.size());
$endif$

    for (const auto& item : $preffix$$object.name$)
    {
        scdr << item.c_str();
    }
}

$else$
scdr << $serializeCasting(typecode=object.typecode)$$preffix$$object.name$;

$endif$
$else$
scdr << $serializeCasting(typecode=object.typecode)$$preffix$$object.name$;

$endif$
>>

recursive_string_array_serialization(ctx, name, loopvar, dims, object) ::= <<
$if(rest(dims))$
for (uint32_t $loopvar$ = 0; $loopvar$ < $name$.size(); ++$loopvar$)
{
    $recursive_string_array_serialization(ctx=ctx, name=cdrIndexName(name=name,loopvar=loopvar),  loopvar=ctx.nextLoopVarName, dims=rest(dims), object=object)$
}
$elseif(ctx.generateTypesC)$
for (char* str : $name$)
{
    scdr << std::string(str != nullptr ? str : "");
}
$else$
for (const auto& str : $name$)
{
    scdr << str$if(object.typecode.contentTypeCode.isStringType)$.c_str()$endif$;
}

$endif$
>>

recursive_array_array_serialization(ctx, name, loopvar, dims, object) ::= <<
$if(rest(dims))$
for (uint32_t $loopvar$ = 0; $loopvar$ < $name$.size(); ++$loopvar$)
{
    $recursive_array_array_serialization(ctx=ctx, name=cdrIndexName(name=name,loopvar=loopvar),  loopvar=ctx.nextLoopVarName, dims=rest(dims), object=object)$
}
$elseif(object.typecode.contentTypeCode.isType_c)$
scdr.serializeArray(reinterpret_cast<const uint32_t*>($name$.data()), $name$.size());
$elseif(object.typecode.contentTypeCode.isBitmaskType)$
scdr.serializeArray(reinterpret_cast<const uint32_t*>($name$.data()), $name$.size());
$elseif(object.typecode.contentTypeCode.isStringType)$
$string_collection_serialization(ctx=ctx, object=object, preffix=preffix)$
$else$
scdr << $name$;
$endif$
>>

recursive_array_array_deserialization(ctx, name, loopvar, dims, object) ::= <<
$if(rest(dims))$
for (uint32_t $loopvar$ = 0; $loopvar$ < $name$.size(); ++$loopvar$)
{
    $recursive_array_array_deserialization(ctx=ctx, name=cdrIndexName(name=name,loopvar=loopvar),  loopvar=ctx.nextLoopVarName, dims=rest(dims), object=object)$
}
$elseif(object.typecode.contentTypeCode.isType_c)$
dcdr.deserializeArray(reinterpret_cast<uint32_t*>($name$.data()), $name$.size());
$elseif(object.typecode.contentTypeCode.isBitmaskType)$
dcdr.deserializeArray(reinterpret_cast<uint32_t*>($name$.data()), $name$.size());
$elseif(object.typecode.contentTypeCode.isStringType)$
$string_collection_deserialization(ctx=ctx, object=object, preffix=preffix)$
$else$
dcdr \>> $name$;
$endif$
>>

object_deserialization(ctx, object, preffix) ::= <<
$if(object.typecode.isType_f)$
$object_array_deserialization(ctx=ctx, object=object, preffix=preffix)$
$elseif(object.typecode.isMapType)$
$object_map_deserialization(ctx=ctx, object=object, preffix=preffix)$
$elseif(object.typecode.isType_e)$
$object_map_seq_deserialization(ctx=ctx, object=object, preffix=preffix)$
$else$
$deserializePossibleEnum(typecode=object.typecode, name=object.name, preffix=preffix)$
$endif$
>>

object_array_deserialization(ctx, object, preffix) ::= <<
$if(object.typecode.contentTypeCode.isStringType)$
$string_collection_deserialization(ctx=ctx, object=object, preffix=preffix)$
$elseif(rest(object.typecode.dimensions))$
$recursive_array_array_deserialization(ctx=ctx, name=cdrMemberName(name=object.name, preffix=preffix),  loopvar=ctx.nextLoopVarName, dims=object.typecode.dimensions, object=object)$
$elseif(object.typecode.contentTypeCode.isType_c)$
dcdr.deserializeArray(reinterpret_cast<uint32_t*>($preffix$$object.name$.data()), $preffix$$object.name$.size());
$else$
dcdr \>> $preffix$$object.name$;
$endif$
>>

object_map_seq_deserialization(ctx, object, preffix) ::= <<
$if(object.typecode.contentTypeCode.isType_c)$
{
    uint32_t seq_length = 0;
    dcdr \>> seq_length;
    $preffix$$object.name$.resize(seq_length);
    dcdr.deserializeArray(reinterpret_cast<uint32_t*>($preffix$$object.name$.data()), seq_length);
}
$elseif(object.typecode.contentTypeCode.isStringType)$
$string_collection_deserialization(ctx=ctx, object=object, preffix=preffix)$
$else$
dcdr \>> $preffix$$object.name$;
$endif$
>>

object_map_deserialization(ctx, object, preffix) ::= <<

$if(object.typecode.valueTypeCode.isType_c ||
    object.typecode.valueTypeCode.isBitmaskType ||
    object.typecode.valueTypeCode.isStringType ||
    object.typecode.valueTypeCode.isWStringType ||
    object.typecode.keyTypeCode.isStringType ||
    object.typecode.keyTypeCode.isWStringType)$
uint32_t seq_length = 0;
dcdr \>> seq_length;
$preffix$$object.name$.clear();
for (uint32_t i = 0; i < seq_length; ++i)
{
$object_map_key_deserialization(ctx=ctx, keyTypeCode=object.typecode.keyTypeCode)$

$object_map_value_deserialization(ctx=ctx, name=[preffix, object.name], keyTypeCode=object.typecode.keyTypeCode,
        valueTypeCode=object.typecode.valueTypeCode)$
}
$else$
    dcdr \>> $preffix$$object.name$;
$endif$
>>


object_map_key_deserialization(ctx, keyTypeCode) ::= <<
$if(keyTypeCode.isStringType)$
    std::string key;
    $if(keyTypeCode.isBounded)$
        std::string aux;
        dcdr \>> aux;
        key = aux.c_str();
    $else$
        dcdr \>> key;
    $endif$
$elseif(keyTypeCode.isWStringType)$
    std::wstring key;
    $if(keyTypeCode.isBounded)$
        std::wstring aux;
        dcdr \>> aux;
        key = aux.c_str();
    $else$
        dcdr \>> key;
    $endif$
$else$
    $keyTypeCode.cppTypename$ key;
    dcdr \>> key;
$endif$
>>

object_map_value_deserialization(ctx, name, keyTypeCode, valueTypeCode) ::= <<
$if(valueTypeCode.isStringType)$
    std::string value;
    dcdr \>> value;
    $name$[key$if(keyTypeCode.isStringType)$.c_str()$endif$] = value$if(valueTypeCode.isStringType)$.c_str()$endif$;
$elseif(valueTypeCode.isWStringType)$
    std::wstring value;
    dcdr \>> value;
    $name$[key$if(keyTypeCode.isStringType)$.c_str()$endif$] = value$if(valueTypeCode.isStringType)$.c_str()$endif$;
$elseif(valueTypeCode.isType_c)$
    uint32_t value;
    dcdr \>> value;
    $name$[key$if(keyTypeCode.isStringType)$.c_str()$endif$] = static_cast<$valueTypeCode.cppTypename$>(value);
$elseif(valueTypeCode.isBitmaskType)$
    uint32_t value;
    dcdr \>> value;
    $name$[key$if(keyTypeCode.isStringType)$.c_str()$endif$] = static_cast<$valueTypeCode.cppTypename$>(value);
$else$
    $valueTypeCode.cppTypename$ value;
    dcdr \>> value;
    $name$[key$if(keyTypeCode.isStringType)$.c_str()$endif$] = value$if(valueTypeCode.isStringType)$.c_str()$endif$;
$endif$
>>

string_collection_deserialization(ctx, object, preffix) ::= <<
$if(object.typecode.isType_f)$
$recursive_string_array_deserialization(ctx=ctx, name=cdrMemberName(name=object.name, preffix=preffix),  loopvar=ctx.nextLoopVarName, dims=object.typecode.dimensions, object=object)$
$elseif(ctx.generateTypesC)$
$if(object.typecode.isType_e)$
{
    dcdr \>> $preffix$$object.name$;
}
$else$
{
    // Free old memory allocation
    for (char* str : $preffix$$object.name$)
    {
        free(str);
    }
    $preffix$$object.name$.clear();
    std::vector<std::string> temp_$object.name$;
    dcdr \>> temp_$object.name$;
    for (std::string str : temp_$object.name$)
    {
        char* aux = (char*)malloc(str.size() + 1);
        strncpy(aux, str.c_str(), str.size() + 1);
        $preffix$$object.name$.push_back(aux);
    }
}
$endif$
$elseif(object.typecode.contentTypeCode.isStringType)$
$if(object.typecode.contentTypeCode.isBounded)$
{
$if(object.typecode.isType_e)$
    uint32_t sequence_size = 0;
    dcdr \>> sequence_size;
    $preffix$$object.name$.resize(sequence_size);
$endif$

    for (auto& item : $preffix$$object.name$)
    {
        std::string s;
        dcdr \>> s;
        item = s.c_str();
    }
}

$else$
dcdr \>> $preffix$$object.name$;
$endif$
$else$
dcdr \>> $preffix$$object.name$;
$endif$
>>

recursive_string_array_deserialization(ctx, name, loopvar, dims, object) ::= <<
$if(rest(dims))$
for (uint32_t $loopvar$ = 0; $loopvar$ < $name$.size(); ++$loopvar$)
{
    $recursive_string_array_deserialization(ctx=ctx, name=cdrIndexName(name=name,loopvar=loopvar),  loopvar=ctx.nextLoopVarName, dims=rest(dims), object=object)$
}
$elseif(ctx.generateTypesC)$
// Free old memory allocation
for (char* str : $name$)
{
    free(str);
}
$name$.fill(nullptr);
for (uint32_t index = 0; index < $name$.size(); ++index)
{
    std::string str;
    dcdr \>> str;
    char* aux = new char[str.size() + 1];
    strncpy(aux, str.c_str(), str.size() + 1);
    $name$[index] = aux;
}
$else$
for (auto& str : $name$)
{
$if(object.typecode.contentTypeCode.isStringType)$
$if(object.typecode.contentTypeCode.isBounded)$
    {
        std::string aux_str;
        dcdr \>> aux_str;
        str = aux_str.c_str();
    }

$else$
    dcdr \>> str;
$endif$
$else$
    dcdr \>> str;
$endif$
}

$endif$
>>

bitfield_deserialization(ctx, object) ::= <<$if(member.name)$$member.spec.cppTypename$ aux_$member.name$;
dcdr \>> aux_$member.name$;
$member.name$(aux_$member.name$);$endif$
>>

serialized_size_type(ctx, typecode, var) ::= <<
$if(typecode.isType_13)$
$var$ += 16$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 8)$endif$; // 128 bits, but aligned as 64
$elseif(typecode.primitive)$
$var$ += $typecode.size$$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, $typecode.size$)$endif$;

$endif$
>>

serialized_size(ctx, object, data, var) ::= <<
$if(object.typecode.isType_13)$
$var$ += 16$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 8)$endif$; // 128 bits, but aligned as 64
$elseif(object.typecode.primitive || object.typecode.isBitmaskType)$
$var$ += $object.typecode.size$$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, $object.typecode.size$)$endif$;
$elseif(object.typecode.isWStringType)$
$var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$ + ($data$.$object.name$().size()) * 4; // 32 bits
$elseif(object.typecode.isType_d)$
$var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$ + $if(ctx.generateTypesC)$strlen($data$.$object.name$())$else$$data$.$object.name$().size()$endif$ + 1;
$elseif(object.typecode.isMapType)$
$var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$;

$map_serialized_size(ctx=ctx, typecodeMap=object.typecode, data=[data, ".", object.name, "()"], var=var, loopvar=ctx.newLoopVarName)$
$elseif(object.typecode.isType_e)$
$var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$;

$sequence_serialized_size(ctx=ctx, typecodeSeq=object.typecode, data=[data, ".", object.name, "()"], var=var, loopvar=ctx.newLoopVarName)$
$elseif(object.typecode.isType_f)$
$array_serialized_size(ctx=ctx, typecodeArr=object.typecode, data=[data, ".", object.name, "()"], var=var, loopvar=ctx.newLoopVarName, dimensions=object.typecode.dimensions)$
$elseif(object.typecode.isBitmaskType)$
$var$ += $object.typecode.size$$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, $object.typecode.size$)$endif$;
$else$
$var$ += $object.typecode.scopedname$::getCdrSerializedSize($data$.$object.name$(), $var$);
$endif$

>>

sequence_serialized_size(ctx, typecodeSeq, data, var, loopvar) ::= <<
$if(typecodeSeq.contentTypeCode.primitive || typecodeSeq.contentTypeCode.isBitmaskType)$
if ($data$.size() > 0)
{
    $if(typecodeSeq.contentTypeCode.isType_13)$
    $var$ += ($data$.size() * $typecodeSeq.contentTypeCode.size$)$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 8)$endif$; // 128 bits, but aligned as 64
    $else$
    $var$ += ($data$.size() * $typecodeSeq.contentTypeCode.size$)$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, $typecodeSeq.contentTypeCode.size$)$endif$;
    $endif$
}

$elseif(typecodeSeq.contentTypeCode.isType_d)$

for(size_t $loopvar$ = 0; $loopvar$ < $data$.size(); ++$loopvar$)
{
    $if(typecodeSeq.contentTypeCode.isWStringType)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$ + ($data$.at($loopvar$).size() * 4);
    $else$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$ +
        $if(ctx.generateTypesC)$strlen($data$.value()[$loopvar$])$else$$data$.at($loopvar$).size()$endif$ + 1;
    $endif$
}
$else$

for(size_t $loopvar$ = 0; $loopvar$ < $data$.size(); ++$loopvar$)
{
$if(typecodeSeq.contentTypeCode.isType_e)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$;

    $if(ctx.generateTypesC)$
    $sequence_serialized_size(ctx=ctx, typecodeSeq=typecodeSeq.contentTypeCode, data=[data, ".value()[", loopvar, "]"], var=var, loopvar=ctx.nextLoopVarName)$
    $else$
    $sequence_serialized_size(ctx=ctx, typecodeSeq=typecodeSeq.contentTypeCode, data=[data, ".at(", loopvar, ")"], var=var, loopvar=ctx.nextLoopVarName)$
    $endif$
$elseif(typecodeSeq.contentTypeCode.isMapType)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$;

    $if(ctx.generateTypesC)$
    $map_serialized_size(ctx=ctx, typecodeMap=typecodeSeq.contentTypeCode, data=[data, ".value()[", loopvar, "]"], var=var, loopvar=ctx.nextLoopVarName)$
    $else$
    $map_serialized_size(ctx=ctx, typecodeMap=typecodeSeq.contentTypeCode, data=[data, ".at(", loopvar, ")"], var=var, loopvar=ctx.nextLoopVarName)$
    $endif$
$elseif(typecodeSeq.contentTypeCode.isType_f)$
    $if(ctx.generateTypesC)$
    $array_serialized_size(ctx=ctx, typecodeArr=typecodeSeq.contentTypeCode, data=[data, ".value()[", loopvar, "]"], var=var, loopvar=ctx.nextLoopVarName, dimensions=typecodeSeq.contentTypeCode.dimensions)$
    $else$
    $array_serialized_size(ctx=ctx, typecodeArr=typecodeSeq.contentTypeCode, data=[data, ".at(", loopvar, ")"], var=var, loopvar=ctx.nextLoopVarName, dimensions=typecodeSeq.contentTypeCode.dimensions)$
    $endif$
$else$
    $var$ += $typecodeSeq.contentTypeCode.scopedname$::getCdrSerializedSize($if(ctx.generateTypesC)$$data$.value()[$loopvar$]$else$$data$.at($loopvar$)$endif$, $var$);
$endif$
}
$endif$
>>

array_serialized_size(ctx, typecodeArr, data, var, loopvar, dimensions) ::= <<
$if(typecodeArr.contentTypeCode.primitive || typecodeArr.contentTypeCode.isBitmaskType)$
$if(typecodeArr.notZeroArray)$
$var$ += ($typecodeArr.size$ * $typecodeArr.contentTypeCode.size$)$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, $typecodeArr.contentTypeCode.size$)$endif$;
$endif$
$else$
$if(first(dimensions))$

for(size_t $loopvar$ = 0; $loopvar$ < $data$.size(); ++$loopvar$)
{
    $array_serialized_size(ctx=ctx, typecodeArr=typecodeArr, data=[data, ".at(", loopvar, ")"], var=var, loopvar=ctx.nextLoopVarName, dimensions=rest(dimensions))$
}
$else$
$if(typecodeArr.contentTypeCode.isType_d)$
    $if(typecodeArr.contentTypeCode.isWStringType)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$ + ($data$.size() * 4);
    $else$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$ + $if(ctx.generateTypesC)$strlen($data$)$else$$data$.size()$endif$ + 1;
    $endif$
$elseif(typecodeArr.contentTypeCode.isMapType)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$;

    $map_serialized_size(ctx=ctx, typecodeMap=typecodeArr.contentTypeCode, data=data, var=var, loopvar=loopvar)$
$elseif(typecodeArr.contentTypeCode.isType_e)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$;

    $sequence_serialized_size(ctx=ctx, typecodeSeq=typecodeArr.contentTypeCode, data=data, var=var, loopvar=ctx.nextLoopVarName)$
$elseif(typecodeArr.contentTypeCode.isType_f)$
    $array_serialized_size(ctx=ctx, typecodeArr=typecodeArr.contentTypeCode, data=data, var=var, loopvar=loopvar, dimensions=typecodeArr.contentTypeCode.dimensions)$
$else$
    $var$ += $typecodeArr.contentTypeCode.scopedname$::getCdrSerializedSize($data$, $var$);
$endif$
$endif$
$endif$
>>

map_serialized_size(ctx, typecodeMap, data, var, loopvar) ::= <<
for(auto $loopvar$ : $data$)
{
    (void)$loopvar$;

    $map_serialized_size_element(ctx=ctx, typecodeMapElement=typecodeMap.keyTypeCode, data=[loopvar, ".first"], var=var, loopvar=loopvar)$
    $map_serialized_size_element(ctx=ctx, typecodeMapElement=typecodeMap.valueTypeCode, data=[loopvar, ".second"], var=var, loopvar=loopvar)$
\}
>>

map_serialized_size_element(ctx, typecodeMapElement, data, var, loopvar) ::= <<
$if(typecodeMapElement.isType_13)$
    $var$ += 16$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 8)$endif$; // 128 bits, but aligned as 64
$elseif(typecodeMapElement.primitive || typecodeMapElement.isBitmaskType)$
    $var$ += $typecodeMapElement.size$$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, $typecodeMapElement.size$)$endif$;
$elseif(typecodeMapElement.isWStringType)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$ + $data$.size() * 4;
$elseif(typecodeMapElement.isType_d)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$ + $if(ctx.generateTypesC)$strlen($loopvar$)$else$$data$.size()$endif$ + 1;
$elseif(typecodeMapElement.isMapType)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$;

    $map_serialized_size(ctx=ctx, typecodeMap=typecodeMapElement, data=data, var=var, loopvar=ctx.nextLoopVarName)$
$elseif(typecodeMapElement.isType_e)$
    $var$ += 4$if(ctx.cdr)$ + eprosima::fastcdr::Cdr::alignment($var$, 4)$endif$;

    $sequence_serialized_size(ctx=ctx, typecodeSeq=typecodeMapElement, data=data, var=var, loopvar=ctx.nextLoopVarName)$
$elseif(typecodeMapElement.isType_f)$
    $array_serialized_size(ctx=ctx, typecodeArr=typecodeMapElement, data=data, var=var, loopvar=ctx.nextLoopVarName, dimensions=typecodeMapElement.dimensions)$
$else$
    $var$ += $typecodeMapElement.scopedname$::getCdrSerializedSize($data$, $var$);
$endif$
>>

serializeCasting(typecode) ::= <<
$if(typecode.isType_c)$(uint32_t)$elseif(typecode.isBitmaskType)$($typecode.castingType$)$endif$
>>

deserializePossibleEnum(typecode, name, preffix) ::= <<
$if(typecode.isType_c)$
{
    uint32_t enum_value = 0;
    dcdr \>> enum_value;
    $preffix$$name$ = ($typecode.scopedname$)enum_value;
}
$elseif(typecode.isBitmaskType)$
{
    $typecode.castingType$ bitmask_value = 0;
    dcdr \>> bitmask_value;
    $preffix$$name$ = ($typecode.scopedname$)bitmask_value;
}

$elseif(ctx.generateTypesC)$
$if(typecode.isStringType)$
{
    std::string aux;
    dcdr \>> aux;
    free($preffix$$name$);
    $preffix$$name$ = (char*)malloc(aux.size() + 1);
    strncpy($preffix$$name$, aux.c_str(), aux.size() + 1);
}
$else$
dcdr \>> $preffix$$name$;
$endif$
$elseif(typecode.isStringType)$
$if(typecode.isBounded)$
{
    std::string aux;
    dcdr \>> aux;
    $preffix$$name$ = aux.c_str();
}
$else$
dcdr \>> $preffix$$name$;
$endif$
$else$
dcdr \>> $preffix$$name$;
$endif$
>>

cdrIndexName(name, loopvar) ::= <<$name$[$loopvar$]>>

cdrMemberName(name, preffix) ::= <<$preffix$$name$>>

member_default_init(ctx, member, loopvar) ::= <<
// $member.typecode.idlTypename$ m_$member.name$
$if(member.typecode.primitive)$$if(member.typecode.isBitmaskType)$m_$member.name$ = $if(member.annotationDefault)$$member.annotationDefaultValue$$else$static_cast<$member.typecode.cppTypename$>(0)$endif$;$else$m_$member.name$ = $if(member.annotationDefault)$$member.annotationDefaultValue$$else$$member.typecode.initialValue$$endif$;$endif$$elseif(member.typecode.isType_f)$$if(member.typecode.contentTypeCode.primitive)$memset(&m_$member.name$, $if(member.annotationDefault)$$member.annotationDefaultValue$$else$0$endif$, $member.typecode.size$ * $member.typecode.contentTypeCode.size$);$elseif(member.typecode.contentTypeCode.isStringType)$$if(ctx.generateTypesC)$$member_array_default_cstring_init(ctx=ctx, name=memberName(member.name), loopvar=ctx.newLoopVarName, dims=member.typecode.dimensions)$$endif$$endif$$endif$>>

member_array_default_cstring_init(ctx, name, loopvar, dims) ::= <<$if(rest(dims))$for (uint32_t $loopvar$ = 0; $loopvar$ < $name$.size(); ++$loopvar$)
{
    $member_array_default_cstring_init(ctx=ctx, name=indexName(name=name,loopvar=loopvar),  loopvar=ctx.nextLoopVarName, dims=rest(dims))$
}$else$$name$.fill(nullptr);$endif$>>

indexName(name, loopvar) ::= <<$name$[$loopvar$]>>

memberName(name) ::= <<m_$name$>>
