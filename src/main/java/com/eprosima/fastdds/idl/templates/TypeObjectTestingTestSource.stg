// Copyright 2023 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

import "eprosima.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "TypeObjectTestingTest.cpp"], description=["This file contains TypeObject test code."])$

#include <fastdds/dds/domain/DomainParticipantFactory.hpp>
#include <fastdds/dds/xtypes/type_representation/TypeObject.h>
#include <fastdds/dds/xtypes/type_representation/TypeObjectRegistry.hpp>
#include <fastrtps/types/TypesBase.h>
#include <fastrtps/utils/md5.h>
#include <gtest/gtest.h>

#include "$ctx.filename$TypeObject.h"

using ReturnCode_t = eprosima::fastrtps::rtps::types::ReturnCode_t;
using namespace eprosima::fastdds::dds::xtypes1_3;

$definitions;separator="\n"$

int main(
        int argc,
        char** argv)
{

    register$ctx.filename$Types();

    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
>>

get_type_identifier(typename) ::= <<
    TypeIdentifierPair type_ids;
    ret_code =
        eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
        "$typename$", type_ids);
>>

get_type_object(typename) ::= <<
    TypeObjectPair type_objects;
    ret_code =
        eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_objects(
        "$typename$", type_objects);
>>

check_optional_detail_annotations(ctx, object) ::= <<
    $if(object.annotationList)$
    $object.annotationList: { annotation |
    $if(annotation.isVerbatim)$
    AppliedBuiltinTypeAnnotations $object.name$_$relation_name$_applied_bta = $object.name$_$relation_name$_detail.ann_builtin();
    AppliedVerbatimAnnotation $object.name$_$relation_name$_vermatim_annotation = $object.name$_$relation_name$_applied_bta.verbatim();
    $annotation.valueList : { vermatim_param |
    $if(vermatim_param.isVerbatimPlacement)$
    $object.name$_$relation_name$_vermatim_annotation.placement() = $vermatim_param.enumStringValue$;
    $elseif(vermatim_param.isVerbatimLanguage)$
    $object.name$_$relation_name$_vermatim_annotation.language() = $vermatim_param.value$;
    $elseif(vermatim_param.isVerbatimText)$
    $object.name$_$relation_name$_vermatim_annotation.text() = $vermatim_param.value$;
    $endif$
    };separator="\n"$
    $else$
    AppliedAnnotationSeq $object.name$_$relation_name$_annotation_seq = $object.name$_$relation_name$_detail.ann_custom();
    for(int i = 0;i < $object.name$_$relation_name$_annotation_seq.size();i++)
    {
        AppliedAnnotation $object.name$_$relation_name$_applied_annotation = $object.name$_$relation_name$_annotation_seq.at(i);
        $get_type_identifier(typename=object.scopedname)$
        ASSERT_EQ($object.name$_$relation_name$_annotation_type_id->_d(), $object.name$_$relation_name$_applied_annotation.annotation_typeid()._d());

        AppliedAnnotationParameterSeq $object.name$_$relation_name$_annotation_param_seq = $object.name$_$relation_name$_applied_annotation.param_seq();
        for(int i = 0;i < $object.name$_$relation_name$_annotation_param_seq.size();i++)
        {
            AppliedAnnotationParameter $object.name$_$relation_name$_annotation_param = $object.name$_$relation_name$_annotation_param_seq.at(i);
            NameHash $object.name$_$relation_name$_annotation_paramname_hash = $object.name$_$relation_name$_annotation_param.paramname_hash();
            MD5 $object.name$_$relation_name$_paramname_hash("$object.name$");
            for(int i = 0;i < 4;++i)
            {
                ASSERT_EQ($object.name$_$relation_name$_paramname_hash.digest[i], $object.name$_$relation_name$_annotation_paramname_hash[i]);
            \}

            AnnotationParameterValue $object.name$_$relation_name$_value = $object.name$_$relation_name$_annotation_param.value();
            $if(object.typecode.primitiveType)$
            $if(object.typecode.isBooleanType)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.boolean_value());
            $elseif(object.typecode.isByteType)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.byte_value());
            $elseif(object.typecode.isInt8Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.int8_value());
            $elseif(object.typecode.isUint8Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.uint8_value());
            $elseif(object.typecode.isInt16Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.int16_value());
            $elseif(object.typecode.isUint16Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.uint16_value());
            $elseif(object.typecode.isInt32Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.int32_value());
            $elseif(object.typecode.isUint32Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.uint32_value());
            $elseif(object.typecode.isInt64Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.int64_value());
            $elseif(object.typecode.isUint64Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.uint64_value());
            $elseif(object.typecode.isFloat32Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.float32_value());
            $elseif(object.typecode.isFloat64Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.float64_value());
            $elseif(object.typecode.isFloat128Type)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.float128_value());
            $elseif(object.typecode.isCharType)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.char_value());
            $elseif(object.typecode.isWCharType)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.wchar_value());
            $endif$
            $elseif(object.typecode.isEnumType)$
            ASSERT_EQ($object.value$, $object.name$_$relation_name$_value.enumerated_value());
            $elseif(object.typecode.isStringType)$
            ASSERT_EQ("$object.value$, $object.name$_$relation_name$_value.string8_value());
            $elseif(object.typecode.isWStringType)$
            ASSERT_EQ("$object.value$", $object.name$_$relation_name$_value.string16_value());
            $endif$
        \}
    \}
    $endif$
    };separator=""$
    $endif$
>>

check_member_flags(ctx, object, flags_var_name) ::= <<
    //=====check_member_flags - $flags_var_name$=====
    MemberFlag $flags_var_name$_expected_flags;
    $if(object.annotationTryConstruct)$
    $if(object.annotationDiscard)$
    $flags_var_name$_expected_flags |= MemberFlagBits::TRY_CONSTRUCT1
    $elseif(object.annotationUseDefault)$
    $flags_var_name$_expected_flags |= MemberFlagBits::TRY_CONSTRUCT2;
    $elseif(object.annotationTrim)$
    $flags_var_name$_expected_flags |= MemberFlagBits::TRY_CONSTRUCT1 | MemberFlagBits::TRY_CONSTRUCT2;
    $endif$
    $else$
    $flags_var_name$_expected_flags |= MemberFlagBits::TRY_CONSTRUCT1;
    $endif$

    $if(object.annotationExternal)$
    $flags_var_name$_expected_flags |= MemberFlagBits::IS_EXTERNAL;
    $endif$

    $if(object.annotationOptional)$
    $flags_var_name$_expected_flags |= MemberFlagBits::IS_OPTIONAL;
    $endif$
    $if(object.annotationMustUnderstand)$
    $flags_var_name$_expected_flags |= MemberFlagBits::IS_MUST_UNDERSTAND;
    $endif$
    $if(object.annotationKey)$
    $flags_var_name$_expected_flags |= MemberFlagBits::IS_KEY;
    $endif$
    $if(object.annotationDefaultLiteral)$
    $flags_var_name$_expected_flags |= MemberFlagBits::IS_DEFAULT;
    $endif$
>>

check_type_flags(ctx, object, flags_var_name) ::= <<
    //=====check_type_flags - $flags_var_name$=====
    TypeFlag $flags_var_name$_expected_flags;
    $if(object.annotationFinal)$
    $flags_var_name$_expected_flags |= TypeFlagBits::IS_FINAL;
    $elseif(object.annotationAppendable)$
    $flags_var_name$_expected_flags |= TypeFlagBits::IS_APPENDABLE;
    $elseif(object.annotationMutable)$
    $flags_var_name$_expected_flags |= TypeFlagBits::IS_MUTABLE;
    $endif$
    $if(object.annotationNested)$
    $flags_var_name$_expected_flags |= TypeFlagBits::IS_NESTED;
    $endif$
    $if(object.annotationAutoidHash)$
    $flags_var_name$_expected_flags |= TypeFlagBits::IS_AUTOID_HASH;
    $endif$
>>


check_alias_type(typedefs) ::= <<
    //=====check_alias_type - $relation_name$ - $typedefs.name$=====
    $get_type_identifier(typename=typedefs.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $typedefs.name$_$relation_name$_type_identifier->_d());

    $get_type_object(type=typedefs.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $typedefs.name$_$relation_name$_typeobject->_d());

    $relation_capname$TypeObject $typedefs.name$_$relation_name$_object = $typedefs.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_ALIAS, $typedefs.name$_$relation_name$_object._d());

    $relation_capname$AliasType $typedefs.name$_$relation_name$_typedefs = $typedefs.name$_$relation_name$_object.alias_type();
    //AliasTypeFlag alias_flags;// Unused. No flags apply
    
    $relation_capname$AliasHeader $typedefs.name$_$relation_name$_header = $typedefs.name$_$relation_name$_typedefs.header();

    $if(relation)$
    CompleteTypeDetail $typedefs.name$_$relation_name$_header_detail = $typedefs.name$_$relation_name$_header.detail();// not present for anonymous
    $check_optional_detail_annotations(ctx=ctx, object=typedefs)$
    QualifiedTypeName $typedefs.name$_$relation_name$_header_detail_type_name = $typedefs.name$_$relation_name$_header_detail.type_name();
    ASSERT_EQ("$typedefs.scopedname$", $typedefs.name$_$relation_name$_header_detail_type_name);

    $endif$

    $relation_capname$AliasBody $typedefs.name$_$relation_name$_body = $typedefs.name$_$relation_name$_typedefs.body();
    CommonAliasBody $typedefs.name$_$relation_name$_common_alias_body = $typedefs.name$_$relation_name$_body.common();
    //AliasMemberFlag related_flags;// Unused. No flags apply

    $get_type_identifier(typename=typedefs.typedefContentTypeCode.scopedname)$
    ASSERT_EQ($typedefs.typedefContentTypeCode.name$_$relation_name$_content_type_identifier->_d(), $typedefs.name$_$relation_name$_common_alias_body.related_type()._d());

    $if(relation)$
    CompleteAliasBody $typedefs.name$_$relation_name$_detail = $typedefs.name$_$relation_name$_typedefs.body();
    $check_optional_detail_annotations(ctx=ctx, object=typedefs)$
    $endif$
>>

check_struct_type(struct) ::= <<
    //=====check_struct_type - $relation_name$ - $struct.name$=====
    $get_type_identifier(typename=struct.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $struct.name$_$relation_name$_type_identifier->_d());
    $get_type_object(typename=struct.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $struct.name$_$relation_name$_typeobject->_d());
    $relation_capname$TypeObject $struct.name$_$relation_name$_object = $struct.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_STRUCTURE, $struct.name$_$relation_name$_object._d());
    $relation_capname$StructType $struct.name$_$relation_name$_struct = $struct.name$_$relation_name$_object.struct_type();
    {
    $check_type_flags(ctx=ctx, object=struct, flags_var_name=["struct"])$
    ASSERT_TRUE(struct_expected_flags == $struct.name$_$relation_name$_struct.struct_flags());
    }
    $relation_capname$StructHeader $struct.name$_$relation_name$_header = $struct.name$_$relation_name$_struct.header();

    $if(struct.inheritance)$
    $get_type_identifier(typename=struct.inheritance.scopedname)$
    ASSERT_EQ($struct.inheritance.name$_$relation_name$_inheritance_type_id->_d(), $struct.name$_$relation_name$_header.base_type()._d());
    $endif$
    $if(relation)$
    CompleteTypeDetail $struct.name$_$relation_name$_detail = $struct.name$_$relation_name$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=struct)$
    QualifiedTypeName $struct.name$_$relation_name$_detail_type_name = $struct.name$_$relation_name$_detail.type_name();
    ASSERT_EQ("$struct.scopedname$", $struct.name$_$relation_name$_detail_type_name);
    $else$
    //MinimalTypeDetail detail;// Empty. Available for future extension
    $endif$

    $relation_capname$StructMemberSeq $struct.name$_$relation_name$_memberseq = $struct.name$_$relation_name$_struct.member_seq();
    $struct.allMembers:{ member | $check_struct_member_type(ctx=ctx, member=member, relation=true, relation_name="complete", relation_capname="Complete")$ };separator="\n"$
    ASSERT_EQ(memberId, $struct.name$_complete_memberseq.size());
>>

check_struct_member_type(ctx, member, relation, relation_name, relation_capname) ::= <<
    //=====check_struct_member_type - $relation_name$ - $member.name$=====
    $relation_capname$StructMember $struct.name$_$relation_name$_$member.name$ = $struct.name$_$relation_name$_memberseq.at(memberId);
    CommonStructMember $struct.name$_$relation_name$_common_$member.name$_struct_member = $struct.name$_$relation_name$_$member.name$.common();

    MemberId $struct.name$_$relation_name$_common_$member.name$_struct_member_member_id = $struct.name$_$relation_name$_common_$member.name$_struct_member.member_id();
    ASSERT_EQ(memberId, $struct.name$_$relation_name$_common_$member.name$_struct_member.member_id());
    StructMemberFlag $struct.name$_$relation_name$_common_$member.name$_struct_member_member_flags = $struct.name$_$relation_name$_common_$member.name$_struct_member.member_flags();
    {
    $check_member_flags(ctx=ctx, object=member, flags_var_name=["struct_member"])$
    ASSERT_TRUE(struct_member_expected_flags & $struct.name$_$relation_name$_common_$member.name$_struct_member_member_flags);
    }
    TypeIdentifier $member.name$_$relation_name$_common_struct_member_member_type_id = $struct.name$_$relation_name$_common_$member.name$_struct_member.member_type_id();
    $get_type_identifier(typename=member.scopedname)$
    ASSERT_EQ($member.name$_$relation_name$_common_struct_member_type_id->_d(), $member.name$_$relation_name$_common_struct_member_member_type_id._d());
    $if(relation)$
    {    
    CompleteMemberDetail $member.name$_$relation_name$_detail = $struct.name$_$relation_name$_$member.name$.detail();
    $check_optional_detail_annotations(ctx=ctx, object=member)$
    MemberName $struct.name$_$relation_name$_common_$member.name$_struct_member_name = $member.name$_$relation_name$_detail.name();
    ASSERT_EQ("$member.name$", $struct.name$_$relation_name$_common_$member.name$_struct_member_name);
    }
    $else$
    {
    MinimalMemberDetail $member.name$_$relation_name$_detail = $struct.name$_$relation_name$_$member.name$.detail();
    NameHash $struct.name$_$relation_name$_common_$member.name$_struct_member_name_hash = $member.name$_$relation_name$_detail.name_hash();
    MD5 $struct.name$_$relation_name$_common_$member.name$_name_hash("$member.name$");
    for(int i = 0;i < 4;++i)
    {
        ASSERT_EQ($struct.name$_$relation_name$_common_$member.name$_name_hash.digest[i], $struct.name$_$relation_name$_common_$member.name$_struct_member_name_hash[i]);
    }
    }
    $endif$

    $if (member.typecode.isAliasType)$
        //=====member.typecode.isAliasType=====
        $check_alias_related_type(typedefs=member.typecode, relation=relation, relation_name=relation_name, relation_capname=relation_capname)$
    $elseif (member.typecode.PrimitiveType)$
        //=====member.typecode.PrimitiveType=====
        $get_type_identifier(typename=member.scopedname)$
        ASSERT_EQ($member.name$_$relation_name$_member_type->_d(), $struct.name$_$relation_name$_common_$member.name$_struct_member.member_type_id()._d());
    $elseif (member.typecode.isStringType)$
        //=====member.typecode.isStringType=====
        $get_type_identifier(typename=member.scopedname)$
        ASSERT_EQ($member.name$_$relation_name$_member_type->_d(), $struct.name$_$relation_name$_common_$member.name$_struct_member.member_type_id()._d());

        if($member.typecode.maxsize$ <= 255){
            ASSERT_EQ($member.typecode.maxsize$, $struct.name$_$relation_name$_$member.name$_content_type.string_sdefn().bound());
        }else{
            ASSERT_EQ($member.typecode.maxsize$, $struct.name$_$relation_name$_$member.name$_content_type.string_ldefn().bound());
        }
    $elseif (member.typecode.isWStringType)$
        //=====member.typecode.isWStringType=====
        $get_type_identifier(typename=member.scopedname)$
        ASSERT_EQ($member.name$_$relation_name$_member_type->_d(), $struct.name$_$relation_name$_common_$member.name$_struct_member.member_type_id()._d());

        if($member.typecode.maxsize$ <= 255){
            ASSERT_EQ($member.typecode.maxsize$, $struct.name$_$relation_name$_$member.name$_content_type.string_sdefn().bound());
        }else{
            ASSERT_EQ($member.typecode.maxsize$, $struct.name$_$relation_name$_$member.name$_content_type.string_ldefn());
        }
    $elseif (member.typecode.isStructType)$
        //=====member.typecode.isStructType=====
        $check_struct_type(ctx=ctx, struct=member, relation=relation, relation_name=relation_name, relation_capname=relation_capname)$
    $elseif (member.typecode.isArrayType)$
        //=====member.typecode.isArrayType=====
        $check_array_type(ctx=ctx, array=member, relation=relation, relation_name=relation_name, relation_capname=relation_capname)$
    $elseif (member.typecode.isSequenceType)$
        //=====member.typecode.isSequenceType=====
        $check_sequence_type(ctx=ctx, sequence=member, relation=relation, relation_name=relation_name, relation_capname=relation_capname)$
    $elseif (member.typecode.isMapType)$
        //=====member.typecode.isSequenceType=====
        $check_map_type(ctx=ctx, map=member, relation=relation, relation_name=relation_name, relation_capname=relation_capname)$
    $elseif (member.typecode.isUnionType)$
        //=====member.typecode.isUnionType=====
        $check_union_type(ctx=ctx, union=member, relation=relation, relation_name=relation_name, relation_capname=relation_capname)$

    $else$
        //check_struct_member_type UKNOWN TYPE
        std::cout << std::endl << "======================================== Testing struct: $member.typecode$ ========================================" << std::endl;
    memberId = 99;

    $endif$

    memberId++;
>>

check_union_type(union) ::= <<
    //=====check_union_type - $relation_name$ - $union.name$=====
    $get_type_identifier(typename=union.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $union.name$_$relation_name$_type_identifier->_d());

    $get_type_object(typename=union.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $union.name$_$relation_name$_typeobject->_d());

    $relation_capname$TypeObject $union.name$_$relation_name$_object = $union.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_UNION, $union.name$_$relation_name$_object._d());

    $relation_capname$UnionType $union.name$_$relation_name$_union = $union.name$_$relation_name$_object.union_type();

    UnionTypeFlag $union.name$_$relation_name$_union_flags = $union.name$_$relation_name$_union.union_flags();
    {
    $check_type_flags(ctx=ctx, object=union, flags_var_name=["union"])$
    ASSERT_TRUE(union_expected_flags & $union.name$_$relation_name$_union_flags);
    }
    $relation_capname$UnionHeader $union.name$_$relation_name$_header = $union.name$_$relation_name$_union.header();
    $if(relation)$
    {
    CompleteTypeDetail $union.name$_$relation_name$_detail = $union.name$_$relation_name$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=union)$
    QualifiedTypeName $union.name$_$relation_name$_detail_type_name = $union.name$_$relation_name$_detail.type_name();
    ASSERT_EQ("$union.scopedname$", $union.name$_$relation_name$_detail_type_name);
    }
    $else$
    //MinimalTypeDetail detail;// Empty. Available for future extension
    $endif$

    $relation_capname$DiscriminatorMember $union.name$_$relation_name$_discriminator = $union.name$_$relation_name$_union.discriminator();

    CommonDiscriminatorMember $union.name$_$relation_name$_discriminator_common = $union.name$_$relation_name$_discriminator.common();
    UnionDiscriminatorFlag $union.name$_$relation_name$_discriminator_common_member_flags = $union.name$_$relation_name$_discriminator_common.member_flags();
    {
    $check_member_flags(ctx=ctx, object=union.discriminator, flags_var_name=["union_discriminator"])$
    ASSERT_TRUE(union_discriminator_expected_flags & $union.name$_$relation_name$_discriminator_common_member_flags);
    }
    TypeIdentifier $union.name$_$relation_name$_discriminator_common_type_id = $union.name$_$relation_name$_discriminator_common.type_id();
    $get_type_identifier(typename=union.scopedname)$  
    ASSERT_EQ($union.name$_$relation_name$_discriminator_common_factory_type_id->_d(), $union.name$_$relation_name$_discriminator_common.type_id()._d());
    $if(relation)$
    CompleteDiscriminatorMember $union.name$_$relation_name$_detail = $union.name$_$relation_name$_union.discriminator();
    $check_optional_detail_annotations(ctx=ctx, object=union)$
    $endif$

    $relation_capname$UnionMemberSeq $union.name$_$relation_name$_memberseq = $union.name$_$relation_name$_union.member_seq();
    $union.members:{ member | $check_union_member_type(ctx=ctx, member=member, relation=true, relation_name="complete", relation_capname="Complete")$ };separator="\n"$
    ASSERT_EQ(memberId, $union.name$_complete_memberseq.size());
>>

check_union_member_type(ctx, member, relation, relation_name, relation_capname) ::= <<
    //=====check_union_member_type - $relation_name$ - $member.name$=====
    $relation_capname$UnionMember $union.name$_$relation_name$_$member.name$_member = $union.name$_$relation_name$_memberseq.at(memberId);
    CommonUnionMember $union.name$_$relation_name$_common_$member.name$_common = $union.name$_$relation_name$_$member.name$_member.common();

    MemberId $union.name$_$relation_name$_common_$member.name$_memberid = $union.name$_$relation_name$_common_$member.name$_common.member_id();
    ASSERT_EQ(memberId, $union.name$_$relation_name$_common_$member.name$_memberid);

    UnionMemberFlag $union.name$_$relation_name$_common_$member.name$_memberflags = $union.name$_$relation_name$_common_$member.name$_common.member_flags();
    {
    $check_member_flags(ctx=ctx, object=union.member, flags_var_name=["union_member"])$
    ASSERT_TRUE(union_member_expected_flags & $union.name$_$relation_name$_common_$member.name$_memberflags);
    }

    TypeIdentifier $union.name$_$relation_name$_common_$member.name$_member_typeid = $union.name$_$relation_name$_common_$member.name$_common.type_id();
    $get_type_identifier(typename=member.scopedname)$  
    ASSERT_EQ($member.name$_$relation_name$_common_member_factory_type_id->_d(), $union.name$_$relation_name$_common_$member.name$_member_typeid._d());

    UnionCaseLabelSeq $union.name$_$relation_name$_common_$member.name$_member_labelseq = $union.name$_$relation_name$_common_$member.name$_common.label_seq();
    {
    int $union.name$_label_index = 0;
    $member.labels:{ label |
    ASSERT_EQ($label$, $union.name$_$relation_name$_common_$member.name$_member_labelseq.at($union.name$_label_index));
    $union.name$_label_index++;
    };separator="\n"$
    }
    $if(relation)$
    {    
    CompleteMemberDetail $member.name$_$relation_name$_detail = $union.name$_$relation_name$_$member.name$_member.detail();
    $check_optional_detail_annotations(ctx=ctx, object=member)$
    MemberName $member.name$_$relation_name$_common_$member.name$_union_member_name = $member.name$_$relation_name$_detail.name();
    ASSERT_EQ("$member.name$", $member.name$_$relation_name$_common_$member.name$_union_member_name);
    }
    $else$
    {
    MinimalMemberDetail $member.name$_$relation_name$_detail = $union.name$_$relation_name$_$member.name$_member.detail();
    NameHash $member.name$_$relation_name$_union_member_name_hash = $member.name$_$relation_name$_detail.name_hash();
    MD5 $member.name$_$relation_name$_name_hash("$member.name$");
    for(int i = 0;i < 4;++i)
    {
        ASSERT_EQ($member.name$_$relation_name$_name_hash.digest[i], $member.name$_$relation_name$_union_member_name_hash[i]);
    }
    }
    $endif$

    memberId++;
>>

check_enum_type(enum) ::= <<
    //=====check_enum_type - $relation_name$ - $enum.name$=====
    $get_type_identifier(typename=enum.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $enum.name$_$relation_name$_type_identifier->_d());

    $get_type_object(typename=enum.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $enum.name$_$relation_name$_typeobject->_d());

    $relation_capname$TypeObject $enum.name$_$relation_name$_object = $enum.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_ENUM, $enum.name$_$relation_name$_object._d());

    $relation_capname$EnumeratedType $enum.name$_$relation_name$_enum = $enum.name$_$relation_name$_object.enumerated_type();
    //EnumTypeFlag flags;// Unused. No flags apply

    $relation_capname$EnumeratedHeader $enum.name$_$relation_name$_header = $enum.name$_$relation_name$_enum.header();

    CommonEnumeratedHeader $enum.name$_$relation_name$_commonheader = $enum.name$_$relation_name$_header.common();
    BitBound $enum.name$_$relation_name$_commonheader_bit_bound = $enum.name$_$relation_name$_commonheader.bit_bound();
    ASSERT_EQ($enum.bitBound$, $enum.name$_$relation_name$_commonheader_bit_bound);

    $if(relation)$
    CompleteTypeDetail $enum.name$_$relation_name$_detail = $enum.name$_$relation_name$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=enum)$
    QualifiedTypeName $enum.name$_$relation_name$_detail_type_name = $enum.name$_$relation_name$_detail.type_name();
    ASSERT_EQ("$enum.scopedname$", $enum.name$_$relation_name$_detail_type_name);
    $endif$

    $relation_capname$EnumeratedLiteralSeq $enum.name$_$relation_name$_literalseq = $enum.name$_$relation_name$_enum.literal_seq();
    $enum.members:{ literal | $check_enum_literal_type(ctx=ctx, literal=literal, relation=true, relation_name="complete", relation_capname="Complete")$ };separator="\n"$
    ASSERT_EQ(literalId, $enum.name$_complete_literalseq.size());
>>

check_enum_literal_type(ctx, literal, relation, relation_name, relation_capname) ::= <<
    //=====check_enum_literal_type - $relation_name$ - $literal.name$=====
    $relation_capname$EnumeratedLiteral $enum.name$_$relation_name$_$literal.name$ = $enum.name$_$relation_name$_literalseq.at(literalId);
    CommonEnumeratedLiteral $enum.name$_$relation_name$_common_$literal.name$_enum_literal = $enum.name$_$relation_name$_$literal.name$.common();
    
    long $enum.name$_$relation_name$_common_$literal.name$_enum_literal_value = $enum.name$_$relation_name$_common_$literal.name$_enum_literal.value();
    ASSERT_EQ(literalId, $enum.name$_$relation_name$_common_$literal.name$_enum_literal.value());
    
    EnumeratedLiteralFlag $enum.name$_$relation_name$_common_$literal.name$_enum_flags = $enum.name$_$relation_name$_common_$literal.name$_enum_literal.flags();
    {
    $check_member_flags(ctx=ctx, object=literal, flags_var_name=["enum_literal"])$
    ASSERT_TRUE(enum_literal_expected_flags & $enum.name$_$relation_name$_common_$literal.name$_enum_flags);
    }
    $if(relation)$
    {
    CompleteMemberDetail $literal.name$_$relation_name$_detail = $enum.name$_$relation_name$_$literal.name$.detail();
    $check_optional_detail_annotations(ctx=ctx, object=literal)$
    MemberName $literal.name$_$relation_name$_detail_member_name = $literal.name$_$relation_name$_detail.name();
    ASSERT_EQ("$literal.name$", $literal.name$_$relation_name$_detail_member_name);
    }
    $endif$

    literalId++;
>>

check_bitmask_type(bitmask) ::= <<
    //=====check_bitmask_type - $relation_name$ - $bitmask.name$=====
    $get_type_identifier(typename=bitmask.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $bitmask.name$_$relation_name$_type_identifier->_d());

    $get_type_object(typename=bitmask.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $bitmask.name$_$relation_name$_typeobject->_d());

    $relation_capname$TypeObject $bitmask.name$_$relation_name$_object = $bitmask.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_BITMASK, $bitmask.name$_$relation_name$_object._d());

    $relation_capname$BitmaskType $bitmask.name$_$relation_name$_bitmask = $bitmask.name$_$relation_name$_object.bitmask_type();
    //BitmaskTypeFlag flags;// Unused. No flags apply

    $relation_capname$BitmaskHeader $bitmask.name$_$relation_name$_header = $bitmask.name$_$relation_name$_bitmask.header();
    CommonBitmaskHeader $bitmask.name$_$relation_name$_commonheader = $bitmask.name$_$relation_name$_header.common();

    BitBound $bitmask.name$_$relation_name$_commonheader_bit_bound = $bitmask.name$_$relation_name$_commonheader.bit_bound();
    ASSERT_EQ($bitmask.bitBound$, $bitmask.name$_$relation_name$_commonheader_bit_bound);

    $relation_capname$BitflagSeq $bitmask.name$_$relation_name$_flagseq = $bitmask.name$_$relation_name$_bitmask.flag_seq();
    $bitmask.members:{ flag | $check_bitmask_flag_type(ctx=ctx, flag=flag, relation=true, relation_name="complete", relation_capname="Complete")$ };separator="\n"$
    ASSERT_EQ(flagId, $bitmask.name$_complete_flagseq.size());
>>

check_bitmask_flag_type(ctx, flag, relation, relation_name, relation_capname) ::= <<
    //=====check_bitmask_flag_type - $relation_name$ - $flag.name$=====
    $relation_capname$Bitflag $bitmask.name$_$relation_name$_$flag.name$ = $bitmask.name$_$relation_name$_flagseq.at(flagId);
    CommonBitflag $bitmask.name$_$relation_name$_common_$flag.name$_bitmask_flag = $bitmask.name$_$relation_name$_$flag.name$.common();
    
    unsigned short $bitmask.name$_$relation_name$_common_$flag.name$_bitmask_flag_position = $bitmask.name$_$relation_name$_common_$flag.name$_bitmask_flag.position();
    ASSERT_EQ(flagId, $bitmask.name$_$relation_name$_common_$flag.name$_bitmask_flag_position);

    //BitflagFlag flags;// Unused. No flags apply

    $if(relation)$
    {
    CompleteMemberDetail $flag.name$_$relation_name$_detail = $bitmask.name$_$relation_name$_$flag.name$.detail();
    $check_optional_detail_annotations(ctx=ctx, object=flag)$
    MemberName $flag.name$_$relation_name$_detail_flag_name = $flag.name$_$relation_name$_detail.name();
    ASSERT_EQ("$flag.name$", $flag.name$_$relation_name$_detail_flag_name);
    }
    $else$
    {
    MinimalMemberDetail $bitmask.name$_$relation_name$_detail = $bitmask.name$_$relation_name$_$flag.name$.detail();
    NameHash $flag.name$_$relation_name$_flag_name_hash = $bitmask.name$_$relation_name$_detail.name_hash();
    MD5 $flag.name$_$relation_name$_name_hash("$flag.name$");
    for(int i = 0;i < 4;++i)
    {
        ASSERT_EQ($flag.name$_$relation_name$_name_hash.digest[i], $flag.name$_$relation_name$_flag_name_hash[i]);
    }
    }
    $endif$

    flagId++;
>>

check_bitset_type(bitset) ::= <<
    //=====check_bitset_type - $relation_name$ - $bitset.name$=====
    $get_type_identifier(typename=bitset.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $bitset.name$_$relation_name$_type_identifier->_d());

    $get_type_object(typename=bitset.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $bitset.name$_$relation_name$_typeobject->_d());

    $relation_capname$TypeObject $bitset.name$_$relation_name$_object = $bitset.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_BITSET, $bitset.name$_$relation_name$_object._d());

    $relation_capname$BitsetType $bitset.name$_$relation_name$_bitset = $bitset.name$_$relation_name$_object.bitset_type();
    //BitsetTypeFlag bitset_flags;// Unused. No flags apply

    $relation_capname$BitsetHeader $bitset.name$_$relation_name$_header = $bitset.name$_$relation_name$_bitset.header();

    $if(relation)$
    CompleteTypeDetail $bitset.name$_$relation_name$_detail = $bitset.name$_$relation_name$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=bitset)$
    QualifiedTypeName $bitset.name$_$relation_name$_detail_type_name = $bitset.name$_$relation_name$_detail.type_name();
    ASSERT_EQ("$bitset.scopedname$", $bitset.name$_$relation_name$_detail_type_name);
    $else$
    //MinimalTypeDetail detail;// Empty. Available for future extension
    $endif$

    $relation_capname$BitfieldSeq $bitset.name$_$relation_name$_bitfieldseq = $bitset.name$_$relation_name$_bitset.field_seq();
    $bitset.members:{ bitfield | $check_bitfield_type(ctx=ctx, bitfield=bitfield, relation=true, relation_name="complete", relation_capname="Complete")$ };separator="\n"$
    ASSERT_EQ(bitfieldId, $bitset.name$_complete_bitfieldseq.size());
>>

check_bitfield_type(ctx, bitfield, relation, relation_name, relation_capname) ::= <<
    //=====check_bitfield_type - $relation_name$ - $bitfield.name$=====
    $relation_capname$Bitfield field_$bitset.name$_$relation_name$_$bitfield.name$ = $bitset.name$_$relation_name$_bitfieldseq.at(bitfieldId);
    CommonBitfield $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield = field_$bitset.name$_$relation_name$_$bitfield.name$.common();
    
    unsigned short $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield_position = $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield.position();
    ASSERT_EQ(bitfieldId, $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield_position);
    //BitsetMemberFlag flags;// Unused. No flags apply
    octet $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield_bitcount = $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield.bitcount();
    ASSERT_EQ($bitfield.spec.bitSize$, $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield_bitcount);
    TypeKind $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield_holder_type = $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield.holder_type();// Must be primitive integer type
    ASSERT_EQ($bitfield.spec.typecode.typeIdentifier$, $bitset.name$_$relation_name$_common_$bitfield.name$_bitset_bitfield_holder_type);

    //Bitfieldbitfield bitfields;// Unused. No bitfields apply

    $if(relation)$
    {
    CompleteMemberDetail $bitfield.name$_$relation_name$_detail = field_$bitset.name$_$relation_name$_$bitfield.name$.detail();
    MemberName $bitfield.name$_$relation_name$_detail_bitfield_name = $bitfield.name$_$relation_name$_detail.name();
    ASSERT_EQ("$bitfield.name$", $bitfield.name$_$relation_name$_detail_bitfield_name);
    }
    $else$
    {
    NameHash field_$bitset.name$_$relation_name$_$bitfield.name$_name_hash = field_$bitset.name$_$relation_name$_$bitfield.name$.name_hash();
    MD5 minimal_field_$bitset.name$_$relation_name$_$bitfield.name$_name_hash("$bitfield.name$");
    for(int i = 0;i < 4;++i)
    {
        ASSERT_EQ(minimal_field_$bitset.name$_$relation_name$_$bitfield.name$_name_hash.digest[i], field_$bitset.name$_$relation_name$_$bitfield.name$_name_hash[i]);
    }
    }
    $endif$

    bitfieldId++;
>>

check_annotation_type(annotation) ::= <<
    //=====check_annotation_type - $relation_name$ - $annotation.name$=====
    $get_type_identifier(typename=annotation.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $annotation.name$_$relation_name$_type_identifier->_d());

    $get_type_object(typename=annotation.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $annotation.name$_$relation_name$_typeobject->_d());

    $relation_capname$TypeObject $annotation.name$_$relation_name$_object = $annotation.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_ANNOTATION, $annotation.name$_$relation_name$_object._d());

    $relation_capname$AnnotationType $annotation.name$_$relation_name$_annotation = $annotation.name$_$relation_name$_object.annotation_type();
    //AnnotationTypeFlag annotation_flag;// Unused. No flags apply

    $relation_capname$AnnotationHeader $annotation.name$_$relation_name$_header = $annotation.name$_$relation_name$_annotation.header();
    $if(relation)$
    QualifiedTypeName $annotation.name$_$relation_name$_name = $annotation.name$_$relation_name$_header.annotation_name();
    ASSERT_EQ("$annotation.name$", $annotation.name$_$relation_name$_name);
    $endif$

    $relation_capname$AnnotationParameterSeq $annotation.name$_$relation_name$_memberseq = $annotation.name$_$relation_name$_annotation.member_seq();
    $annotation.members:{ parameter | $check_annotation_parameter_type(ctx=ctx, parameter=parameter, relation=false, relation_name="minimal", relation_capname="Minimal")$ };separator="\n"$
    ASSERT_EQ(memberId, $annotation.name$_minimal_memberseq.size());
>>

check_annotation_parameter_type(ctx, parameter, relation, relation_name, relation_capname) ::= <<
    //=====check_annotation_parameter_type - $relation_name$ - $parameter.name$=====
    $relation_capname$AnnotationParameter $annotation.name$_$relation_name$_$parameter.name$ = $annotation.name$_$relation_name$_memberseq.at(memberId);
    CommonAnnotationParameter $annotation.name$_$relation_name$_common_$parameter.name$_parameter_member = $annotation.name$_$relation_name$_$parameter.name$.common();
    //AnnotationParameterFlag member_flags;// Unused. No flags apply

    TypeIdentifier $annotation.name$_$relation_name$_common_$parameter.name$_parameter_member_typeid = $annotation.name$_$relation_name$_common_$parameter.name$_parameter_member.member_type_id();
    const TypeIdentifier* $annotation.name$_$relation_name$_common_$parameter.name$_factory_typeid = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$parameter.typecode.cppTypename$", $relation$);
    ASSERT_EQ($annotation.name$_$relation_name$_common_$parameter.name$_factory_typeid->_d(), $annotation.name$_$relation_name$_common_$parameter.name$_parameter_member_typeid._d());

    $if(relation)$
    MemberName $annotation.name$_$relation_name$_$parameter.name$_name = $annotation.name$_$relation_name$_$parameter.name$.name();
    ASSERT_EQ("$parameter.name$", $annotation.name$_$relation_name$_$parameter.name$_name);
    $else$
    NameHash $annotation.name$_$relation_name$_$parameter.name$_member_name_hash = $annotation.name$_$relation_name$_$parameter.name$.name_hash();
    MD5 $annotation.name$_$relation_name$_$parameter.name$_name_hash("$flag.name$");
    for(int i = 0;i < 4;++i)
    {
        ASSERT_EQ($annotation.name$_$relation_name$_$parameter.name$_name_hash.digest[i], $annotation.name$_$relation_name$_$parameter.name$_member_name_hash[i]);
    }
    $endif$

    AnnotationParameterValue $annotation.name$_$relation_name$_$parameter.name$_default_value = $annotation.name$_$relation_name$_$parameter.name$.default_value();
    $if(parameter.typecode.primitiveType)$
    $if(parameter.typecode.isBooleanType)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.boolean_value());
    $elseif(parameter.typecode.isByteType)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.byte_value());
    $elseif(parameter.typecode.isInt8Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.int8_value());
    $elseif(parameter.typecode.isUint8Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.uint8_value());
    $elseif(parameter.typecode.isInt16Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.int16_value());
    $elseif(parameter.typecode.isUint16Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.uint16_value());
    $elseif(parameter.typecode.isInt32Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.int32_value());
    $elseif(parameter.typecode.isUint32Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.uint32_value());
    $elseif(parameter.typecode.isInt64Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.int64_value());
    $elseif(parameter.typecode.isUint64Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.uint64_value());
    $elseif(parameter.typecode.isFloat32Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.float32_value());
    $elseif(parameter.typecode.isFloat64Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.float64_value());
    $elseif(parameter.typecode.isFloat128Type)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.float128_value());
    $elseif(parameter.typecode.isCharType)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.char_value());
    $elseif(parameter.typecode.isWCharType)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.wchar_value());
    $endif$
    $elseif(parameter.typecode.isEnumType)$
    ASSERT_EQ($parameter.value$, $annotation.name$_$relation_name$_$parameter.name$_default_value.enumerated_value());
    $elseif(parameter.typecode.isStringType)$
    ASSERT_EQ("$parameter.value$", $annotation.name$_$relation_name$_$parameter.name$_default_value.string8_value());
    $elseif(parameter.typecode.isWStringType)$
    ASSERT_EQ("$parameter.value$", $annotation.name$_$relation_name$_$parameter.name$_default_value.string16_value());
    $endif$
    memberId++;
>>

check_array_type(ctx, array, relation, relation_name, relation_capname) ::= <<
    //=====check_array_type - $relation_name$ - $array.name$=====
    $get_type_identifier(typename=array.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $array.name$_$relation_name$_type_identifier->_d());

    $get_type_identifier(typename=array.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $array.name$_$relation_name$_typeobject->_d());

    $relation_capname$TypeObject $array.name$_$relation_name$_object = $array.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_ARRAY, $array.name$_$relation_name$_object._d());

    $relation_capname$ArrayType $array.name$_$relation_name$_array = $array.name$_$relation_name$_object.array_type();
    //CollectionTypeFlag collection_flag;// Unused. No flags apply
    
    $relation_capname$ArrayHeader $array.name$_$relation_name$_header = $array.name$_$relation_name$_array.header();
    $if(relation)$
    CompleteTypeDetail $array.name$_$relation_name$_detail = $array.name$_$relation_name$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=array)$
    QualifiedTypeName $array.name$_$relation_name$_detail_type_name = $array.name$_$relation_name$_detail.type_name();
    ASSERT_EQ("$array.scopedname$", $array.name$_$relation_name$_detail_type_name);
    $endif$

    CommonArrayHeader $array.name$_$relation_name$_header_common = $array.name$_$relation_name$_header.common();
    LBoundSeq $array.name$_$relation_name$_header_common_bound_seq = $array.name$_$relation_name$_header_common.bound_seq();

    int dimension_bound_index = 0;
    $array.typecode.dimensions:{ dimension_bound |
    ASSERT_EQ($dimension_bound$, $array.name$_$relation_name$_header_common_bound_seq.at(dimension_bound_index));
    dimension_bound_index++;
    };separator="\n"$

    $relation_capname$CollectionElement $array.name$_$relation_name$_collection_element = $array.name$_$relation_name$_array.element();
    CommonCollectionElement $array.name$_$relation_name$_common_element = $array.name$_$relation_name$_collection_element.common();

    CollectionElementFlag $array.name$_$relation_name$_common_element_flags = $array.name$_$relation_name$_common_element.element_flags();
    {
    $check_member_flags(ctx=ctx, object=array, flags_var_name=["array"])$
    ASSERT_TRUE(array_expected_flags & $map.name$_$relation_name$_array);
    }
    $get_type_identifier(typename=array.scopedname)$
    ASSERT_EQ($array.name$_$relation_name$_common_element_id->_d(), $array.name$_$relation_name$_common_element.type()._d());

    $if(relation)$
{
    CompleteElementDetail $array.name$_$relation_name$_detail = $array.name$_$relation_name$_collection_element.detail();
    $check_optional_detail_annotations(ctx=ctx, object=array)$
}
    $endif$

    int $array.name$_$relation_name$_totalsize = $member.typecode.dimensions:{ dim | $dim$};separator=" + "$;
    
    if($array.name$_$relation_name$_totalsize <= 100){
        SBoundSeq $array.name$_$relation_name$_s_bound_seq;
        $member.typecode.dimensions:{ dim | $array.name$_$relation_name$_s_bound_seq.push_back($dim$);};separator="\n"$
        ASSERT_EQ($array.name$_$relation_name$_s_bound_seq, $array.name$_$relation_name$_type_identifier.array_sdefn().array_bound_seq());
    }else{
        LBoundSeq $array.name$_$relation_name$_l_bound_seq;
        $member.typecode.dimensions:{ dim | $array.name$_$relation_name$_l_bound_seq.push_back($dim$);};separator="\n"$
        ASSERT_EQ($array.name$_$relation_name$_l_bound_seq, $array.name$_$relation_name$_type_identifier.array_ldefn().array_bound_seq());
    }
>>

check_sequence_type(ctx, sequence, relation, relation_name, relation_capname) ::= <<
    //=====check_sequence_type - $relation_name$ - $sequence.name$=====
    $get_type_identifier(typename=sequence.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $sequence.name$_$relation_name$_type_identifier._d());

    $get_type_identifier(typename=sequence.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $sequence.name$_$relation_name$_typeobject->_d());

    $relation_capname$TypeObject $sequence.name$_$relation_name$_object = $sequence.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_SEQUENCE, $sequence.name$_$relation_name$_object._d());

    $relation_capname$SequenceType $sequence.name$_$relation_name$_sequence = $sequence.name$_$relation_name$_object.sequence_type();
    //CollectionTypeFlag collection_flag;// Unused. No flags apply
    
    $relation_capname$CollectionHeader $sequence.name$_$relation_name$_header = $sequence.name$_$relation_name$_sequence.header();
    CommonCollectionHeader $sequence.name$_$relation_name$_commonheader = $sequence.name$_$relation_name$_header.common();
    ASSERT_EQ($array.typecode.maxsize$, $array.name$_$relation_name$_header_common.bound());

    $if(relation)$
    CompleteTypeDetail $sequence.name$_$relation_name$_detail = $sequence.name$_$relation_name$_header.detail();// not present for anonymous
    $check_optional_detail_annotations(ctx=ctx, object=sequence)$
    QualifiedTypeName $sequence.name$_$relation_name$_detail_type_name = $sequence.name$_$relation_name$_detail.type_name();
    ASSERT_EQ("$sequence.scopedname$", $sequence.name$_$relation_name$_detail_type_name);
    $endif$

    $relation_capname$CollectionElement $sequence.name$_$relation_name$_collection_element = $sequence.name$_$relation_name$_sequence.element();
    CommonCollectionElement $sequence.name$_$relation_name$_common_element = $sequence.name$_$relation_name$_collection_element.common();

    CollectionElementFlag $sequence.name$_$relation_name$_common_element_flags = $sequence.name$_$relation_name$_common_element.element_flags();
    {
    $check_member_flags(ctx=ctx, object=sequence, flags_var_name=["sequence"])$
    ASSERT_TRUE(sequence_expected_flags & $sequence.name$_$relation_name$_common_element_flags);
    }

    $get_type_identifier(typename=sequence.scopedname)$
    ASSERT_EQ($sequence.name$_$relation_name$_common_element_id->_d(), $sequence.name$_$relation_name$_type_identifier._d());
       
    $if(relation)$
    {
    CompleteElementDetail $sequence.name$_$relation_name$_detail = $sequence.name$_$relation_name$_collection_element.detail();
    $check_optional_detail_annotations(ctx=ctx, object=sequence)$
    }
    $endif$

    if($sequence.typecode.maxsize$ <= 100){
        ASSERT_EQ($sequence.typecode.maxsize$, $sequence.name$_$relation_name$_type_identifier.seq_sdefn().bound());
    }else{
        ASSERT_EQ($sequence.typecode.maxsize$, $sequence.name$_$relation_name$_type_identifier.seq_ldefn().bound());
    }
>>

check_map_type(ctx, map, relation, relation_name, relation_capname) ::= <<
    //=====check_map_type - $relation_name$ - $map.name$=====
    $get_type_identifier(typename=map.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $map.name$_$relation_name$_type_identifier._d());

    $get_type_identifier(typename=map.scopedname)$
    ASSERT_EQ(eprosima::fastrtps::types::EK_$if(relation)$COMPLETE$else$MINIMAL$endif$, $map.name$_$relation_name$_typeobject->_d());

    $relation_capname$TypeObject $map.name$_$relation_name$_object = $map.name$_$relation_name$_typeobject->$relation_name$();
    ASSERT_EQ(TK_MAP, $map.name$_$relation_name$_object._d());

    $relation_capname$MapType $map.name$_$relation_name$_map = $map.name$_$relation_name$_object.map_type();
    //CollectionTypeFlag collection_flag;// Unused. No flags apply
    
    //$relation_capname$CollectionHeader header;// Empty. Available for future extension

    CommonCollectionHeader $map.name$_$relation_name$_commonheader = $map.name$_$relation_name$_header.common();
    ASSERT_EQ($map.typecode.maxsize$, $map.name$_$relation_name$_commonheader.bound());

    $if(relation)$
    CompleteTypeDetail $map.name$_$relation_name$_detail = $map.name$_$relation_name$_header.detail();// not present for anonymous
    $check_optional_detail_annotations(ctx=ctx, object=map)$
    QualifiedTypeName $map.name$_$relation_name$_detail_type_name = $map.name$_$relation_name$_detail.type_name();
    ASSERT_EQ("$map.scopedname$", $map.name$_$relation_name$_detail_type_name);
    $endif$

    $relation_capname$CollectionElement $map.name$_$relation_name$_collection_key_element = $map.name$_$relation_name$_map.key();
    CommonCollectionElement $map.name$_$relation_name$_key_common_element = $map.name$_$relation_name$_collection_key_element.common();
    CollectionElementFlag $map.name$_$relation_name$_key_common_element_flags = $map.name$_$relation_name$_key_common_element.element_flags();
    {
    $check_member_flags(ctx=ctx, object=map.key, flags_var_name=["key_common_element"])$
    ASSERT_TRUE(key_common_element_expected_flags & $map.name$_$relation_name$_key_common_element_flags);
    }
    $get_type_identifier(typename=map.key.typecode.scopedname)$
    ASSERT_EQ($map.key.typecode.name$_$relation_name$_key_common_element_type_id->_d(), $map.name$_$relation_name$_key_common_element.type()._d());
      
    $if(relation)$
    {
    CompleteElementDetail $map.name$_$relation_name$_detail = $map.name$_$relation_name$_collection_key_element.detail();
    $check_optional_detail_annotations(ctx=ctx, object=map)$
    }
    $endif$

    $relation_capname$CollectionElement $map.name$_$relation_name$_element_collection_element = $map.name$_$relation_name$_map.element();
    CommonCollectionElement $map.name$_$relation_name$_element_common_element = $map.name$_$relation_name$_element_collection_element.common();
    CollectionElementFlag $map.name$_$relation_name$_element_common_element_flags = $map.name$_$relation_name$_element_common_element.element_flags();
    {
    $check_member_flags(ctx=ctx, object=map.element, flags_var_name=["element_common_element"])$
    ASSERT_TRUE(element_common_element_expected_flags & $map.name$_$relation_name$_element_common_element_flags);
    }
    $get_type_identifier(typename=map.element.typecode.scopedname)$
    ASSERT_EQ($map.element.typecode.name$_$relation_name$_element_common_element_type_id->_d(), $map.name$_$relation_name$_element_common_element.type()._d());

    $if(relation)$
    {
    CompleteElementDetail $map.name$_$relation_name$_detail = $map.name$_$relation_name$_element_collection_element.detail();
    $check_optional_detail_annotations(ctx=ctx, object=map)$
    }
    $endif$

    if($map.typecode.maxsize$ <= 100){
        ASSERT_EQ($map.typecode.maxsize$, $map.name$_$relation_name$_type_identifier.seq_sdefn().bound());
    }else{
        ASSERT_EQ($map.typecode.maxsize$, $map.name$_$relation_name$_type_identifier.seq_ldefn().bound());
    }
>>


test_typedef(typedefs) ::= <<
TEST(TypeObjectTests, TestTypedefTypeObject_$typedefs.name$)
{
    $check_alias_type(typedefs=typedefs)$
}
>>

test_structure(struct) ::= <<
TEST(TypeObjectTests, TestStructureTypeObject_$struct.name$)
{
    $check_struct_type(struct=struct)$ 
}
>>

test_union(union) ::= <<
TEST(TypeObjectTests, TestUnionTypeObject_$union.name$)
{
    $check_union_type(union=union)$ 
}
>>

test_enum(enum) ::= <<
TEST(TypeObjectTests, TestEnumTypeObject_$enum.name$)
{
    $check_enum_type(enum=enum)$ 
}
>>

test_bitmask(bitmask) ::= <<
TEST(TypeObjectTests, TestBitmaskTypeObject_$bitmask.name$)
{
    $check_bitmask_type(bitmask=bitmask)$ 
}
>>

test_bitset(bitset) ::= <<
TEST(TypeObjectTests, TestBitsetTypeObject_$bitset.name$)
{
    $check_bitset_type(bitset=bitset)$ 
}
>>

test_annotation(annotation) ::= <<
TEST(TypeObjectTests, TestAnnotationTypeObject_$annotation.name$)
{
    $check_annotation_type(annotation=annotation)$
}
>>

test_sequence(sequence) ::= <<
TEST(TypeObjectTests, TestSequenceTypeObject_$sequence_name(sequence)$)
{
    $check_sequence_type(sequence=sequence)$
}
>>

test_map(map) ::= <<
TEST(TypeObjectTests, TestMapTypeObject_$map_name(map)$)
{
    $check_map_type(map=map)$
}
>>

test_array(array) ::= <<
TEST(TypeObjectTests, TestArrayTypeObject_$array_name(array)$)
{
    $check_array_type(array=array)$
}
>>

test_string(string) ::= <<
TEST(TypeObjectTests, TestStringTypeObject_$string_name(name)$)
{
    $check_string_type(string=string)$
}
>>

test_wstring(wstring) ::= <<
TEST(TypeObjectTests, TestWstringTypeObject_$wstring_name(wstring)$)
{
    $check_wstring_type(wstring=wstring)$
}
>>

fwd_decl(ctx, parent, type) ::= <<>>

typedef_decl(ctx, parent, typedefs, typedefs_type, declarator_type) ::= <<
$declarator_type$
$typedefs_type$
$test_typedef(typedefs=typedefs)$
>>

struct_type(ctx, parent, struct, member_list) ::= <<
$member_list$
$test_structure(struct=struct)$
>>

union_type(ctx, parent, union, switch_type) ::= <<
$switch_type$
$test_union(union=union)$
>>

enum_type(ctx, parent, enum) ::= <<
$test_enum(enum=enum)$
>>

bitmask_type(ctx, parent, bitmask) ::= <<
$test_bitmask(bitmask=bitmask)$
>>

bitset_type(ctx, parent, bitset, extensions) ::= <<
$test_bitset(bitset=bitset)$
>>

annotation(ctx, annotation) ::= <<
$test_annotation(annotation=annotation)$
>>

module(ctx, parent, module, definition_list) ::= <<
$definition_list$
>>

definition_list(definitions) ::= <<
$definitions;separator="\n"$
>>

const_decl(ctx, parent, const, const_type) ::= <<
$const_type$
>>

member_type(ctx, member, type_member, declarators) ::= <<
$type_member$
$declarators$
>>

element_type(ctx, element, type_element, declarator) ::= <<>>

sequence_type(ctx, sequence, type_sequence) ::= <<
$type_sequence$
$test_sequence(sequence=sequence)$
>>

map_type(ctx, map, key_type, value_type) ::= <<
$key_type$
$value_type$
$test_map(map=map)$
>>

string_type(ctx, string) ::= <<
$test_string(string=string)$
>>

wide_string_type(ctx, wstring) ::= <<
$test_wstring(wstring=wstring)$
>>

array_declarator(ctx, array, array_type) ::= <<
$test_array(array=array)$
>>

sequence_name(sequence) ::= <<
anonymous_sequence_$sequence.contentTypeCode.cppTypename$_$if(sequence.unbound)$4294967295$else$$sequence.evaluatedMaxsize$$endif$
>>

map_name(map) ::= <<
anonymous_map_$map.keyTypeCode.cppTypename$_$map.valueTypeCode.cppTypename$_$if(map.isBounded)$$map.evaluatedMaxsize$$else$4294967295$endif$
>>

array_name(array, array_type) ::= <<
anonymous_array_$array_type$$array.evaluatedDimensions : { dimension | _$dimension$}$
>>

string_name(string) ::= <<
anonymous_string_$if(string.isBounded)$$string.evaluatedMaxsize$$else$4294967295$endif$
>>

wstring_name(wstring) ::= <<
anonymous_wstring_$if(wstring.isBounded)$$wstring.evaluatedMaxsize$$else$4294967295$endif$
>>
