// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

import "eprosima.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "TypeObjectTestingTest.cpp"], description=["This file contains TypeObject test code."])$


#include "iostream"
#include "$ctx.filename$TypeObject.h"
//#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>

#include <fastdds/dds/domain/DomainParticipantFactory.hpp>

#include <stdint.h>
#include <inttypes.h>
#include <string.h>
#include <functional>
#include <vector>

using TestLambda = std::function<bool()>;

std::vector<TestLambda> functions_to_run;

int main(void)
{
    srand((unsigned) time(NULL));
    bool ret_value = true;
    
    register$ctx.filename$Types();  

    $definitions; separator="\n"$

    for (auto& fc : functions_to_run)
    {
        ret_value &= fc();
    }
    return ret_value ? 0 : 1;
}

>>


check_alias_type(ctx, typedefs, relation) ::= <<
    const TypeIdentifier* $typedefs.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$typedefs.name$_identifier($relation$);
    result &= $typedefs.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $typedefs.name$_$if(relation)$complete$else$minimal$endif$_type_identifier->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $typedefs.name$_$if(relation)$complete$else$minimal$endif$_typeobject = get_$typedefs.name$_object($relation$);
    result &= $typedefs.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $typedefs.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $typedefs.name$_$if(relation)$complete$else$minimal$endif$_object = $typedefs.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $typedefs.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_ALIAS;

    $if(relation)$Complete$else$Minimal$endif$AliasType $typedefs.name$_$if(relation)$complete$else$minimal$endif$_typedefs = $typedefs.name$_$if(relation)$complete$else$minimal$endif$_object.alias_type();
    //AliasTypeFlag alias_flags;// Unused. No flags apply
    $if(relation)$Complete$else$Minimal$endif$AliasHeader $typedefs.name$_$if(relation)$complete$else$minimal$endif$_header = $typedefs.name$_$if(relation)$complete$else$minimal$endif$_typedefs.header();// Empty. Available for future extension

    $if(relation)$
    CompleteTypeDetail $typedefs.name$_$if(relation)$complete$else$minimal$endif$_header_detail = $typedefs.name$_$if(relation)$complete$else$minimal$endif$_header.detail();// not present for anonymous
    $check_optional_detail_annotations(ctx=ctx, object=typedefs)$
    QualifiedTypeName $typedefs.name$_$if(relation)$complete$else$minimal$endif$_header_detail_type_name = $typedefs.name$_$if(relation)$complete$else$minimal$endif$_header_detail.type_name();
    result &= $typedefs.name$_$if(relation)$complete$else$minimal$endif$_header_detail_type_name == "$typedefs.scopedname$";
    $endif$

    $if(relation)$Complete$else$Minimal$endif$AliasBody $typedefs.name$_$if(relation)$complete$else$minimal$endif$_body = $typedefs.name$_$if(relation)$complete$else$minimal$endif$_typedefs.body();
    CommonAliasBody $typedefs.name$_$if(relation)$complete$else$minimal$endif$_common_alias_body = $typedefs.name$_$if(relation)$complete$else$minimal$endif$_body.common();
    //AliasMemberFlag related_flags;// Unused. No flags apply

    TypeIdentifier* $typedefs.name$_$if(relation)$complete$else$minimal$endif$_factory_type_identifier = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$typedefs.typedefContentTypeCode.scopedname$", $relation$);
    result &= $typedefs.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $typedefs.name$_$if(relation)$complete$else$minimal$endif$_common_alias_body.related_type()->_d() == $typedefs.name$_$if(relation)$complete$else$minimal$endif$_factory_type_identifier->_d();
     
    $if(relation)$
    CompleteAliasBody $typedefs.name$_$if(relation)$complete$else$minimal$endif$_detail = $typedefs.name$_$if(relation)$complete$else$minimal$endif$_typedefs.body();
    $check_optional_detail_annotations(ctx=ctx, object=typedefs)$
    $endif$
>>

check_alias_related_type(ctx, typedefs, relation) ::= <<
    //=====check_alias_related_type - $if(relation)$complete$else$minimal$endif$ - $typedefs.name$=====
    $if (typedefs.typedefContentTypeCode.isAliasType)$
    //=====typedefs.typedefContentTypeCode.isAliasType=====
    $check_alias_related_type(ctx=ctx, typedefs=typedefs.typedefContentTypeCode, relation=relation)$
    $else$
    {
    TypeIdentifier* $typedefs.name$_$if(relation)$complete$else$minimal$endif$_content_type = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$typedefs.scopedname$", $relation$);
    TypeIdentifier $typedefs.name$_$if(relation)$complete$else$minimal$endif$_related_type = get_$typedefs.name$_object($relation$)->$if(relation)$complete$else$minimal$endif$().alias_type().body().common().related_type();
    result &= $typedefs.name$_$if(relation)$complete$else$minimal$endif$_related_type._d() == $typedefs.name$_$if(relation)$complete$else$minimal$endif$_content_type->_d();
    }
    $endif$
>>

check_struct_type(ctx, struct, relation) ::= <<
    const TypeIdentifier* $struct.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$struct.name$_identifier($relation$);
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_type_identifier->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $struct.name$_$if(relation)$complete$else$minimal$endif$_typeobject = get_$struct.name$_object($relation$);
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $struct.name$_$if(relation)$complete$else$minimal$endif$_object = $struct.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_STRUCTURE;

    $if(relation)$Complete$else$Minimal$endif$StructType $struct.name$_$if(relation)$complete$else$minimal$endif$_struct = $struct.name$_$if(relation)$complete$else$minimal$endif$_object.struct_type();
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_struct.struct_flags().IS_FINAL() == $struct.annotationFinal$;
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_struct.struct_flags().IS_APPENDABLE() == $struct.annotationAppendable$;
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_struct.struct_flags().IS_MUTABLE() == $struct.annotationMutable$;
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_struct.struct_flags().IS_NESTED() == $struct.annotationNested$;
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_struct.struct_flags().IS_AUTOID_HASH() == $struct.annotationAutoidHash$;

    $if(relation)$Complete$else$Minimal$endif$StructHeader $struct.name$_$if(relation)$complete$else$minimal$endif$_header = $struct.name$_$if(relation)$complete$else$minimal$endif$_struct.header();

    TypeIdentifier* $struct.name$_$if(relation)$complete$else$minimal$endif$_inheritance_type_id = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$struct.inheritance.scopedname$",$relation$);
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_header.base_type->_d(); == $struct.name$_$if(relation)$complete$else$minimal$endif$_inheritance_type_id->_d();;

    $if(relation)$
    CompleteTypeDetail $struct.name$_$if(relation)$complete$else$minimal$endif$_detail = $struct.name$_$if(relation)$complete$else$minimal$endif$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=struct)$
    QualifiedTypeName $struct.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name = $struct.name$_$if(relation)$complete$else$minimal$endif$_detail.type_name();
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name == "$struct.scopedname$";
    $else$
    MinimalTypeDetail $struct.name$_$if(relation)$complete$else$minimal$endif$_detail = $struct.name$_$if(relation)$complete$else$minimal$endif$_header.detail();// Empty. Available for future extension
    $endif$

    $if(relation)$Complete$else$Minimal$endif$StructMemberSeq $struct.name$_$if(relation)$complete$else$minimal$endif$_memberseq = $struct.name$_$if(relation)$complete$else$minimal$endif$_struct.member_seq();
>>

check_struct_member_type(ctx, member, relation) ::= <<
    $if(relation)$Complete$else$Minimal$endif$StructMember $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$ = $struct.name$_$if(relation)$complete$else$minimal$endif$_memberseq.at(memberId);
    CommonStructMember $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member = $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$.common();

    MemberId $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_id = $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member.member_id();
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member.member_id() == memberId;

    StructMemberFlag $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_flags = $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member.member_flags();
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_flags.TRY_CONSTRUCT1() == false; // Unsupported
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_flags.TRY_CONSTRUCT2() == false; // Unsupported
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_flags.IS_EXTERNAL() == false; // Unsupported
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_flags.IS_OPTIONAL() == $member.annotationOptional$;
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_flags.IS_MUST_UNDERSTAND() == $member.annotationMustUnderstand$;
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_flags.IS_KEY() == $member.annotationKey$;

    TypeIdentifier $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_type_id = $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member.member_type_id();
    TypeIdentifier* $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_factory_type_id = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$member.name$",$relation$);    
    result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_member_type_id->_d(); == $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member_factory_type_id->_d();

    $if(relation)$
    {    
    CompleteMemberDetail $member.name$_$if(relation)$complete$else$minimal$endif$_detail = $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$.detail();
    $check_optional_detail_annotations(ctx=ctx, object=member)$
    MemberName $member.name$_$if(relation)$complete$else$minimal$endif$_common_struct_member_name = $member.name$_$if(relation)$complete$else$minimal$endif$_detail.name();
    result &= $member.name$_$if(relation)$complete$else$minimal$endif$_common_struct_member_name == "$member.name$";
    }
    $else$
    {
    MinimalMemberDetail $member.name$_$if(relation)$complete$else$minimal$endif$_detail = $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$.detail();
    NameHash $member.name$_$if(relation)$complete$else$minimal$endif$_common_struct_member_name_hash = $member.name$_$if(relation)$complete$else$minimal$endif$_detail.name_hash();
    //result &= $member.name$_$if(relation)$complete$else$minimal$endif$_common_struct_member_name_hash == ?????
    }
    $endif$


    $if (member.typecode.isAliasType)$
        //=====member.typecode.isAliasType=====
        $check_alias_related_type(ctx=ctx, typedefs=member.typecode, relation=relation)$
    $elseif (member.typecode.PrimitiveType)$
        //=====member.typecode.PrimitiveType=====
        TypeIdentifier* $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$member.scopedname$", false);
        result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member.member_type_id()._d() == $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type->_d();
    $elseif (member.typecode.isStringType)$
        //=====member.typecode.isStringType=====
        TypeIdentifier* $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$member.scopedname$", $relation$);
        result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member.member_type_id()._d() == $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type->_d();

        if($member.typecode.maxsize$ <= 255){
            result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type.string_sdefn().bound() == $member.typecode.maxsize$;
        }else{
            result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type.string_ldefn().bound() == $member.typecode.maxsize$;
        }
    $elseif (member.typecode.isWStringType)$
        //=====member.typecode.isWStringType=====
        TypeIdentifier* $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$member.scopedname$", $relation$);
        result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_struct_member.member_type_id()._d() == $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type->_d();

        if($member.typecode.maxsize$ <= 255){
            result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type.string_sdefn().bound() == $member.typecode.maxsize$;
        }else{
            result &= $struct.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_content_type.string_ldefn().bound() == $member.typecode.maxsize$;
        }
    $elseif (member.typecode.isStructType)$
        //=====member.typecode.isStructType=====
        $check_struct_type(ctx=ctx, struct=member, relation=relation)$
    $elseif (member.typecode.isArrayType)$
        //=====member.typecode.isArrayType=====
        $check_array_type(ctx=ctx, array=member, relation=relation)$
    $elseif (member.typecode.isSequenceType)$
        //=====member.typecode.isSequenceType=====
        $check_sequence_type(ctx=ctx, sequence=member, relation=relation)$
    $elseif (member.typecode.isMapType)$
        //=====member.typecode.isSequenceType=====
        $check_map_type(ctx=ctx, map=member, relation=relation)$
    $elseif (member.typecode.isUnionType)$
        //=====member.typecode.isUnionType=====
        $check_union_type(ctx=ctx, union=member, relation=relation)$

    $else$
        //check_struct_member_type UKNOWN TYPE
        std::cout << std::endl << "======================================== Testing struct: $member.typecode$ ========================================" << std::endl;
    memberId = 99;

    $endif$

    memberId++;
>>

check_union_type(ctx, union, relation) ::= <<
    const TypeIdentifier* $union.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$union.name$_identifier($relation$);
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_type_identifier->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $union.name$_$if(relation)$complete$else$minimal$endif$_typeobject = get_$union.name$_object($relation$);
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $union.name$_$if(relation)$complete$else$minimal$endif$_object = $union.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_UNION;

    $if(relation)$Complete$else$Minimal$endif$UnionType $union.name$_$if(relation)$complete$else$minimal$endif$_union = $union.name$_$if(relation)$complete$else$minimal$endif$_object.union_type();

    UnionTypeFlag $union.name$_$if(relation)$complete$else$minimal$endif$_union_flags = $union.name$_$if(relation)$complete$else$minimal$endif$_union.union_flags();
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_union_flags.IS_FINAL() == $union.annotationFinal$;
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_union_flags.IS_APPENDABLE() == $union.annotationAppendable$;
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_union_flags.IS_MUTABLE() == $union.annotationMutable$;
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_union_flags.IS_NESTED() == $union.annotationNested$;
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_union_flags.IS_AUTOID_HASH() == $union.annotationAutoidHash$;

    $if(relation)$Complete$else$Minimal$endif$UnionHeader $union.name$_$if(relation)$complete$else$minimal$endif$_header = $union.name$_$if(relation)$complete$else$minimal$endif$_union.header();
    $if(relation)$
    CompleteTypeDetail $union.name$_$if(relation)$complete$else$minimal$endif$_detail = $union.name$_$if(relation)$complete$else$minimal$endif$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=union)$
    QualifiedTypeName $union.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name = $union.name$_$if(relation)$complete$else$minimal$endif$_detail.type_name();
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name == "$union.scopedname$";
    $else$
    MinimalTypeDetail $union.name$_$if(relation)$complete$else$minimal$endif$_detail = $union.name$_$if(relation)$complete$else$minimal$endif$_header.detail();// Empty. Available for future extension
    $endif$

    $if(relation)$Complete$else$Minimal$endif$DiscriminatorMember $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator = $union.name$_$if(relation)$complete$else$minimal$endif$_union.discriminator();

    CommonDiscriminatorMember $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common = $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator.common();
    UnionDiscriminatorFlag $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common_member_flags = $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common.member_flags();
    //result &= $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common_member_flags.TRY_CONSTRUCT1() == $union.discriminator.annotationTryConstruct1$;
    //result &= $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common_member_flags.TRY_CONSTRUCT2() == $union.discriminator.annotationTryConstruct2$;
    //result &= $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common_member_flags.IS_KEY() == $union.discriminator.annotationKey$;

    TypeIdentifier $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common_type_id = $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common.type_id();
    TypeIdentifier* $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common_factory_type_id = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$union.discriminator.name$",$relation$);    
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common_type_id._d() == $union.name$_$if(relation)$complete$else$minimal$endif$_discriminator_common_factory_type_id ->_d();
    $if(relation)$
    CompleteDiscriminatorMember $union.name$_$if(relation)$complete$else$minimal$endif$_detail = $union.name$_$if(relation)$complete$else$minimal$endif$_union.discriminator();
    $check_optional_detail_annotations(ctx=ctx, object=union)$
    $endif$

    $if(relation)$Complete$else$Minimal$endif$UnionMemberSeq $union.name$_$if(relation)$complete$else$minimal$endif$_memberseq = $union.name$_$if(relation)$complete$else$minimal$endif$_union.member_seq();
>>

check_union_member_type(ctx, member, relation) ::= <<
    $if(relation)$Complete$else$Minimal$endif$UnionMember $union.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_member = $union.name$_$if(relation)$complete$else$minimal$endif$_memberseq.at(memberId);
    CommonUnionMember $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_common = $union.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_member.common();

    MemberId $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_memberid = $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_common.member_id();
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_memberid == memberId;

    UnionMemberFlag $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_memberflags = $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_common.member_flags();
    //result &= $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_memberflags.TRY_CONSTRUCT1() == $member.annotationTryConstruct1$;?????
    //result &= $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_memberflags.TRY_CONSTRUCT2() == $member.annotationTryConstruct2$;?????
    //result &= $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_memberflags.IS_EXTERNAL() == $member.annotationExternal$;?????
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_memberflags.IS_DEFAULT() == $member.annotationDefault$;
    
    TypeIdentifier $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_member_typeid = $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_common.type_id();
    TypeIdentifier* $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_member_factory_type_id = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$member.name$",$relation$);    
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_member_typeid._d() == $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_member_factory_type_id->_d();
    
    UnionCaseLabelSeq $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_member_labelseq = $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_common.label_seq();
    {
    int $union.name$_label_index = 0;
    $member.labels:{ label |
    result &= $union.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_member_labelseq.at($union.name$_label_index) == $label$;
    $union.name$_label_index++;
    }; separator="\n"$
    }
    $if(relation)$
    {    
    CompleteMemberDetail $member.name$_$if(relation)$complete$else$minimal$endif$_detail = $union.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_member.detail();
    $check_optional_detail_annotations(ctx=ctx, object=member)$
    MemberName $member.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_union_member_name = $member.name$_$if(relation)$complete$else$minimal$endif$_detail.name();
    result &= $member.name$_$if(relation)$complete$else$minimal$endif$_common_$member.name$_union_member_name == "$member.name$";
    }
    $else$
    {
    MinimalMemberDetail $member.name$_$if(relation)$complete$else$minimal$endif$_detail = $union.name$_$if(relation)$complete$else$minimal$endif$_$member.name$_member.detail();
    NameHash $member.name$_$if(relation)$complete$else$minimal$endif$_commonunion_member_name_hash = $member.name$_$if(relation)$complete$else$minimal$endif$_detail.name_hash();
    //result &= $member.name$_$if(relation)$complete$else$minimal$endif$_common_union_member_name_hash == ?????
    }
    $endif$

    memberId++;
>>

check_enum_type(ctx, enum, relation) ::= <<
    //=====check_enum_type - $if(relation)$complete$else$minimal$endif$ - $enum.name$=====
    const TypeIdentifier* $enum.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$enum.name$_identifier($relation$);
    result &= $enum.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $enum.name$_$if(relation)$complete$else$minimal$endif$_type_identifier->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $enum.name$_$if(relation)$complete$else$minimal$endif$_typeobject = get_$enum.name$_object($relation$);
    result &= $enum.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $enum.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $enum.name$_$if(relation)$complete$else$minimal$endif$_object = $enum.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $enum.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_ENUM;

    $if(relation)$Complete$else$Minimal$endif$EnumeratedType $enum.name$_$if(relation)$complete$else$minimal$endif$_enum = $enum.name$_$if(relation)$complete$else$minimal$endif$_object.enumerated_type();
    //EnumTypeFlag $enum.name$_$if(relation)$complete$else$minimal$endif$_enum_flags = $enum.name$_$if(relation)$complete$else$minimal$endif$_enum.enum_flags();// Unused. No flags apply

    $if(relation)$Complete$else$Minimal$endif$EnumeratedHeader $enum.name$_$if(relation)$complete$else$minimal$endif$_header = $enum.name$_$if(relation)$complete$else$minimal$endif$_enum.header();

    CommonEnumeratedHeader $enum.name$_$if(relation)$complete$else$minimal$endif$_commonheader = $enum.name$_$if(relation)$complete$else$minimal$endif$_header.common();
    BitBound $enum.name$_$if(relation)$complete$else$minimal$endif$_commonheader_bit_bound = $enum.name$_$if(relation)$complete$else$minimal$endif$_commonheader.bit_bound();
    //result &= $enum.name$_$if(relation)$complete$else$minimal$endif$_commonheader_bit_bound == ?????;

    $if(relation)$
    CompleteTypeDetail $enum.name$_$if(relation)$complete$else$minimal$endif$_detail = $enum.name$_$if(relation)$complete$else$minimal$endif$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=enum)$
    QualifiedTypeName $enum.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name = $enum.name$_$if(relation)$complete$else$minimal$endif$_detail.type_name();
    result &= $enum.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name == "$enum.scopedname$";
    $endif$

    $if(relation)$Complete$else$Minimal$endif$EnumeratedLiteralSeq $enum.name$_$if(relation)$complete$else$minimal$endif$_literalseq = $enum.name$_$if(relation)$complete$else$minimal$endif$_enum.literal_seq();
>>

check_enum_literal_type(ctx, literal, relation) ::= <<
    $if(relation)$Complete$else$Minimal$endif$EnumeratedLiteral $enum.name$_$if(relation)$complete$else$minimal$endif$_$literal.name$ = $enum.name$_$if(relation)$complete$else$minimal$endif$_literalseq.at(literalId);
    CommonEnumeratedLiteral $enum.name$_$if(relation)$complete$else$minimal$endif$_common_$literal.name$_enum_literal = $enum.name$_$if(relation)$complete$else$minimal$endif$_$literal.name$.common();
    
    long $enum.name$_$if(relation)$complete$else$minimal$endif$_common_$literal.name$_enum_literal_value = $enum.name$_$if(relation)$complete$else$minimal$endif$_common_$literal.name$_enum_literal.value();
    result &= $enum.name$_$if(relation)$complete$else$minimal$endif$_common_$literal.name$_enum_literal.value() == literalId;
    
    EnumeratedLiteralFlag $enum.name$_$if(relation)$complete$else$minimal$endif$_common_$literal.name$_enum_flags = $enum.name$_$if(relation)$complete$else$minimal$endif$_common_$literal.name$_enum_literal.flags();
    result &= $enum.name$_$if(relation)$complete$else$minimal$endif$_common_$literal.name$_enum_flags.IS_DEFAULT() == $literal.annotationDefault$;

    $if(relation)$
    {
    CompleteMemberDetail $literal.name$_$if(relation)$complete$else$minimal$endif$_detail = $enum.name$_$if(relation)$complete$else$minimal$endif$_$literal.name$.detail();
    $check_optional_detail_annotations(ctx=ctx, object=literal)$
    MemberName $literal.name$_$if(relation)$complete$else$minimal$endif$_detail_member_name = $literal.name$_$if(relation)$complete$else$minimal$endif$_detail.name();
    result &= $literal.name$_$if(relation)$complete$else$minimal$endif$_detail_member_name == "$literal.name$";
    }
    $endif$

    literalId++;
>>

check_bitmask_type(ctx, bitmask, relation) ::= <<
    //=====check_bitmask_type - $if(relation)$complete$else$minimal$endif$ - $bitmask.name$=====
    const TypeIdentifier* $bitmask.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$bitmask.name$_identifier($relation$);
    result &= $bitmask.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $bitmask.name$_$if(relation)$complete$else$minimal$endif$_type_identifier->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $bitmask.name$_$if(relation)$complete$else$minimal$endif$_typeobject = get_$bitmask.name$_object($relation$);
    result &= $bitmask.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $bitmask.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $bitmask.name$_$if(relation)$complete$else$minimal$endif$_object = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $bitmask.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_BITMASK;

    $if(relation)$Complete$else$Minimal$endif$BitmaskType $bitmask.name$_$if(relation)$complete$else$minimal$endif$_bitmask = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_object.bitmask_type();
    //BitmaskTypeFlag $bitmask.name$_$if(relation)$complete$else$minimal$endif$_bitmask_flags = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_bitmask.bitmask_flags();// Unused. No flags apply

    $if(relation)$Complete$else$Minimal$endif$BitmaskHeader $bitmask.name$_$if(relation)$complete$else$minimal$endif$_header = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_bitmask.header();
    CommonBitmaskHeader $bitmask.name$_$if(relation)$complete$else$minimal$endif$_commonheader = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_header.common();

    BitBound $bitmask.name$_$if(relation)$complete$else$minimal$endif$_commonheader_bit_bound = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_commonheader.bit_bound();
    //result &= $bitmask.name$_$if(relation)$complete$else$minimal$endif$_commonheader_bit_bound == ?????;


    $if(relation)$Complete$else$Minimal$endif$BitflagSeq $bitmask.name$_$if(relation)$complete$else$minimal$endif$_flagseq = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_bitmask.flag_seq();
>>

check_bitmask_flag_type(ctx, flag, relation) ::= <<
    $if(relation)$Complete$else$Minimal$endif$Bitflag $bitmask.name$_$if(relation)$complete$else$minimal$endif$_$flag.name$ = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_flagseq.at(flagId);
    CommonBitflag $bitmask.name$_$if(relation)$complete$else$minimal$endif$_common_$flag.name$_bitmask_flag = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_$flag.name$.common();
    
    unsigned short $bitmask.name$_$if(relation)$complete$else$minimal$endif$_common_$flag.name$_bitmask_flag_position = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_common_$flag.name$_bitmask_flag.position();
    result &= $bitmask.name$_$if(relation)$complete$else$minimal$endif$_common_$flag.name$_bitmask_flag_position == flagId;

    //BitflagFlag flags;// Unused. No flags apply

    $if(relation)$
    {
    CompleteMemberDetail $flag.name$_$if(relation)$complete$else$minimal$endif$_detail = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_$flag.name$.detail();
    $check_optional_detail_annotations(ctx=ctx, object=flag)$
    MemberName $flag.name$_$if(relation)$complete$else$minimal$endif$_detail_flag_name = $flag.name$_$if(relation)$complete$else$minimal$endif$_detail.name();
    result &= $flag.name$_$if(relation)$complete$else$minimal$endif$_detail_flag_name == "$flag.name$";
    }
    $else$
    {
    MinimalMemberDetail $flag.name$_$if(relation)$complete$else$minimal$endif$_detail = $bitmask.name$_$if(relation)$complete$else$minimal$endif$_$flag.name$.detail();
    NameHash $flag.name$_$if(relation)$complete$else$minimal$endif$_common_bitmask_flag_name_hash = $flag.name$_$if(relation)$complete$else$minimal$endif$_detail.name_hash();
    //result &= $flag.name$_$if(relation)$complete$else$minimal$endif$_common_bitmask_flag_name_hash == ?????
    }
    $endif$

    flagId++;
>>

check_bitset_type(ctx, bitset, relation) ::= <<
    const TypeIdentifier* $bitset.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$bitset.name$_identifier($relation$);
    result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_type_identifier->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $bitset.name$_$if(relation)$complete$else$minimal$endif$_typeobject = get_$bitset.name$_object($relation$);
    result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $bitset.name$_$if(relation)$complete$else$minimal$endif$_object = $bitset.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_BITSET;

    $if(relation)$Complete$else$Minimal$endif$BitsetType $bitset.name$_$if(relation)$complete$else$minimal$endif$_bitset = $bitset.name$_$if(relation)$complete$else$minimal$endif$_object.bitset_type();
    //BitsetTypeFlag bitset_flags;// Unused. No flags apply

    $if(relation)$Complete$else$Minimal$endif$BitsetHeader $bitset.name$_$if(relation)$complete$else$minimal$endif$_header = $bitset.name$_$if(relation)$complete$else$minimal$endif$_bitset.header();

    $if(relation)$
    CompleteTypeDetail $bitset.name$_$if(relation)$complete$else$minimal$endif$_detail = $bitset.name$_$if(relation)$complete$else$minimal$endif$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=bitset)$
    QualifiedTypeName $bitset.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name = $bitset.name$_$if(relation)$complete$else$minimal$endif$_detail.type_name();
    result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name == "$bitset.scopedname$";
    $else$
    MinimalTypeDetail $bitset.name$_$if(relation)$complete$else$minimal$endif$_detail = $bitset.name$_$if(relation)$complete$else$minimal$endif$_header.detail();// Empty. Available for future extension
    $endif$

    $if(relation)$Complete$else$Minimal$endif$BitfieldSeq $bitset.name$_$if(relation)$complete$else$minimal$endif$_bitfieldseq = $bitset.name$_$if(relation)$complete$else$minimal$endif$_bitset.field_seq();
>>

check_bitfield_type(ctx, bitfield, relation) ::= <<
    $if(relation)$Complete$else$Minimal$endif$Bitbitfield $bitset.name$_$if(relation)$complete$else$minimal$endif$_$bitfield.name$ = $bitset.name$_$if(relation)$complete$else$minimal$endif$_bitfieldseq.at(bitfieldId);
    CommonBitfield $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield = $bitset.name$_$if(relation)$complete$else$minimal$endif$_$bitfield.name$.common();
    
    unsigned short $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield_position = $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield.position();
    result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield_position == bitfieldId;
    //BitsetMemberFlag flags;// Unused. No flags apply
    octet $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield_bitcount = $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield.bitcount();
    result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield_bitcount == $bitfield.spec.bitSize$;
    TypeKind $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield_holder_type = $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield.holder_type(); // Must be primitive integer type
    result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield_holder_type == $bitfield.spec.typecode.typeIdentifier$;

    //Bitbitfieldbitfield bitfields;// Unused. No bitfields apply

    $if(relation)$
    {
    CompleteMemberDetail $bitfield.name$_$if(relation)$complete$else$minimal$endif$_detail = $bitset.name$_$if(relation)$complete$else$minimal$endif$_$bitfield.name$.detail();
    MemberName $bitfield.name$_$if(relation)$complete$else$minimal$endif$_detail_bitfield_name = $bitfield.name$_$if(relation)$complete$else$minimal$endif$_detail.name();
    result &= $bitfield.name$_$if(relation)$complete$else$minimal$endif$_detail_bitfield_name == "$bitfield.name$";
    }
    $else$
    {
    NameHash $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield_name_hash = $bitset.name$_$if(relation)$complete$else$minimal$endif$_$bitfield.name$.name_hash();
    //result &= $bitset.name$_$if(relation)$complete$else$minimal$endif$_common_$bitfield.name$_bitset_bitfield_name_hash == ?????
    }
    $endif$

    bitfieldId++;
>>

check_annotation_type(ctx, annotation, relation) ::= <<
    const TypeIdentifier* $annotation.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$annotation.name$_identifier($relation$);
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_type_identifier->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $annotation.name$_$if(relation)$complete$else$minimal$endif$_typeobject = get_$annotation.name$_object($relation$);
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $annotation.name$_$if(relation)$complete$else$minimal$endif$_object = $annotation.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_ANNOTATION;

    $if(relation)$Complete$else$Minimal$endif$AnnotationType $annotation.name$_$if(relation)$complete$else$minimal$endif$_annotation = $annotation.name$_$if(relation)$complete$else$minimal$endif$_object.annotation_type();
    //AnnotationTypeFlag annotation_flag;// Unused. No flags apply

    $if(relation)$Complete$else$Minimal$endif$AnnotationHeader $annotation.name$_$if(relation)$complete$else$minimal$endif$_header = $annotation.name$_$if(relation)$complete$else$minimal$endif$_annotation.header();
    $if(relation)$
    QualifiedTypeName $annotation.name$_$if(relation)$complete$else$minimal$endif$_name = $annotation.name$_$if(relation)$complete$else$minimal$endif$_header.annotation_name();
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_name == "$annotation.name$";
    $endif$

    $if(relation)$Complete$else$Minimal$endif$AnnotationParameterSeq $annotation.name$_$if(relation)$complete$else$minimal$endif$_memberseq = $annotation.name$_$if(relation)$complete$else$minimal$endif$_annotation.member_seq();
>>

check_annotation_member_type(ctx, parameter, relation) ::= <<
    $if(relation)$Complete$else$Minimal$endif$AnnotationParameter $parameter.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$ = $annotation.name$_$if(relation)$complete$else$minimal$endif$_memberseq.at(memberId);
    CommonAnnotationParameter $annotation.name$_$if(relation)$complete$else$minimal$endif$_common_$parameter.name$_parameter_member = $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$.common();
    //AnnotationParameterFlag member_flags;// Unused. No flags apply

    TypeIdentifier $annotation.name$_$if(relation)$complete$else$minimal$endif$_common_$parameter.name$_parameter_member_typeid = $annotation.name$_$if(relation)$complete$else$minimal$endif$_common_$parameter.name$_parameter_member.member_type_id();
    const TypeIdentifier* $annotation.name$_$if(relation)$complete$else$minimal$endif$_common_$parameter.name$_factory_typeid = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$parameter.typecode.cppTypename$", $relation$);
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_common_$parameter.name$_parameter_member_typeid._d() == $annotation.name$_$if(relation)$complete$else$minimal$endif$_common_$parameter.name$_factory_typeid->_d();

    $if(relation)$
    MemberName $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_name = $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$.name();
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_name == "$parameter.name$";
    $else$
    NameHash $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_namehash = $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$.name_hash();
    //result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_namehash == "$parameter.name$";?????
    $endif$

    AnnotationParameterValue $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value = $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$.default_value();
    $if(parameter.typecode.primitiveType)$
    $if(parameter.typecode.isBooleanType)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.boolean_value() == ($parameter.value$;
    $elseif(parameter.typecode.isByteType)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.byte_value() == $parameter.value$;
    $elseif(parameter.typecode.isInt8Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.int8_value() == $parameter.value$;
    $elseif(parameter.typecode.isUint8Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.uint8_value() == $parameter.value$;
    $elseif(parameter.typecode.isInt16Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.int16_value() == $parameter.value$;
    $elseif(parameter.typecode.isUint16Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.uint16_value() == $parameter.value$;
    $elseif(parameter.typecode.isInt32Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.int32_value() == $parameter.value$;
    $elseif(parameter.typecode.isUint32Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.uint32_value() == $parameter.value$;
    $elseif(parameter.typecode.isInt64Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.int64_value() == $parameter.value$;
    $elseif(parameter.typecode.isUint64Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.uint64_value() == $parameter.value$;
    $elseif(parameter.typecode.isFloat32Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.float32_value() == $parameter.value$;
    $elseif(parameter.typecode.isFloat64Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.float64_value() == $parameter.value$;
    $elseif(parameter.typecode.isFloat128Type)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.float128_value() == $parameter.value$;
    $elseif(parameter.typecode.isCharType)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.char_value() == $parameter.value$;
    $elseif(parameter.typecode.isWCharType)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.wchar_value() == $parameter.value$;
    $endif$
    $elseif(parameter.typecode.isEnumType)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.enumerated_value() == $parameter.value$;
    $elseif(parameter.typecode.isStringType)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.string8_value() == "$parameter.value$";
    $elseif(parameter.typecode.isWStringType)$
    result &= $annotation.name$_$if(relation)$complete$else$minimal$endif$_$parameter.name$_default_value.string16_value() == "$parameter.value$";
    $endif$
    memberId++;
>>

check_const_type(ctx, const, relation) ::= <<
    const TypeIdentifier* $const.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$const.name$_identifier($relation$);
    TypeIdentifier* $const.name$_$if(relation)$complete$else$minimal$endif$_factory_type_identifier = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$const.name$", $relation$);
    result &= $const.name$_$if(relation)$complete$else$minimal$endif$_type_identifier->_d() == $const.name$_$if(relation)$complete$else$minimal$endif$_factory_type_identifier->_d():
>>

check_array_type(ctx, array, relation) ::= <<
    const TypeIdentifier* $array.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$array.name$_identifier($relation$);
    result &= $array.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $array.name$_$if(relation)$complete$else$minimal$endif$_type_identifier->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $array.name$_$if(relation)$complete$else$minimal$endif$_typeobject = $get_type_object(ctx=ctx, type=array, relation=relation)$
    result &= $array.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $array.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $array.name$_$if(relation)$complete$else$minimal$endif$_object = $array.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $array.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_ARRAY;

    $if(relation)$Complete$else$Minimal$endif$ArrayType $array.name$_$if(relation)$complete$else$minimal$endif$_array = $array.name$_$if(relation)$complete$else$minimal$endif$_object.array_type();
    //CollectionTypeFlag collection_flag;// Unused. No flags apply
    
    $if(relation)$Complete$else$Minimal$endif$ArrayHeader $array.name$_$if(relation)$complete$else$minimal$endif$_header = $array.name$_$if(relation)$complete$else$minimal$endif$_array.header();
    $if(relation)$
    CompleteTypeDetail $array.name$_$if(relation)$complete$else$minimal$endif$_detail = $array.name$_$if(relation)$complete$else$minimal$endif$_header.detail();
    $check_optional_detail_annotations(ctx=ctx, object=array)$
    QualifiedTypeName $array.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name = $array.name$_$if(relation)$complete$else$minimal$endif$_detail.type_name();
    result &= $array.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name == "$array.scopedname$";
    $endif$

    CommonArrayHeader $array.name$_$if(relation)$complete$else$minimal$endif$_header_common = $array.name$_$if(relation)$complete$else$minimal$endif$_header.common();
    LBoundSeq $array.name$_$if(relation)$complete$else$minimal$endif$_header_common_bound_seq = $array.name$_$if(relation)$complete$else$minimal$endif$_header_common.bound_seq();

    int dimension_bound_index = 0;
    $array.typecode.dimensions:{ dimension_bound |
    result &= $array.name$_$if(relation)$complete$else$minimal$endif$_header_common_bound_seq.at(dimension_bound_index) == $dimension_bound$;
    dimension_bound_index++;
    }; separator="\n"$

    $if(relation)$Complete$else$Minimal$endif$CollectionElement $array.name$_$if(relation)$complete$else$minimal$endif$_collection_element = $array.name$_$if(relation)$complete$else$minimal$endif$_array.element();
    CommonCollectionElement $array.name$_$if(relation)$complete$else$minimal$endif$_common_element = $array.name$_$if(relation)$complete$else$minimal$endif$_collection_element.common();

    CollectionElementFlag $array.name$_$if(relation)$complete$else$minimal$endif$_common_element_flags = $array.name$_$if(relation)$complete$else$minimal$endif$_common_element.element_flags();
    //result &= $array.name$_$if(relation)$complete$else$minimal$endif$_common_element_flags.TRY_CONSTRUCT1() == $array.annotationTryConstruct1$;?????
    //result &= $array.name$_$if(relation)$complete$else$minimal$endif$_common_element_flags.TRY_CONSTRUCT2() == $array.annotationTryConstruct2$;?????
    //result &= $array.name$_$if(relation)$complete$else$minimal$endif$_common_element_flags.IS_EXTERNAL() == $array.annotationExternal$;?????

    TypeIdentifier* $array.name$_$if(relation)$complete$else$minimal$endif$_common_element_id = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$array.name$", true);
    result &= $array.name$_$if(relation)$complete$else$minimal$endif$_common_element.type()->_d() == $array.name$_$if(relation)$complete$else$minimal$endif$_common_element_id->_d();

    $if(relation)$
{
    CompleteElementDetail $array.name$_$if(relation)$complete$else$minimal$endif$_detail = $array.name$_$if(relation)$complete$else$minimal$endif$_collection_element.detail();
    $check_optional_detail_annotations(ctx=ctx, object=array)$
}
    $endif$

    int $array.name$_$if(relation)$complete$else$minimal$endif$_totalsize = $member.typecode.dimensions:{ dim | $dim$}; separator=" + "$;
    
    if($array.name$_$if(relation)$complete$else$minimal$endif$_totalsize <= 100){
        SBoundSeq $array.name$_$if(relation)$complete$else$minimal$endif$_s_bound_seq;
        $member.typecode.dimensions:{ dim | $array.name$_$if(relation)$complete$else$minimal$endif$_s_bound_seq.push_back($dim$);}; separator="\n"$
        result &= $array.name$_$if(relation)$complete$else$minimal$endif$_type_identifier.array_sdefn().array_bound_seq() == $array.name$_$if(relation)$complete$else$minimal$endif$_s_bound_seq;
    }else{
        LBoundSeq $array.name$_$if(relation)$complete$else$minimal$endif$_l_bound_seq;
        $member.typecode.dimensions:{ dim | $array.name$_$if(relation)$complete$else$minimal$endif$_l_bound_seq.push_back($dim$);}; separator="\n"$
        result &= $array.name$_$if(relation)$complete$else$minimal$endif$_type_identifier.array_ldefn().array_bound_seq() == $array.name$_$if(relation)$complete$else$minimal$endif$_l_bound_seq;       
    }
>>

check_sequence_type(ctx, sequence, relation) ::= <<
    const TypeIdentifier $sequence.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$sequence.name$_identifier($relation$);
    result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_type_identifier._d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $sequence.name$_$if(relation)$complete$else$minimal$endif$_typeobject = $get_type_object(ctx=ctx, type=sequence, relation=relation)$
    result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $sequence.name$_$if(relation)$complete$else$minimal$endif$_object = $sequence.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_SEQUENCE;


    $if(relation)$Complete$else$Minimal$endif$SequenceType $sequence.name$_$if(relation)$complete$else$minimal$endif$_sequence = $sequence.name$_$if(relation)$complete$else$minimal$endif$_object.sequence_type();
    //CollectionTypeFlag collection_flag;// Unused. No flags apply
    
    $if(relation)$Complete$else$Minimal$endif$CollectionHeader $sequence.name$_$if(relation)$complete$else$minimal$endif$_header = $sequence.name$_$if(relation)$complete$else$minimal$endif$_sequence.header();// Empty. Available for future extension
        
    CommonCollectionHeader $sequence.name$_$if(relation)$complete$else$minimal$endif$_commonheader = $sequence.name$_$if(relation)$complete$else$minimal$endif$_header.common();
    result &= $array.name$_$if(relation)$complete$else$minimal$endif$_header_common.bound() == $array.typecode.maxsize$;

    $if(relation)$
    CompleteTypeDetail $sequence.name$_$if(relation)$complete$else$minimal$endif$_detail = $sequence.name$_$if(relation)$complete$else$minimal$endif$_header.detail();// not present for anonymous
    $check_optional_detail_annotations(ctx=ctx, object=sequence)$
    QualifiedTypeName $sequence.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name = $sequence.name$_$if(relation)$complete$else$minimal$endif$_detail.type_name();
    result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name == "$sequence.scopedname$";
    $endif$

    $if(relation)$Complete$else$Minimal$endif$CollectionElement $sequence.name$_$if(relation)$complete$else$minimal$endif$_collection_element = $sequence.name$_$if(relation)$complete$else$minimal$endif$_sequence.element();
    CommonCollectionElement $sequence.name$_$if(relation)$complete$else$minimal$endif$_common_element = $sequence.name$_$if(relation)$complete$else$minimal$endif$_collection_element.common();

    CollectionElementFlag $sequence.name$_$if(relation)$complete$else$minimal$endif$_common_element_flags = $sequence.name$_$if(relation)$complete$else$minimal$endif$_common_element.element_flags();
    //result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_common_element_flags.TRY_CONSTRUCT1() == $sequence.annotationTryConstruct1$;?????
    //result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_common_element_flags.TRY_CONSTRUCT2() == $sequence.annotationTryConstruct2$;?????
    //result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_common_element_flags.IS_EXTERNAL() == $sequence.annotationExternal$;?????

    TypeIdentifier* $sequence.name$_$if(relation)$complete$else$minimal$endif$_common_element_id = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$sequence.name$", true);
    result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_common_element.type()->_d() == $sequence.name$_$if(relation)$complete$else$minimal$endif$_common_element_id->_d();
       
    $if(relation)$
    {
    CompleteElementDetail $sequence.name$_$if(relation)$complete$else$minimal$endif$_detail = $sequence.name$_$if(relation)$complete$else$minimal$endif$_collection_element.detail();
    $check_optional_detail_annotations(ctx=ctx, object=sequence)$
    }
    $endif$

    if($sequence.typecode.maxsize$ <= 100){
        result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_type_identifier.seq_sdefn().bound() == $sequence.typecode.maxsize$;
    }else{
        result &= $sequence.name$_$if(relation)$complete$else$minimal$endif$_type_identifier.seq_ldefn().bound() == $sequence.typecode.maxsize$;
    }
>>

check_map_type(ctx, map, relation) ::= <<
    const TypeIdentifier $map.name$_$if(relation)$complete$else$minimal$endif$_type_identifier = get_$map.name$_identifier($relation$);
    result &= $map.name$_$if(relation)$complete$else$minimal$endif$_type_identifier != nullptr;
    result &= $map.name$_$if(relation)$complete$else$minimal$endif$_type_identifier._d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    const TypeObject* $map.name$_$if(relation)$complete$else$minimal$endif$_typeobject = $get_type_object(ctx=ctx, type=map, relation=relation)$
    result &= $map.name$_$if(relation)$complete$else$minimal$endif$_typeobject != nullptr;
    result &= $map.name$_$if(relation)$complete$else$minimal$endif$_typeobject->_d() == EK_$if(relation)$COMPLETE$else$MINIMAL$endif$;

    $if(relation)$Complete$else$Minimal$endif$TypeObject $map.name$_$if(relation)$complete$else$minimal$endif$_object = $map.name$_$if(relation)$complete$else$minimal$endif$_typeobject->$if(relation)$complete$else$minimal$endif$();
    result &= $map.name$_$if(relation)$complete$else$minimal$endif$_object._d() == TK_MAP;

    $if(relation)$Complete$else$Minimal$endif$MapType $map.name$_$if(relation)$complete$else$minimal$endif$_map = $map.name$_$if(relation)$complete$else$minimal$endif$_object.map_type();
    //CollectionTypeFlag collection_flag;// Unused. No flags apply
    
    $if(relation)$Complete$else$Minimal$endif$CollectionHeader $map.name$_$if(relation)$complete$else$minimal$endif$_header = $map.name$_$if(relation)$complete$else$minimal$endif$_map.header();// Empty. Available for future extension

    CommonCollectionHeader $map.name$_$if(relation)$complete$else$minimal$endif$_commonheader = $map.name$_$if(relation)$complete$else$minimal$endif$_header.common();
    result &= $map.name$_$if(relation)$complete$else$minimal$endif$_commonheader.bound() == $map.typecode.maxsize$;

    $if(relation)$
    CompleteTypeDetail $map.name$_$if(relation)$complete$else$minimal$endif$_detail = $map.name$_$if(relation)$complete$else$minimal$endif$_header.detail();// not present for anonymous
    $check_optional_detail_annotations(ctx=ctx, object=map)$
    QualifiedTypeName $map.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name = $map.name$_$if(relation)$complete$else$minimal$endif$_detail.type_name();
    result &= $map.name$_$if(relation)$complete$else$minimal$endif$_detail_type_name == "$map.scopedname$";
    $endif$

    $if(relation)$Complete$else$Minimal$endif$CollectionElement $map.name$_$if(relation)$complete$else$minimal$endif$_collection_key_element = $map.name$_$if(relation)$complete$else$minimal$endif$_map.key();
    CommonCollectionElement $map.name$_$if(relation)$complete$else$minimal$endif$_key_common_element = $map.name$_$if(relation)$complete$else$minimal$endif$_collection_key_element.common();
    CollectionElementFlag $map.name$_$if(relation)$complete$else$minimal$endif$_key_common_element_flags = $map.name$_$if(relation)$complete$else$minimal$endif$_key_common_element.element_flags();
    //result &= $map.name$_$if(relation)$complete$else$minimal$endif$_key_common_element_flags.TRY_CONSTRUCT1() == $map.annotationTryConstruct1$;?????
    //result &= $map.name$_$if(relation)$complete$else$minimal$endif$_key_common_element_flags.TRY_CONSTRUCT2() == $map.annotationTryConstruct2$;?????
    //result &= $map.name$_$if(relation)$complete$else$minimal$endif$_key_common_element_flags.IS_EXTERNAL() == $map.annotationExternal$;?????

    TypeIdentifier* $map.name$_$if(relation)$complete$else$minimal$endif$_key_common_element_id = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$map.name$", true);
    result &= $map.name$_$if(relation)$complete$else$minimal$endif$_key_common_element.type()->_d() == $map.name$_$if(relation)$complete$else$minimal$endif$_key_common_element_id->_d();
      
    $if(relation)$
    {
    CompleteElementDetail $map.name$_$if(relation)$complete$else$minimal$endif$_detail = $map.name$_$if(relation)$complete$else$minimal$endif$_collection_key_element.detail();
    $check_optional_detail_annotations(ctx=ctx, object=map)$
    }
    $endif$

    $if(relation)$Complete$else$Minimal$endif$CollectionElement $map.name$_$if(relation)$complete$else$minimal$endif$_element_collection_element = $map.name$_$if(relation)$complete$else$minimal$endif$_map.element();
    CommonCollectionElement $map.name$_$if(relation)$complete$else$minimal$endif$_element_common_element = $map.name$_$if(relation)$complete$else$minimal$endif$_element_collection_element.common();
    CollectionElementFlag $map.name$_$if(relation)$complete$else$minimal$endif$_element_common_element_flags = $map.name$_$if(relation)$complete$else$minimal$endif$_element_common_element.element_flags();
    //result &= $map.name$_$if(relation)$complete$else$minimal$endif$_element_common_element_flags.TRY_CONSTRUCT1() == $map.annotationTryConstruct1$;?????
    //result &= $map.name$_$if(relation)$complete$else$minimal$endif$_element_common_element_flags.TRY_CONSTRUCT2() == $map.annotationTryConstruct2$;?????
    //result &= $map.name$_$if(relation)$complete$else$minimal$endif$_element_common_element_flags.IS_EXTERNAL() == $map.annotationExternal$;?????

    TypeIdentifier* $map.name$_$if(relation)$complete$else$minimal$endif$_element_common_element_id = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$map.name$", true);
    result &= $map.name$_$if(relation)$complete$else$minimal$endif$_element_common_element.type()->_d() == $map.name$_$if(relation)$complete$else$minimal$endif$_element_common_element_id->_d();
    $if(relation)$
    {
    CompleteElementDetail $map.name$_$if(relation)$complete$else$minimal$endif$_detail = $map.name$_$if(relation)$complete$else$minimal$endif$_element_collection_element.detail();
    $check_optional_detail_annotations(ctx=ctx, object=map)$
    }
    $endif$

    if($map.typecode.maxsize$ <= 100){
        result &= $map.name$_$if(relation)$complete$else$minimal$endif$_type_identifier.seq_sdefn().bound() == $map.typecode.maxsize$;
    }else{
        result &= $map.name$_$if(relation)$complete$else$minimal$endif$_type_identifier.seq_ldefn().bound() == $map.typecode.maxsize$;
    }
>>




test_typedef(ctx, parent, typedefs) ::= <<
functions_to_run.emplace_back([]() -> bool
{
    std::cout << std::endl << "======================================== Testing typedef: $typedefs.name$ ========================================" << std::endl;
    bool result = true;

    //Minimal
    $check_alias_type(ctx=ctx, typedefs=typedefs, relation=false)$
    $check_alias_related_type(ctx=ctx, typedefs=typedefs, relation=false)$

    //Complete
    $check_alias_type(ctx=ctx, typedefs=typedefs, relation=true)$
    $check_alias_related_type(ctx=ctx, typedefs=typedefs, relation=true)$


    if(result){
        std::cout << std::endl << "======OK====== Test $typedefs.name$" << std::endl;
    }else{
        std::cout << std::endl << "=====FAIL===== Test $typedefs.name$" << std::endl;
    }
    return result;
});
>>

test_structure(ctx, parent, struct) ::= <<
functions_to_run.emplace_back([]() -> bool
{
    std::cout << std::endl << "======================================== Testing struct: $struct.name$ ========================================" << std::endl;
    MemberId memberId;
    bool result = true;

    //Minimal
    $check_struct_type(ctx=ctx, struct=struct, relation=false)$ 
    memberId = 0;
    $struct.allMembers:{ member | $check_struct_member_type(ctx=ctx, member=member, relation=false)$ }; separator="\n"$
    result &= $struct.name$_minimal_memberseq.size() == memberId; 

    //Complete
    $check_struct_type(ctx=ctx, struct=struct, relation=true)$ 
    memberId = 0;
    $struct.allMembers:{ member | $check_struct_member_type(ctx=ctx, member=member, relation=true)$ }; separator="\n"$
    result &= $struct.name$_complete_memberseq.size() == memberId; 

    if(result){
        std::cout << std::endl << "======OK====== Test $struct.name$" << std::endl;
    }else{
        std::cout << std::endl << "=====FAIL===== Test $struct.name$" << std::endl;
    }
    return result;
});
>>

test_union(ctx, parent, union) ::= <<
functions_to_run.emplace_back([]() -> bool
{
    std::cout << std::endl << "======================================== Testing union: $union.name$ ========================================" << std::endl;
    MemberId memberId;
    bool result = true;

    //Minimal
    $check_union_type(ctx=ctx, union=union, relation=false)$ 
    memberId = 0;
    $union.members:{ member | $check_union_member_type(ctx=ctx, member=member, relation=false)$ }; separator="\n"$
    result &= $union.name$_minimal_memberseq.size() == memberId; 

    //Complete
    $check_union_type(ctx=ctx, union=union, relation=true)$ 
    memberId = 0;
    $union.members:{ member | $check_union_member_type(ctx=ctx, member=member, relation=true)$ }; separator="\n"$
    result &= $union.name$_complete_memberseq.size() == memberId; 

    if(result){
        std::cout << std::endl << "======OK====== Test $union.name$" << std::endl;
    }else{
        std::cout << std::endl << "=====FAIL===== Test $union.name$" << std::endl;
    }
    return result;
});
>>

test_enum(ctx, parent, enum) ::= <<
functions_to_run.emplace_back([]() -> bool
{
    std::cout << std::endl << "======================================== Testing enum: $enum.name$ ========================================" << std::endl;
    int literalId;
    bool result = true;

    //Minimal
    $check_enum_type(ctx=ctx, enum=enum, relation=false)$ 
    literalId = 0;
    $enum.members:{ literal | $check_enum_literal_type(ctx=ctx, literal=literal, relation=false)$ }; separator="\n"$
    result &= $enum.name$_minimal_literalseq.size() == literalId; 

    //Complete
    $check_enum_type(ctx=ctx, enum=enum, relation=true)$ 
    literalId = 0;
    $enum.members:{ literal | $check_enum_literal_type(ctx=ctx, literal=literal, relation=true)$ }; separator="\n"$
    result &= $enum.name$_complete_literalseq.size() == literalId; 

    if(result){
        std::cout << std::endl << "======OK====== Test $enum.name$" << std::endl;
    }else{
        std::cout << std::endl << "=====FAIL===== Test $enum.name$" << std::endl;
    }
    return result;
});
>>

test_bitmask(ctx, parent, bitmask) ::= <<
functions_to_run.emplace_back([]() -> bool
{
    std::cout << std::endl << "======================================== Testing bitmask: $bitmask.name$ ========================================" << std::endl;
    unsigned short flagId;
    bool result = true;

    //Minimal
    $check_bitmask_type(ctx=ctx, bitmask=bitmask, relation=false)$ 
    flagId = 0;
    $bitmask.members:{ flag | $check_bitmask_flag_type(ctx=ctx, flag=flag, relation=false)$ }; separator="\n"$
    result &= $bitmask.name$_minimal_flagseq.size() == flagId; 

    //Complete
    $check_bitmask_type(ctx=ctx, bitmask=bitmask, relation=true)$ 
    flagId = 0;
    $bitmask.members:{ flag | $check_bitmask_flag_type(ctx=ctx, flag=flag, relation=true)$ }; separator="\n"$
    result &= $bitmask.name$_complete_flagseq.size() == flagId; 

    if(result){
        std::cout << std::endl << "======OK====== Test $bitmask.name$" << std::endl;
    }else{
        std::cout << std::endl << "=====FAIL===== Test $bitmask.name$" << std::endl;
    }
    return result;
});
>>

test_bitset(ctx, parent, bitset) ::= <<
functions_to_run.emplace_back([]() -> bool
{
    std::cout << std::endl << "======================================== Testing bitset: $bitset.name$ ========================================" << std::endl;
    unsigned short bitfieldId;
    bool result = true;

    //Minimal
    $check_bitset_type(ctx=ctx, bitset=bitset, relation=false)$ 
    bitfieldId = 0;
    $bitset.members:{ bitfield | $check_bitfield_type(ctx=ctx, bitfield=bitfield, relation=false)$ }; separator="\n"$
    result &= $bitset.name$_minimal_bitfieldseq.size() == bitfieldId; 

    //Complete
    $check_bitset_type(ctx=ctx, bitset=bitset, relation=true)$ 
    bitfieldId = 0;
    $bitset.members:{ bitfield | $check_bitfield_type(ctx=ctx, bitfield=bitfield, relation=true)$ }; separator="\n"$
    result &= $bitset.name$_complete_bitfieldseq.size() == bitfieldId; 

    if(result){
        std::cout << std::endl << "======OK====== Test $bitset.name$" << std::endl;
    }else{
        std::cout << std::endl << "=====FAIL===== Test $bitset.name$" << std::endl;
    }
    return result;
});
>>

test_annotation(ctx, parent, annotation) ::= <<
functions_to_run.emplace_back([]() -> bool
{
    std::cout << std::endl << "======================================== Testing annotation: $annotation.name$ ========================================" << std::endl;
    MemberId memberId;
    bool result = true;

    //Minimal
    $check_annotation_type(ctx=ctx, annotation=annotation, relation=false)$ 
    memberId = 0;
    $annotation.members:{ parameter | $check_annotation_member_type(ctx=ctx, parameter=parameter, relation=false)$ }; separator="\n"$
    result &= $annotation.name$_minimal_memberseq.size() == memberId; 

    //Complete
    $check_annotation_type(ctx=ctx, annotation=annotation, relation=true)$ 
    memberId = 0;
    $annotation.members:{ parameter | $check_annotation_member_type(ctx=ctx, parameter=parameter, relation=true)$ }; separator="\n"$
    result &= $annotation.name$_complete_memberseq.size() == memberId;

    if(result){
        std::cout << std::endl << "======OK====== Test $annotation.name$" << std::endl;
    }else{
        std::cout << std::endl << "=====FAIL===== Test $annotation.name$" << std::endl;
    }
    return result;
});
>>

test_const(ctx, parent, const) ::= <<
functions_to_run.emplace_back([]() -> bool
{
    std::cout << std::endl << "======================================== Testing const: $const.name$ ========================================" << std::endl;
    bool result = true;

    //Minimal
    $check_const_type(ctx=ctx, const=const, relation=false)$ 

    //Complete
    $check_const_type(ctx=ctx, const=const, relation=true)$ 
    
    if(result){
        std::cout << std::endl << "======OK====== Test $const.name$" << std::endl;
    }else{
        std::cout << std::endl << "=====FAIL===== Test $const.name$" << std::endl;
    }
    return result;
});
>>


fwd_decl(ctx, parent, type) ::= <<>>

typedef_decl(ctx, parent, typedefs) ::= <<
$test_typedef(ctx=ctx, parent=parent, typedefs=typedefs)$
>>

struct_type(ctx, parent, struct) ::= <<
$test_structure(ctx=ctx, parent=parent, struct=struct)$
>>

union_type(ctx, parent, union) ::= <<
$test_union(ctx=ctx, parent=parent, union=union)$
>>

enum_type(ctx, parent, enum) ::= <<
$test_enum(ctx=ctx, parent=parent, enum=enum)$
>>

bitmask_type(ctx, parent, bitmask) ::= <<
$test_bitmask(ctx=ctx, parent=parent, bitmask=bitmask)$
>>

bitset_type(ctx, parent, bitset) ::= <<
$test_bitset(ctx=ctx, parent=parent, bitset=bitset)$
>>

annotation(ctx, parent, annotation) ::= <<
$test_annotation(ctx=ctx, parent=parent, annotation=annotation)$
>>

module(ctx, parent, module, definition_list) ::= <<
$definition_list$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

const_decl(ctx, parent, const) ::= <<
$test_const(ctx=ctx, parent=parent, const=const)$
>>






get_type_identifier(ctx, type, relation) ::= <<
    $if(type.isSequenceType)$
    DomainParticipantFactory::get_instance()->type_object_registry()->get_sequence_identifier($get_content_type(ctx=ctx, type=type.contentTypeCode)$, $type.maxsize$, $relation$);
    $elseif(type.isArrayType)$
    DomainParticipantFactory::get_instance()->type_object_registry()->get_array_identifier($get_content_type(ctx=ctx, type=type.contentTypeCode)$, {$type.dimensions:{ dim |$dim$}; separator=", "$}, $relation$);
    $elseif(type.isSetType)$
    DomainParticipantFactory::get_instance()->type_object_registry()->get_sequence_identifier($get_content_type(ctx=ctx, type=type.contentTypeCode)$, $type.maxsize$, $relation$);
    $elseif(type.isMapType)$
    DomainParticipantFactory::get_instance()->type_object_registry()->get_map_identifier($get_content_type(ctx=ctx, type=type.keyTypeCode)$, $get_content_type(ctx=ctx, type=type.valueTypeCode)$, $type.maxsize$, $relation$);
    $elseif(type.isStringType)$
    DomainParticipantFactory::get_instance()->type_object_registry()->get_string_identifier($type.maxsize$, false);
    $elseif(type.isWStringType)$
    DomainParticipantFactory::get_instance()->type_object_registry()->get_string_identifier($type.maxsize$, true);
    $elseif(type.objectType)$
    get_$type.name$_identifier($relation$);
    $elseif(type.plainType)$
    DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$type.cppTypenameForTypeId$", false);
    $else$
    DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$type.cppTypenameForTypeId$", false);
    $endif$
>>

get_type_object(ctx, type, relation) ::= <<
    DomainParticipantFactory::get_instance()->type_object_registry()->get_type_object("$type.name$", false);
>>

get_content_type(ctx, type) ::= <<
    $if(type.plainType)$
    $if(type.isSequenceType)$
    TypeNamesGenerator::get_sequence_type_name($get_content_type(ctx=ctx, type=type.contentTypeCode)$, $type.maxsize$)
    $elseif(type.isArrayType)$
    TypeNamesGenerator::get_array_type_name($get_content_type(ctx=ctx, type=type.contentTypeCode)$, {$type.dimensions:{ dim |$dim$}; separator=", "$})
    $elseif(type.isSetType)$
    TypeNamesGenerator::get_sequence_type_name($get_content_type(ctx=ctx, type=type.contentTypeCode)$, $type.maxsize$)
    $elseif(type.isMapType)$
    TypeNamesGenerator::get_map_type_name($get_content_type(ctx=ctx, type=type.keyTypeCode)$, $get_content_type(ctx=ctx, type=type.valueTypeCode)$, $type.maxsize$)
    $elseif(type.isStringType)$
    TypeNamesGenerator::get_string_type_name($type.maxsize$, false)
    $elseif(type.isWStringType)$
    TypeNamesGenerator::get_string_type_name($type.maxsize$, true)
    $else$
    "$type.cppTypenameForTypeId$"
    $endif$
    $else$
    "$type.cppTypenameForTypeId$"
    $endif$
>>


check_optional_detail_annotations(ctx, object) ::= <<
    $if(object.annotationList)$
    $object.annotationList: { annotation |
    $if(annotation.isVerbatim)$
    AppliedBuiltinTypeAnnotations $object.name$_$if(relation)$complete$else$minimal$endif$_applied_bta = $object.name$_$if(relation)$complete$else$minimal$endif$_detail.ann_builtin();
    AppliedVerbatimAnnotation $object.name$_$if(relation)$complete$else$minimal$endif$_vermatim_annotation = $object.name$_$if(relation)$complete$else$minimal$endif$_applied_bta.verbatim();
    $annotation.valueList : { vermatim_param |
    $if(vermatim_param.isVerbatimPlacement)$
    $object.name$_$if(relation)$complete$else$minimal$endif$_vermatim_annotation.placement() = $vermatim_param.enumStringValue$;
    $elseif(vermatim_param.isVerbatimLanguage)$
    $object.name$_$if(relation)$complete$else$minimal$endif$_vermatim_annotation.language() = $vermatim_param.value$;
    $elseif(vermatim_param.isVerbatimText)$
    $object.name$_$if(relation)$complete$else$minimal$endif$_vermatim_annotation.text() = $vermatim_param.value$;
    $endif$
    }; separator="\n"$
    $else$
    AppliedAnnotationSeq $object.name$_$if(relation)$complete$else$minimal$endif$_annotation_seq = $object.name$_$if(relation)$complete$else$minimal$endif$_detail.ann_custom();
    for(int i = 0; i < $object.name$_$if(relation)$complete$else$minimal$endif$_annotation_seq.size(); i++)
    {
        AppliedAnnotation $object.name$_$if(relation)$complete$else$minimal$endif$_applied_annotation = $object.name$_$if(relation)$complete$else$minimal$endif$_annotation_seq.at(i);
        TypeIdentifier* $object.name$_annotation_type_id = DomainParticipantFactory::get_instance()->type_object_registry()->get_type_identifier("$object.name$", true);
        result &= $object.name$_$if(relation)$complete$else$minimal$endif$_applied_annotation.annotation_typeid() == $object.name$_annotation_type_id;
        AppliedAnnotationParameterSeq $object.name$_$if(relation)$complete$else$minimal$endif$_annotation_param_seq = $object.name$_$if(relation)$complete$else$minimal$endif$_applied_annotation.param_seq();
        for(int i = 0; i < $object.name$_$if(relation)$complete$else$minimal$endif$_annotation_param_seq.size(); i++)
        {
            AppliedAnnotationParameter $object.name$_$if(relation)$complete$else$minimal$endif$_annotation_param = $object.name$_$if(relation)$complete$else$minimal$endif$_annotation_param_seq.at(i);
            NameHash paramname_hash;//?????
            AnnotationParameterValue value;//?????
        \}
    \}
    $endif$
    }; separator=""$
    $endif$
>>