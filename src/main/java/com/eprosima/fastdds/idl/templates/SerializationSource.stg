// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

import "eprosima.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "SerializationSource.cpp"], description=["This file contains serialization code."])$

#include "$ctx.filename$Serialization.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <string.h>
#include <cassert>

bool g_$ctx.filename$_test_null_opt = false;

$ctx.directIncludeDependencies:{ header | #include "$header$Serialization.h"}; separator="\n"$

$definitions; separator="\n"$

>>

struct_type(ctx, parent, struct) ::= <<
$if((ctx.generateTypesC))$
void $if(struct.hasScope)$$struct.scope$::$endif$free_string$struct.name$(
        $struct.name$* topic)
{
    $struct.allMembers:{ member |
        $free_member_string(ctx=ctx, typecode=member.typecode, name=member.name)$
    }; separator=""$
}

$endif$
void $if(struct.hasScope)$$struct.scope$::$endif$print$struct.name$(
        $struct.name$* topic)
{
    $if(!struct.allMembers)$
    static_cast<void>(topic);
    $endif$
    printf("$struct.name$: { \n");
    $struct.allMembers:{ member |
        $member_print(ctx=ctx, typecode=member.typecode, name=member.name, originName=member.name, optional=member.annotationOptional)$
    }; separator="\n"$
    printf("}\n");
}

void $if(struct.hasScope)$$struct.scope$::$endif$initialize$struct.name$(
        $struct.name$* topic,
        int idx)
{
    $if(struct.allMembers)$
    if (idx == 0)
    {
        $struct.allMembers:{ member |
            $if(member.annotationOptional)$
            if(!g_$ctx.filename$_test_null_opt)
            {
            $endif$
            $member_assignment(ctx=ctx, typecode=member.typecode, name=member.name, originName=member.name, optional=member.annotationOptional)$
            $if(member.annotationOptional)$
            \}
            $endif$
        }; separator="\n"$
    }
    else
    {
        $struct.allMembers:{ member |
            $if(member.annotationOptional)$
            if(!g_$ctx.filename$_test_null_opt)
            {
            $endif$
            $simply_member_assignment(ctx=ctx, typecode=member.typecode, name=member.name, optional=member.annotationOptional)$
            $if(member.annotationOptional)$
            \}
            $endif$
        }; separator="\n"$
    }
    $else$
    static_cast<void>(topic);
    static_cast<void>(idx);
    $endif$
}

int $if(struct.hasScope)$$struct.scope$::$endif$compare$struct.name$(
        $struct.name$* topic_a,
        $struct.name$* topic_b)
{
    $if(!struct.allMembers)$
    static_cast<void>(topic_a);
    static_cast<void>(topic_b);
    $endif$
    $struct.allMembers:{ member |
        $member_comparision(ctx=ctx, typecode=member.typecode, name=member.name, originName=member.name, optional=member.annotationOptional)$
    }; separator="\n"$
    return 1;
}

$if(struct.hasScope)$$struct.scope$::$endif$$struct.name$ $if(struct.hasScope)$$struct.scope$::$endif$createKey$struct.name$(
        int idx)
{
    $struct.name$ result;
    initialize$struct.name$(&result, idx+1); // 0 means don't use the idx internally.
    return result;
}

>>

union_type(ctx, parent, union) ::= <<
void $if(union.hasScope)$$union.scope$::$endif$print$union.name$(
        $union.name$* topic)
{
    topic->_d(static_cast<$union.discriminator.cppTypename$>($first(first(union.members).labels)$));
    printf("$union.name$: { \n");
    $if(union.members)$
    $member_print(ctx=ctx, typecode=first(union.members).typecode, name=first(union.members).name,
            originName=first(union.members).name, optional=first(union.members).annotationOptional)$
    $endif$
    printf("}\n");
}

void $if(union.hasScope)$$union.scope$::$endif$initialize$union.name$(
        $union.name$* topic)
{
    $if(union.members)$
    $member_assignment(ctx=ctx, typecode=first(union.members).typecode, name=first(union.members).name,
            originName=first(union.members).name, optional=first(union.members).annotationOptional)$
    $endif$
}

int $if(union.hasScope)$$union.scope$::$endif$compare$union.name$(
        $union.name$* topic_a,
        $union.name$* topic_b)
{
    topic_a->_d(static_cast<$union.discriminator.cppTypename$>($first(first(union.members).labels)$));
    topic_b->_d(static_cast<$union.discriminator.cppTypename$>($first(first(union.members).labels)$));
    $if(union.members)$
    $member_comparision(ctx=ctx, typecode=first(union.members).typecode, name=first(union.members).name,
            originName=first(union.members).name, optional=first(union.members).annotationOptional)$
    $endif$
    return 1;
}

>>

enum_type(ctx, parent, enum) ::= <<>>

bitmask_type(ctx, parent, bitmask) ::= <<
void $if(bitmask.hasScope)$$bitmask.scope$::$endif$print$bitmask.name$(
        $bitmask.name$* topic)
{
    printf("$bitmask.scopedname$: { \n");
    $bitmask.members:{ member | printf("$member.name$: %s\n", ((*topic & $bitmask.name$Bits::$member.name$) == $bitmask.name$Bits::$member.name$) ? "true" : "false");}; separator="\n"$
}

void $if(bitmask.hasScope)$$bitmask.scope$::$endif$initialize$bitmask.name$(
        $bitmask.name$* topic)
{
    $bitmask.members:{ member |
    if (rand() % 2 == 1)
    {
        *topic |= $bitmask.name$Bits::$member.name$;
    \}
    }; separator="\n"$
}

int $if(bitmask.hasScope)$$bitmask.scope$::$endif$compare$bitmask.name$(
        $bitmask.name$* topic_a,
        $bitmask.name$* topic_b)
{
    return *topic_a == *topic_b;
}

>>

typedef_decl(ctx, parent, typedefs) ::= <<>>

annotation(ctx, annotation) ::= <<>>

module(ctx, parent, module, definition_list) ::= <<
$definition_list$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$

>>

fwd_decl(ctx, parent, type) ::= <<>>

const_decl(ctx, parent, const) ::= <<>>

bitset_type(ctx, parent, bitset) ::= <<
void $if(bitset.hasScope)$$bitset.scope$::$endif$print$bitset.name$(
        $bitset.name$* topic)
{
    printf("$bitset.name$: { \n");
    $bitset.allBitfields:{ bitfield |
        $if(bitfield.name)$printf("$bitfield.name$: 0x%" PRIx64 "\n", (uint64_t)topic->$bitfield.name$());$endif$
    }; separator="\n"$
}

void $if(bitset.hasScope)$$bitset.scope$::$endif$initialize$bitset.name$(
        $bitset.name$* topic)
{
    $bitset.allBitfields:{ bitfield |
        $if(bitfield.name)$$if(bitfield.spec.typecode.isType_7)$topic->$bitfield.name$(static_cast<$bitfield.spec.typecode.cppTypename$>(rand()%2==1));$elseif(bitfield.spec.typecode.primitive)$topic->$bitfield.name$(static_cast<$bitfield.spec.typecode.cppTypename$>(rand()));$endif$$endif$
    }; separator="\n"$
}

int $if(bitset.hasScope)$$bitset.scope$::$endif$compare$bitset.name$(
        $bitset.name$* topic_a,
        $bitset.name$* topic_b)
{
    $bitset.allBitfields:{ bitfield |
        $if(bitfield.name)$if(topic_a->$bitfield.name$() != topic_b->$bitfield.name$()) return 0;$endif$
    }; separator="\n"$
    return 1;
}

>>

// ========================================================================================
//                                      ASSIGNMENT
// ========================================================================================
simply_member_assignment(ctx, typecode, name, optional) ::= <<
$if(typecode.isType_10)$
$simply_member_assignment(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, optional=optional)$
$elseif(typecode.isType_7)$
topic->$name$(static_cast<$typecode.cppTypename$>(idx%2==1));
$elseif(typecode.primitive)$
topic->$name$(static_cast<$typecode.cppTypename$>(idx));
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
topic->$name$(std::to_wstring(idx));
$elseif(ctx.generateTypesC)$
topic->$name$() = std::to_string(idx).c_str();
$else$
topic->$name$() = std::to_string(idx);
$endif$
$elseif(typecode.isSequenceType)$
printf("For testing map's key structs sequences aren't allowed.\n");
assert(false);
$elseif(typecode.isType_f)$
printf("For testing map's key structs arrays aren't allowed.\n");
assert(false);
$elseif(typecode.isMapType)$
printf("For testing map's key structs maps aren't allowed.\n");
assert(false);
$else$
printf("For testing map's key structs $typecode.cppTypename$ aren't allowed.\n");
assert(false);
$endif$
>>

member_assignment(ctx, typecode, name, originName, optional) ::= <<
$if(typecode.isType_10)$
$member_assignment(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, optional=optional)$
$elseif(typecode.isType_7)$
topic->$name$(static_cast<$typecode.cppTypename$>(rand()%2==1));
$elseif(typecode.isWCharType)$
topic->$name$(L'W');
$elseif(typecode.primitive)$
topic->$name$(static_cast<$typecode.cppTypename$>(rand()));
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
topic->$name$(std::wstring($typecode.maxsize$,'W'));
$else$
topic->$name$() = u8"AAAu8u8ñññöAA\u2602";
$endif$
$elseif(typecode.isSequenceType)$
$if(optional)$topic->$name$().reset(true);$endif$
$sequence_assigment(ctx=ctx, typecode=typecode, name=name, p=optional_suffix(p="()", optional=optional), loopvar=ctx.newLoopVarName)$
$elseif(typecode.isType_f)$
$if(optional)$topic->$name$().reset(true);$endif$
$array_assigment(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p=optional_suffix(p="()", optional=optional), loopvar=ctx.newLoopVarName)$
$elseif(typecode.isMapType)$
$if(optional)$topic->$name$().reset(true);$endif$
$map_assigment(ctx=ctx, typecode=typecode, name=name, originName=originName, p=optional_suffix(p="()", optional=optional), loopvar=ctx.newLoopVarName)$
$else$
$if(optional)$topic->$name$().reset(true);$endif$
$typecode.scope$::initialize$typecode.name$(&topic->$name$()$if(optional)$.value()$endif$);
$endif$
>>

array_member_assignment(ctx, typecode, name, originName, loopvar) ::= <<
$if(typecode.isType_7)$
topic->$name$ = static_cast<$typecode.cppTypename$>(rand()%2==1);
$elseif(typecode.isWCharType)$
topic->$name$ = static_cast<$typecode.cppTypename$>(L'W');
$elseif(typecode.primitive)$
topic->$name$ = static_cast<$typecode.cppTypename$>(rand());
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
topic->$name$ = std::wstring($typecode.maxsize$,'W');
$elseif(ctx.generateTypesC)$
free(topic->$name$);
topic->$name$ = (char*)malloc(6); // AAAAA\0
strncpy(topic->$name$, "AAAAA", 6);
$else$
topic->$name$ = std::string($typecode.maxsize$,'A');
$endif$
$elseif(typecode.isType_10)$
$array_member_assignment(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, loopvar=loopvar)$
$elseif(typecode.isSequenceType)$
$sequence_assigment(ctx=ctx, typecode=typecode, name=name, p="", loopvar=loopvar)$
$elseif(typecode.isType_f)$
$array_assigment(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p="", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_assigment(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=loopvar)$
$else$
$typecode.scope$::initialize$typecode.name$(&topic->$name$);
$endif$
>>

sequence_member_assignment(ctx, typecode, name, originName, p, loopvar, currentvar) ::= <<
$if(typecode.isType_7)$
$if(ctx.generateTypesC)$
topic->$name$$p$.value()[$currentvar$] = static_cast<$typecode.cppTypename$>(rand()%2==1);
$else$
topic->$name$$p$.push_back(static_cast<$typecode.cppTypename$>(rand()%2==1));
$endif$
$elseif(typecode.isWCharType)$
topic->$name$$p$.push_back(static_cast<$typecode.cppTypename$>(L'W'));
$elseif(typecode.primitive)$
$if(ctx.generateTypesC)$
topic->$name$$p$.value()[$currentvar$] = static_cast<$typecode.cppTypename$>(rand());
$else$
topic->$name$$p$.push_back(static_cast<$typecode.cppTypename$>(rand()));
$endif$
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
$if(ctx.generateTypesC)$
topic->$name$$p$.value()[$currentvar$] = std::wstring($typecode.maxsize$,'W');
$else$
topic->$name$$p$.push_back(std::wstring($typecode.maxsize$,'W'));
$endif$
$else$
$if(ctx.generateTypesC)$
topic->$name$$p$.value()[$currentvar$] = u8"AA\u2602A\u2602AA";
$else$
topic->$name$$p$.push_back(u8"AA\u2602A\u2602AA");
$endif$
$endif$
$elseif(typecode.isSequenceType)$
$sequence_assigment(ctx=ctx, typecode=typecode, name=name, loopvar=loopvar, p="")$
$elseif(typecode.isType_f)$
$array_assigment(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p="", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_assigment(ctx=ctx, typecode=typecode, name=name, originName=originName, loopvar=loopvar, p="")$
$elseif(typecode.isType_10)$
$sequence_member_assignment(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, p=p, loopvar=loopvar, currentvar=currentvar)$
$else$
$typecode.cppTypename$ aux$typecode.cTypename$_$name$;
initialize$typecode.name$(&aux$typecode.cTypename$_$name$);
$if(ctx.generateTypesC)$
topic->$name$$p$.value()[$currentvar$] = aux$typecode.cTypename$_$name$;
$else$
topic->$name$$p$.push_back(aux$typecode.cTypename$_$name$);
$endif$
$endif$

>>

map_member_assignment(ctx, keytypecode, valueTypeCode, name, originName, p, loopvar) ::= <<
// Key generation
$if(keytypecode.isType_10)$
$map_member_assignment(ctx=ctx, keytypecode=keytypecode.typedefContentTypeCode, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(keytypecode.isType_7)$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = static_cast<$keytypecode.cppTypename$>(rand()%2==1);
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(keytypecode.isWCharType)$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = static_cast<$keytypecode.cppTypename$>(L'W');
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(keytypecode.primitive)$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = static_cast<$keytypecode.cppTypename$>(rand());
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(keytypecode.isType_d)$
$if(keytypecode.isWStringType)$
$if(keytypecode.isBounded)$
std::wstring var_map_Key$loopvar$ = std::wstring($keytypecode.maxsize$, 'W');
$else$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = std::wstring($keytypecode.maxsize$, 'W');
$endif$
var_map_Key$loopvar$ = std::to_wstring(rand()) + var_map_Key$loopvar$ ;
var_map_Key$loopvar$ = var_map_Key$loopvar$.substr(0, $keytypecode.maxsize$);
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$else$
$if(keytypecode.isBounded)$
std::string var_map_Key$loopvar$ = std::string($keytypecode.maxsize$,'A');
$else$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = std::string($keytypecode.maxsize$,'A');
$endif$
var_map_Key$loopvar$ = std::to_string(rand()) + var_map_Key$loopvar$ ;
var_map_Key$loopvar$ = var_map_Key$loopvar$.substr(0, $keytypecode.maxsize$);
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$endif$
$elseif(keytypecode.isSequenceType)$
printf("Sequences not supported for testing map's key.\n");
assert(false);
$elseif(keytypecode.isType_f)$
printf("Arrays not supported for testing map's key.\n");
assert(false);
$elseif(keytypecode.isMapType)$
printf("Maps not supported for testing map's key.\n");
assert(false);
$elseif(keytypecode.isUnionType)$
printf("Unions not supported for testing map's key.\n");
assert(false);
$elseif(keytypecode.isStructType)$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = createKey$keytypecode.cppTypename$($loopvar$);
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$else$
printf("Unsupported testing map's key type ($keytypecode.cppTypename$).\n");
assert(false);
$endif$
>>

map_member_value_assignment(ctx, valueTypeCode, name, originName, p, loopvar) ::= <<
// Value assignment
$if(valueTypeCode.isType_7)$
topic->$name$$p$[var_map_Key$loopvar$] = static_cast<$valueTypeCode.cppTypename$>(rand()%2==1);
$elseif(valueTypeCode.isWCharType)$
topic->$name$$p$[var_map_Key$loopvar$] = static_cast<$valueTypeCode.cppTypename$>(L'W');
$elseif(valueTypeCode.primitive)$
topic->$name$$p$[var_map_Key$loopvar$] = static_cast<$valueTypeCode.cppTypename$>(rand());
$elseif(valueTypeCode.isType_d)$
$if(valueTypeCode.isWStringType)$
topic->$name$$p$[var_map_Key$loopvar$] = std::wstring($valueTypeCode.maxsize$,'W');
$elseif(ctx.generateTypesC)$
free(topic->$name$$p$[var_map_Key$loopvar$]);
topic->$name$$p$[var_map_Key$loopvar$] = (char*)malloc(6); // AAAAA\0
strncpy(topic->$name$$p$[var_map_Key$loopvar$], "AAAAA", 6);
$else$
topic->$name$$p$[var_map_Key$loopvar$] = std::string($valueTypeCode.maxsize$,'A');
$endif$
$elseif(valueTypeCode.isType_10)$
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode.typedefContentTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(valueTypeCode.isSequenceType)$
$sequence_assigment(ctx=ctx, typecode=valueTypeCode, name=mapName(name=name, p=p, key1="var_map_", key2=loopvar), loopvar=loopvar, p="")$
$elseif(valueTypeCode.isType_f)$
$array_assigment(ctx=ctx, typecode=valueTypeCode, name=mapName(name=name, p="()", key1="var_map_", key2=loopvar), originName=originName, dimensions=valueTypeCode.dimensions, p="", loopvar=loopvar)$
$elseif(valueTypeCode.isMapType)$
$map_assigment(ctx=ctx, typecode=valueTypeCode, name=mapName(name=name, p=p, key1="var_map_", key2=loopvar), originName=originName,loopvar=loopvar, p="")$
$else$
$valueTypeCode.cppTypename$ aux$valueTypeCode.cppTypename$_$name$;
initialize$valueTypeCode.cppTypename$(&aux$valueTypeCode.cppTypename$_$name$);
topic->$name$$p$[var_map_Key$loopvar$] = aux$valueTypeCode.cppTypename$_$name$;
$endif$
>>

sequence_assigment(ctx, typecode, name, p, loopvar) ::= <<
$if(typecode.contentTypeCode.forwarded)$
static bool $name$_detect_recursive_ = false;
$endif$
$if(typecode.contentTypeCode.isArrayType)$
topic->$name$$p$.resize(50);
$endif$
$if(typecode.contentTypeCode.isMapType)$
topic->$name$$p$.resize(50);
$endif$
for(size_t $loopvar$ = 0; $if(typecode.contentTypeCode.forwarded)$!$name$_detect_recursive_ && $endif$$loopvar$ < $if(typecode.unbound)$50$else$$typecode.maxsize$$endif$; ++$loopvar$)
{
    $if(typecode.contentTypeCode.forwarded)$
    $name$_detect_recursive_ = true;
    $endif$
    $if(typecode.contentTypeCode.isSequenceType)$
    topic->$name$$p$.emplace_back();
    $if(ctx.generateTypesC)$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=[p, ".value()"], loopvar=loopvar), originName=name, p="", loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $else$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, p="", loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $endif$
    $elseif(typecode.contentTypeCode.isArrayType)$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, p="", loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $elseif(typecode.contentTypeCode.isMapType)$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, p="", loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $else$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=name, originName=name, p=p, loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $endif$
    $if(typecode.contentTypeCode.forwarded)$
    $name$_detect_recursive_ = false;
    $endif$
}
>>

map_assigment(ctx, typecode, name, originName, p, loopvar) ::= <<
for(size_t $loopvar$ = 0; $loopvar$ < $typecode.maxsize$; ++$loopvar$)
{
    $if(typecode.valueTypeCode.isSequenceType)$
    $map_member_assignment(ctx=ctx, keytypecode=typecode.keyTypeCode, valueTypeCode=typecode.valueTypeCode, name=name, originName=originName, p=p, loopvar=ctx.nextLoopVarName)$
    $elseif(typecode.valueTypeCode.isMapType)$
    $map_member_assignment(ctx=ctx, keytypecode=typecode.keyTypeCode, valueTypeCode=typecode.valueTypeCode, name=name, originName=originName, p=p, loopvar=ctx.nextLoopVarName)$
    $elseif(typecode.valueTypeCode.isArrayType)$
    $map_member_assignment(ctx=ctx, keytypecode=typecode.keyTypeCode, valueTypeCode=typecode.valueTypeCode, name=name, originName=originName, p="", loopvar=ctx.nextLoopVarName)$
    $else$
    $map_member_assignment(ctx=ctx, keytypecode=typecode.keyTypeCode, valueTypeCode=typecode.valueTypeCode, name=name, originName=originName, p=p, loopvar=ctx.nextLoopVarName)$
    $endif$
}
>>

array_assigment(ctx, typecode, name, originName, dimensions, p, loopvar) ::= <<
$if(rest(dimensions))$
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    $array_assigment(ctx=ctx, typecode=typecode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, dimensions=rest(dimensions), p="", loopvar=ctx.nextLoopVarName)$
}
$elseif(typecode.isType_f)$
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    $array_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$elseif(typecode.contentTypeCode.primitive)$
memset(&topic->$name$$p$, static_cast<$typecode.contentTypeCode.cppTypename$>(rand()),  sizeof(topic->$name$$p$));
$elseif(typecode.contentTypeCode.isType_d)$
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    $array_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$else$
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    $array_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$endif$
>>



// ========================================================================================
//                                         PRINT
// ========================================================================================
member_print(ctx, typecode, name, originName, optional) ::= <<
$if(optional)$
if (topic->$name$().has_value()) {
$endif$

$if(typecode.primitive)$
printf("$name$: 0x%" PRIx64 "\n", (uint64_t)topic->$name$()$if(optional)$.value()$endif$);
$elseif(typecode.isBitsetType)$
printf("$name$: %s\n", topic->$name$()$if(optional)$.value()$endif$.bitset().to_string().c_str());
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
printf("$name$: %ls\n", topic->$name$()$if(optional)$.value()$endif$.c_str());
$elseif(ctx.generateTypesC)$
printf("$name$: %s\n", topic->$name$()$if(optional)$.value()$endif$);
$else$
printf("$name$: %s\n", topic->$name$()$if(optional)$.value()$endif$.c_str());
$endif$
$elseif(typecode.isType_10)$
$member_print(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, optional=optional)$
$elseif(typecode.isSequenceType)$
$sequence_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p=optional_suffix(p="()", optional=optional), loopvar=ctx.newLoopVarName)$
$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p=optional_suffix(p="()", optional=optional), loopvar=ctx.newLoopVarName)$
$elseif(typecode.isType_f)$
$array_print(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p=optional_suffix(p="()", optional=optional), loopvar=ctx.newLoopVarName)$
$else$
$typecode.scope$::print$typecode.name$(&topic->$name$()$if(optional)$.value()$endif$);
$endif$

$if(optional)$
}
$endif$
>>

array_member_print(ctx, typecode, name, originName, loopvar) ::= <<
$if(typecode.primitive)$
printf("$name$: 0x%" PRIx64 "\n", (uint64_t)topic->$name$);
$elseif(typecode.isBitsetType)$
printf("$name$: %s\n", topic->$name$.bitset().to_string().c_str());
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
printf("$name$: %ls\n", topic->$name$.c_str());
$elseif(ctx.generateTypesC)$
printf("$name$: %s\n", topic->$name$);
$else$
printf("$name$: %s\n", topic->$name$.c_str());
$endif$
$elseif(typecode.isType_10)$
$array_member_print(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, loopvar=loopvar)$
$elseif(typecode.isSequenceType)$
$sequence_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.isType_f)$
$array_print(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p="", loopvar=loopvar)$
$else$
$typecode.scope$::print$typecode.name$(&topic->$name$);
$endif$
>>

map_member_print(ctx, typecode, name, originName, loopvar) ::= <<
printf("[%" PRIx64 "]: ", (uint64_t)(it_$loopvar$.first));
$if(typecode.valueTypeCode.primitive)$
printf("$name$: 0x%" PRIx64 "\n", (uint64_t)topic->$name$);
$elseif(typecode.isBitsetType)$
printf("$name$: %s\n", topic->$name$.bitset().to_string().c_str());
$elseif(typecode.valueTypeCode.isType_d)$
$if(typecode.valueTypeCode.isWStringType)$
printf("$name$: %ls\n", topic->$name$.c_str());
$elseif(ctx.generateTypesC)$
printf("$name$: %s\n", topic->$name$());
$else$
printf("$name$: %s\n", topic->$name$.c_str());
$endif$
$elseif(typecode.isType_10)$
$map_member_print(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName)$
$elseif(typecode.valueTypeCode.isSequenceType)$
$sequence_print(ctx=ctx, typecode=typecode.valueTypeCode, name=itMapName(name=name, loopvar=loopvar), originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.valueTypeCode.isMapType)$
$map_print(ctx=ctx, typecode=typecode.valueTypeCode, name=itMapName(name=name, loopvar=loopvar), originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.valueTypeCode.isType_f)$
$array_print(ctx=ctx, typecode=typecode.valueTypeCode, name=itMapName(name=name, loopvar=loopvar), originName=originName, dimensions=typecode.valueTypeCode.dimensions, p="", loopvar=loopvar)$
$else$
$typecode.valueTypeCode.scope$::print$typecode.valueTypeCode.name$(&topic->$name$[it_$loopvar$.first]);
$endif$
>>

sequence_print(ctx, typecode, name, originName, p, loopvar) ::= <<
printf("$name$_size: 0x%" PRIx64 "\n", (uint64_t)topic->$name$$p$.size());
$if(typecode.contentTypeCode.primitive)$
printf("$name$: ");
$print_sequence(name=name, p=p, loopvar=loopvar)$
$elseif(typecode.contentTypeCode.isType_10)$
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode.typedefContentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
}

$elseif(typecode.contentTypeCode.isMapType)$
$map_print(ctx=ctx, typecode=typecode.contentTypeCode, name=name, originName=originName, p="", loopvar=loopvar)$

$else$
printf("$name$: \n");
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    $if(ctx.generateTypesC)$
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=[p, ".value()"], loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
    $else$
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
    $endif$
}
$endif$
>>

map_print(ctx, typecode, name, originName, p, loopvar) ::= <<
printf("$name$_size: 0x%" PRIx64 "\n", (uint64_t)topic->$name$$p$.size());
for (auto it_$loopvar$ : topic->$name$$p$)
{
    printf("-");
    $map_key_print(ctx=ctx, typecode=typecode.keyTypeCode, name=itMapName(name=name, p=p, loopvar=loopvar), originName=originName, p="", loopvar=loopvar)$
    printf(" : ");
    $map_value_print(ctx=ctx, typecode=typecode.valueTypeCode, name=itMapName(name=name, p=p, loopvar=loopvar), originName=originName, p="", loopvar=loopvar)$
    printf("\n");
}
>>



map_key_print(ctx, typecode, name, originName, p, loopvar) ::= <<
$if(typecode.isType_d)$
    $if(typecode.isWStringType)$
        printf("[%ls]", (it_$loopvar$.first).c_str());
    $elseif(ctx.generateTypesC)$
        printf("[%s]", (it_$loopvar$.first));
    $else$
        printf("[%s]", (it_$loopvar$.first).c_str());
    $endif$
$elseif(typecode.isSequenceType)$
$sequence_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.isType_f)$
$array_print(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p="", loopvar=loopvar)$
$elseif(typecode.isType_10)$
    $map_key_print(ctx=ctx, typecode=typecode.contentTypeCode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.primitive)$
    static_cast<void>(it_$loopvar$);
    printf("[$typecode$]");
$else$
    static_cast<void>(it_$loopvar$);
    printf("[$typecode$]");
$endif$
>>

map_value_print(ctx, typecode, name, originName, p, loopvar) ::= <<
$if(typecode.isType_d)$
    $if(typecode.isWStringType)$
        printf("[%ls]", (topic->$name$$p$).c_str());
    $elseif(ctx.generateTypesC)$
        printf("[%s]", (topic->$name$$p$));
    $else$
        printf("[%s]", (topic->$name$$p$).c_str());
    $endif$

$elseif(typecode.isSequenceType)$
$sequence_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.isType_f)$
$array_print(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p="", loopvar=loopvar)$
$elseif(typecode.isType_10)$
    $map_value_print(ctx=ctx, typecode=typecode.contentTypeCode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.primitive)$
    static_cast<void>(it_$loopvar$);
    printf("[$typecode$]");
$else$
    static_cast<void>(it_$loopvar$);
    printf("[$typecode$]");
$endif$
>>

array_print(ctx, typecode, name, originName, dimensions, p, loopvar) ::= <<
$if(rest(dimensions))$
printf("$name$: \n");
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    $array_print(ctx=ctx, typecode=typecode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, dimensions=rest(dimensions), p="", loopvar=ctx.nextLoopVarName)$
}
$elseif(typecode.contentTypeCode.primitive)$
printf("$name$: ");
$print_array(name=name, p=p, loopvar=loopvar)$
$elseif(typecode.contentTypeCode.isType_d)$
printf("$name$: \n");
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
}

$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=loopvar)$

$else$
printf("$name$: \n");
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
}
$endif$
>>

print_sequence(name, p, loopvar) ::= <<
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    printf("%" PRIx64 " ", (uint64_t)topic->$name$$p$$if(ctx.generateTypesC)$.value()$endif$[$loopvar$]);
}
printf("\n");
>>

print_array(name, p, loopvar) ::= <<
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$.size(); ++$loopvar$)
{
    printf("%" PRIx64 " ", (uint64_t)topic->$name$$p$[$loopvar$]);
}
printf("\n");
>>

// ========================================================================================
//                                      COMPARISION
// ========================================================================================
member_comparision(ctx, typecode, name, originName, optional) ::= <<
$if(typecode.primitive)$
if (topic_a->$name$() != topic_b->$name$()) return 0;
$elseif(typecode.isType_d)$
$if(typecode.isStringType)$
$if(ctx.generateTypesC)$
if (strncmp(topic_a->$name$(), topic_b->$name$(), strlen(topic_b->$name$())) != 0) return 0;
$else$
if (topic_a->$name$() != topic_b->$name$()) return 0;
$endif$
$else$
if (topic_a->$name$() != topic_b->$name$()) return 0;
$endif$
$elseif(typecode.isType_10)$
$member_comparision(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, optional=optional)$
$elseif(typecode.isSequenceType)$
$if(optional)$
if(topic_a->$name$().has_value())
{
$endif$
$sequence_comparision(ctx=ctx, typecode=typecode, name=name, p=optional_suffix(p="()", optional=optional), loopvar=ctx.newLoopVarName)$
$if(optional)$
}
else
{
    if (topic_a->$name$().has_value() != topic_b->$name$().has_value()) return 0;
}
$endif$
$elseif(typecode.isMapType)$
$if(optional)$
if(topic_a->$name$().has_value())
{
$endif$
$map_comparision(ctx=ctx, typecode=typecode, name=name, originName=originName, p=optional_suffix(p="()", optional=optional), loopvar=ctx.newLoopVarName)$
$if(optional)$
}
else
{
    if (topic_a->$name$().has_value() != topic_b->$name$().has_value()) return 0;
}
$endif$
$elseif(typecode.isType_f)$
$if(optional)$
if(topic_a->$name$().has_value())
{
$endif$
$array_comparision(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p=optional_suffix(p="()", optional=optional), loopvar=ctx.newLoopVarName)$
$if(optional)$
}
else
{
    if (topic_a->$name$().has_value() != topic_b->$name$().has_value()) return 0;
}
$endif$
$else$
$if(optional)$
if(topic_a->$name$().has_value())
{
$endif$
if (!$typecode.scope$::compare$typecode.name$(&topic_a->$name$()$if(optional)$.value()$endif$, &topic_b->$name$()$if(optional)$.value()$endif$)) return 0;
$if(optional)$
}
else
{
    if (topic_a->$name$().has_value() != topic_b->$name$().has_value()) return 0;
}
$endif$
$endif$
>>

array_member_comparision(ctx, typecode, name, originName, loopvar) ::= <<
$if(typecode.primitive)$
if (topic_a->$name$ != topic_b->$name$) return 0;
$elseif(typecode.isType_d)$
$if(typecode.isStringType)$
$if(ctx.generateTypesC)$
if (strncmp(topic_a->$name$, topic_b->$name$, strlen(topic_b->$name$)) != 0) return 0;
$else$
if (topic_a->$name$ != topic_b->$name$) return 0;
$endif$
$else$
if (topic_a->$name$ != topic_b->$name$) return 0;
$endif$
$elseif(typecode.isType_10)$
$array_member_comparision(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, loopvar=loopvar)$
$elseif(typecode.isSequenceType)$
$sequence_comparision(ctx=ctx, typecode=typecode, name=name, p="", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_comparision(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.isType_f)$
$array_comparision(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p="", loopvar=loopvar)$
$else$
if (!$typecode.scope$::compare$typecode.name$(&topic_a->$name$, &topic_b->$name$)) return 0;
$endif$
>>

map_member_comparision(ctx, typecode, name, originName, loopvar) ::= <<
$if(typecode.valueTypeCode.primitive)$
if (topic_a->$name$ != topic_b->$name$) return 0;
$elseif(typecode.valueTypeCode.isType_d)$
$if(typecode.valueTypeCode.isStringType)$
$if(ctx.generateTypesC)$
if (strncmp(topic_a->$name$, topic_b->$name$, strlen(topic_b->$name$)) != 0) return 0;
$else$
if (topic_a->$name$ != topic_b->$name$) return 0;
$endif$
$else$
if (topic_a->$name$ != topic_b->$name$) return 0;
$endif$
$elseif(typecode.isType_10)$
$map_member_comparision(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, loopvar=loopvar)$
$elseif(typecode.valueTypeCode.isSequenceType)$
$sequence_comparision(ctx=ctx, typecode=typecode.valueTypeCode, name=name, p="", loopvar=loopvar)$
$elseif(typecode.valueTypeCode.isMapType)$
$map_comparision(ctx=ctx, typecode=typecode.valueTypeCode, name=name, originName=originName, p="", loopvar=ctx.nextLoopVarName)$
$elseif(typecode.valueTypeCode.isType_f)$
$array_comparision(ctx=ctx, typecode=typecode.valueTypeCode, name=name, originName=originName, dimensions=typecode.valueTypeCode.dimensions, p="", loopvar=loopvar)$
$else$
if (!$typecode.valueTypeCode.scope$::compare$typecode.valueTypeCode.name$(&topic_a->$name$, &topic_b->$name$)) return 0;
$endif$
>>

sequence_comparision(ctx, typecode, name, p, loopvar) ::= <<
for(size_t $loopvar$ = 0; $loopvar$ < topic_a->$name$$p$.size(); ++$loopvar$)
{
    $if(ctx.generateTypesC)$
    $array_member_comparision(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=[p, ".value()"], loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
    $else$
    $array_member_comparision(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
    $endif$
}
>>

map_comparision(ctx, typecode, name, originName, p, loopvar) ::= <<
for(auto it_$loopvar$ : topic_a->$name$$p$)
{
    $map_member_comparision(ctx=ctx, typecode=typecode, name=itMapName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=loopvar)$
}
>>

array_comparision(ctx, typecode, name, originName, dimensions, p, loopvar) ::= <<
$if(rest(dimensions))$
for(size_t $loopvar$ = 0; $loopvar$ < topic_a->$name$$p$.size(); ++$loopvar$)
{
    $array_comparision(ctx=ctx, typecode=typecode, name=indexName(name=name, loopvar=loopvar, p=p), originName=originName, dimensions=rest(dimensions), p="", loopvar=ctx.nextLoopVarName)$
}
$elseif(typecode.contentTypeCode.primitive)$
if (memcmp(&topic_a->$name$$p$, &topic_b->$name$$p$, sizeof(topic_a->$name$$p$)) != 0) return 0;
$elseif(typecode.contentTypeCode.isType_d)$
for(size_t $loopvar$ = 0; $loopvar$ < topic_a->$name$$p$.size(); ++$loopvar$)
{
    $array_member_comparision(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$else$
for(size_t $loopvar$ = 0; $loopvar$ < topic_a->$name$$p$.size(); ++$loopvar$)
{
    $array_member_comparision(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$endif$
>>

// ========================================================================================
//                                      AUXILIAR
// ========================================================================================
indexName(name, p, loopvar) ::= <<$name$$p$[$loopvar$]>>
mapName(name, p, key1, key2) ::= <<$name$$p$[$key1$Key$key2$]>>
itMapName(name, p, loopvar) ::= <<$name$$p$[it_$loopvar$.first]>>

// ========================================================================================
//                                      C STRING
// ========================================================================================
// TODO: Add more cases if tests evolve...
free_member_string(ctx, typecode, name) ::= <<
$if(ctx.generateTypesC)$
$if(typecode.isType_a)$
free_string$typecode.name$(&topic->$name$());
$elseif(typecode.isSequenceType)$$if(typecode.contentTypeCode.isType_d)$
char** $name$_buffer = topic->$name$().value(true);
delete[] $name$_buffer;
$endif$$endif$$endif$
>>

optional_suffix(p, optional) ::= <<$if(optional)$$p$.value()$else$$p$$endif$>>
