// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

import "eprosima.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "SerializationSource.cpp"], description=["This file contains serialization code."])$

#include "$ctx.filename$Serialization.hpp"

#include <cassert>
#include <cinttypes>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <string>
#include <type_traits>

#include <fastcdr/config.h>

bool g_$ctx.filename$_test_null_opt = false;
bool g_$ctx.filename$_test_empty_ext = false;

$ctx.directIncludeDependencies:{ header | #include "$header$Serialization.hpp"}; separator="\n"$

$definitions; separator="\n"$

>>

struct_type(ctx, parent, struct, member_list) ::= <<
$member_list$
$if((ctx.generateTypesC))$
void $if(struct.hasScope)$$struct.scope$::$endif$free_string$struct.name$(
        $struct.name$* topic)
{
    $struct.allMembers:{ member |
        $free_member_string(ctx=ctx, typecode=member.typecode, name=member.name)$
    }; separator=""$
}

$endif$
void $if(struct.hasScope)$$struct.scope$::$endif$print$struct.name$(
        $struct.name$* topic)
{
    $if(!struct.allMembers)$
    static_cast<void>(topic);
    $endif$
    printf("$struct.name$: { \n");
    $struct.allMembers:{ member |
        $member_print(ctx=ctx, typecode=member.typecode, name=member.name, originName=member.name,
                optional=member.annotationOptional, external=member.annotationExternal)$
    }; separator="\n"$
    printf("}\n");
}

void $if(struct.hasScope)$$struct.scope$::$endif$initialize$struct.name$(
        $struct.name$* topic,
        int idx)
{
    static bool $struct.name$_detect_recursive_ = false;

    if (!$struct.name$_detect_recursive_)
    {
        $struct.name$_detect_recursive_ = true;

        $if(struct.allMembers)$
        if (idx == 0)
        {
            $struct.allMembers:{ member |
                $if(member.annotationOptional)$
                if(!g_$ctx.filename$_test_null_opt)
                {
                    topic->$member.name$().reset(true);
                $endif$
                $if(member.annotationExternal)$
                if(!g_$ctx.filename$_test_empty_ext)
                {
                $endif$
                $member_assignment(ctx=ctx, typecode=member.typecode, name=member.name, originName=member.name,
                        optional=member.annotationOptional, external=member.annotationExternal)$
                $if(member.annotationExternal)$
                \}
                $endif$
                $if(member.annotationOptional)$
                \}
                $endif$
            }; separator="\n"$
        }
        else
        {
            $struct.allMembers:{ member |
                $if(member.annotationOptional)$
                if(!g_$ctx.filename$_test_null_opt)
                {
                    topic->$member.name$().reset(true);
                $endif$
                $if(member.annotationExternal)$
                if(!g_$ctx.filename$_test_empty_ext)
                {
                $endif$
                $simply_member_assignment(ctx=ctx, typecode=member.typecode, name=member.name,
                        optional=member.annotationOptional, external=member.annotationExternal)$
                $if(member.annotationExternal)$
                \}
                $endif$
                $if(member.annotationOptional)$
                \}
                $endif$
            }; separator="\n"$
        }
        $else$
        static_cast<void>(topic);
        static_cast<void>(idx);
        $endif$

        $struct.name$_detect_recursive_ = false;
    }
}

int $if(struct.hasScope)$$struct.scope$::$endif$compare$struct.name$(
        $struct.name$* topic_a,
        $struct.name$* topic_b)
{
    $if(!struct.allMembers)$
    static_cast<void>(topic_a);
    static_cast<void>(topic_b);
    $endif$
    $struct.allMembers:{ member |
        $member_comparision(ctx=ctx, typecode=member.typecode, name=member.name, originName=member.name,
                optional=member.annotationOptional, external=member.annotationExternal)$
    }; separator="\n"$
    return 1;
}

$if(struct.hasScope)$$struct.scope$::$endif$$struct.name$ $if(struct.hasScope)$$struct.scope$::$endif$createKey$struct.name$(
        int idx)
{
    $struct.name$ result;
    initialize$struct.name$(&result, idx+1); // 0 means don't use the idx internally.
    return result;
}

>>

union_type(ctx, parent, union, switch_type) ::= <<
$switch_type$
void $if(union.hasScope)$$union.scope$::$endif$print$union.name$(
        $union.name$* topic)
{
    printf("$union.name$: { \n");
    $if(union.members)$
    $if(last(union.members).labels)$
    topic->_d(static_cast<$union.discriminator.typecode.cppTypename$>($first(last(union.members).labels)$));
    $member_print(ctx=ctx, typecode=last(union.members).typecode, name=last(union.members).name,
            originName=last(union.members).name, optional=last(union.members).annotationOptional,
            external=last(union.members).annotationExternal)$
    $else$
    topic->_d(static_cast<$union.discriminator.typecode.cppTypename$>($first(first(union.members).labels)$));
    $member_print(ctx=ctx, typecode=first(union.members).typecode, name=first(union.members).name,
            originName=first(union.members).name, optional=first(union.members).annotationOptional,
            external=first(union.members).annotationExternal)$
    $endif$
    $endif$
    printf("}\n");
}

void $if(union.hasScope)$$union.scope$::$endif$initialize$union.name$(
        $union.name$* topic)
{
    $if(union.members)$
    $if(last(union.members).labels)$
    $member_assignment(ctx=ctx, typecode=last(union.members).typecode, name=last(union.members).name,
            originName=last(union.members).name, optional=last(union.members).annotationOptional,
            external=last(union.members).annotationExternal)$
    $else$
    $member_assignment(ctx=ctx, typecode=first(union.members).typecode, name=first(union.members).name,
            originName=first(union.members).name, optional=first(union.members).annotationOptional,
            external=first(union.members).annotationExternal)$
    $endif$
    $endif$
}

int $if(union.hasScope)$$union.scope$::$endif$compare$union.name$(
        $union.name$* topic_a,
        $union.name$* topic_b)
{
    $if(union.members)$
    $if(last(union.members).labels)$
    topic_a->_d(static_cast<$union.discriminator.typecode.cppTypename$>($first(last(union.members).labels)$));
    topic_b->_d(static_cast<$union.discriminator.typecode.cppTypename$>($first(last(union.members).labels)$));
    $member_comparision(ctx=ctx, typecode=last(union.members).typecode, name=last(union.members).name,
            originName=last(union.members).name, optional=last(union.members).annotationOptional,
            external=last(union.members).annotationExternal)$
    $else$
    topic_a->_d(static_cast<$union.discriminator.typecode.cppTypename$>($first(first(union.members).labels)$));
    topic_b->_d(static_cast<$union.discriminator.typecode.cppTypename$>($first(first(union.members).labels)$));
    $member_comparision(ctx=ctx, typecode=first(union.members).typecode, name=first(union.members).name,
            originName=first(union.members).name, optional=first(union.members).annotationOptional,
            external=first(union.members).annotationExternal)$
    $endif$
    $endif$
    return 1;
}

>>

bitmask_type(ctx, parent, bitmask) ::= <<
void $if(bitmask.hasScope)$$bitmask.scope$::$endif$print$bitmask.name$(
        $bitmask.name$* topic)
{
    printf("$bitmask.scopedname$: { \n");
    $bitmask.members:{ member | printf("$member.name$: %s\n", ((*topic & $bitmask.name$Bits::$member.name$) == $bitmask.name$Bits::$member.name$) ? "true" : "false");}; separator="\n"$
}

void $if(bitmask.hasScope)$$bitmask.scope$::$endif$initialize$bitmask.name$(
        $bitmask.name$* topic)
{
    $bitmask.members:{ member |
    if (rand() % 2 == 1)
    {
        *topic |= $bitmask.name$Bits::$member.name$;
    \}
    }; separator="\n"$
}

int $if(bitmask.hasScope)$$bitmask.scope$::$endif$compare$bitmask.name$(
        $bitmask.name$* topic_a,
        $bitmask.name$* topic_b)
{
    return *topic_a == *topic_b;
}

>>

bitset_type(ctx, parent, bitset) ::= <<
void $if(bitset.hasScope)$$bitset.scope$::$endif$print$bitset.name$(
        $bitset.name$* topic)
{
    printf("$bitset.name$: { \n");
    $bitset.definedBitfields:{ bitfield | printf("$bitfield.name$: 0x%" PRIx64 "\n", (uint64_t)topic->$bitfield.name$); }; separator="\n"$
    printf("} \n");
}

void $if(bitset.hasScope)$$bitset.scope$::$endif$initialize$bitset.name$(
        $bitset.name$* topic)
{
    $bitset.definedBitfields:{ bitfield |
        $if(bitfield.spec.typecode.isType_7)$
        topic->$bitfield.name$ = static_cast<$bitfield.spec.typecode.cppTypename$>(rand()%2==1);
        $elseif(bitfield.spec.typecode.primitive)$
        topic->$bitfield.name$ = static_cast<$bitfield.spec.typecode.cppTypename$>(rand());
        $endif$
    }; separator="\n"$
}

int $if(bitset.hasScope)$$bitset.scope$::$endif$compare$bitset.name$(
        $bitset.name$* topic_a,
        $bitset.name$* topic_b)
{
    $bitset.definedBitfields:{ bitfield | if(topic_a->$bitfield.name$ != topic_b->$bitfield.name$) return 0; }; separator="\n"$
    return 1;
}

>>

// ========================================================================================
//                                      ASSIGNMENT
// ========================================================================================
simply_member_assignment(ctx, typecode, name, optional, external) ::= <<
$if(optional && !typecode.isType_10)$topic->$name$().reset(true);$endif$
$if(external && !typecode.isType_10)$topic->$name$() = new $typecode.cppTypename$();$endif$

$if(typecode.isType_10)$
$simply_member_assignment(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, optional=optional, external=external)$
$elseif(typecode.isType_7)$
$if(external)$*$endif$topic->$name$() = static_cast<$typecode.cppTypename$>(idx%2==1);
$elseif(typecode.primitive)$
$if(external)$*$endif$topic->$name$() = static_cast<$typecode.cppTypename$>(idx);
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
$if(external)$*$endif$topic->$name$() = std::to_wstring(idx);
$elseif(ctx.generateTypesC)$
topic->$name$() = std::to_string(idx).c_str();
$else$
$if(external)$*$endif$topic->$name$() = std::to_string(idx);
$endif$
$elseif(typecode.isSequenceType)$
printf("For testing map's key structs sequences aren't allowed.\n");
assert(false);
$elseif(typecode.isType_f)$
printf("For testing map's key structs arrays aren't allowed.\n");
assert(false);
$elseif(typecode.isMapType)$
printf("For testing map's key structs maps aren't allowed.\n");
assert(false);
$else$
printf("For testing map's key structs $typecode.cppTypename$ aren't allowed.\n");
assert(false);
$endif$
>>

member_assignment(ctx, typecode, name, originName, optional, external) ::= <<
$if(optional && !typecode.isType_10)$topic->$name$().reset(true);$endif$

$if(typecode.isType_10)$
$member_assignment(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, optional=optional, external=external)$
$else$

$cppTypenameBetweenCdrVersions(typecode)$$if(external)$*$endif$ _$name$ $if(external)$= new $cppTypenameBetweenCdrVersions(typecode)$()$endif$;

$if(typecode.isType_7)$
$if(external)$*$endif$_$name$ = static_cast<$typecode.cppTypename$>(rand()%2==1);
$elseif(typecode.isWCharType)$
$if(external)$*$endif$_$name$ = L'W';
$elseif(typecode.primitive)$
$if(external)$*$endif$_$name$ = static_cast<$typecode.cppTypename$>(rand());
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
$if(external)$*$endif$_$name$= std::wstring($typecode.maxsize$,'W');
$else$
$if(external)$*$endif$_$name$ = u8"AAAu8u8ñññöAA\u2602";
$endif$
$elseif(typecode.isSequenceType)$
$sequence_assigment(ctx=ctx, typecode=typecode, name=name, p=external_suffix(p="", external=external),
        loopvar=ctx.newLoopVarName)$
$elseif(typecode.isType_f)$
$array_assignment(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions,
        p=external_suffix(p="", external=external), loopvar=ctx.newLoopVarName)$
$elseif(typecode.isMapType)$
$map_assigment(ctx=ctx, typecode=typecode, name=name, originName=originName,
        p=external_suffix(p="", external=external), loopvar=ctx.newLoopVarName)$
$else$
$typecode.scope$::initialize$typecode.name$(&$if(external)$*$endif$_$name$);
$endif$

topic->$name$($if(external)${$endif$_$name$$if(external)$}$endif$);
$endif$
>>

array_member_assignment(ctx, typecode, name, originName, loopvar) ::= <<
$if(typecode.isType_7)$
_$name$ = static_cast<$typecode.cppTypename$>(rand()%2==1);
$elseif(typecode.isWCharType)$
_$name$ = static_cast<$typecode.cppTypename$>(L'W');
$elseif(typecode.primitive)$
_$name$ = static_cast<$typecode.cppTypename$>(rand());
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
_$name$ = std::wstring($typecode.maxsize$,'W');
$elseif(ctx.generateTypesC)$
free(_$name$);
_$name$ = (char*)malloc(6); // AAAAA\0
strncpy(_$name$, "AAAAA", 6);
$else$
_$name$ = std::string($typecode.maxsize$,'A');
$endif$
$elseif(typecode.isType_10)$
$array_member_assignment(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, loopvar=loopvar)$
$elseif(typecode.isSequenceType)$
$sequence_assigment(ctx=ctx, typecode=typecode, name=name, p=".", loopvar=loopvar)$
$elseif(typecode.isType_f)$
$array_assignment(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p=".", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_assigment(ctx=ctx, typecode=typecode, name=name, originName=originName, p=".", loopvar=loopvar)$
$else$
$typecode.scope$::initialize$typecode.name$(&_$name$);
$endif$
>>

sequence_member_assignment(ctx, typecode, name, originName, p, loopvar, currentvar) ::= <<
$if(typecode.isType_7)$
$if(ctx.generateTypesC)$
_$name$$p$value()[$currentvar$] = static_cast<$typecode.cppTypename$>(rand()%2==1);
$else$
_$name$$p$push_back(static_cast<$typecode.cppTypename$>(rand()%2==1));
$endif$
$elseif(typecode.isWCharType)$
_$name$$p$push_back(static_cast<$typecode.cppTypename$>(L'W'));
$elseif(typecode.primitive)$
$if(ctx.generateTypesC)$
_$name$$p$value()[$currentvar$] = static_cast<$typecode.cppTypename$>(rand());
$else$
_$name$$p$push_back(static_cast<$typecode.cppTypename$>(rand()));
$endif$
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
$if(ctx.generateTypesC)$
_$name$$p$value()[$currentvar$] = std::wstring($typecode.maxsize$,'W');
$else$
_$name$$p$push_back(std::wstring($typecode.maxsize$,'W'));
$endif$
$else$
$if(ctx.generateTypesC)$
_$name$$p$value()[$currentvar$] = u8"AA\u2602A\u2602AA";
$else$
_$name$$p$push_back(u8"AA\u2602A\u2602AA");
$endif$
$endif$
$elseif(typecode.isSequenceType)$
$sequence_assigment(ctx=ctx, typecode=typecode, name=name, loopvar=loopvar, p=".")$
$elseif(typecode.isType_f)$
$array_assignment(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p=".", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_assigment(ctx=ctx, typecode=typecode, name=name, originName=originName, loopvar=loopvar, p=".")$
$elseif(typecode.isType_10)$
$sequence_member_assignment(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, p=p, loopvar=loopvar, currentvar=currentvar)$
$else$
$typecode.cppTypename$ aux$typecode.cTypename$_$name$;
initialize$typecode.name$(&aux$typecode.cTypename$_$name$);
$if(ctx.generateTypesC)$
_$name$$p$value()[$currentvar$] = aux$typecode.cTypename$_$name$;
$else$
_$name$$p$push_back(aux$typecode.cTypename$_$name$);
$endif$
$endif$

>>

map_member_assignment(ctx, keytypecode, valueTypeCode, name, originName, p, loopvar) ::= <<
// Key generation
$if(keytypecode.isType_10)$
$map_member_assignment(ctx=ctx, keytypecode=keytypecode.typedefContentTypeCode, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(keytypecode.isType_7)$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = static_cast<$keytypecode.cppTypename$>(rand()%2==1);
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(keytypecode.isWCharType)$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = static_cast<$keytypecode.cppTypename$>(L'W');
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(keytypecode.primitive)$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = static_cast<$keytypecode.cppTypename$>(rand());
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(keytypecode.isType_d)$
$if(keytypecode.isWStringType)$
$if(keytypecode.isBounded)$
std::wstring var_map_Key$loopvar$ = std::wstring($keytypecode.maxsize$, 'W');
$else$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = std::wstring($keytypecode.maxsize$, 'W');
$endif$
var_map_Key$loopvar$ = std::to_wstring(rand()) + var_map_Key$loopvar$ ;
var_map_Key$loopvar$ = var_map_Key$loopvar$.substr(0, $keytypecode.maxsize$);
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$else$
$if(keytypecode.isBounded)$
std::string var_map_Key$loopvar$ = std::string($keytypecode.maxsize$,'A');
$else$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = std::string($keytypecode.maxsize$,'A');
$endif$
var_map_Key$loopvar$ = std::to_string(rand()) + var_map_Key$loopvar$ ;
var_map_Key$loopvar$ = var_map_Key$loopvar$.substr(0, $keytypecode.maxsize$);
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$endif$
$elseif(keytypecode.isSequenceType)$
printf("Sequences not supported for testing map's key.\n");
assert(false);
$elseif(keytypecode.isType_f)$
printf("Arrays not supported for testing map's key.\n");
assert(false);
$elseif(keytypecode.isMapType)$
printf("Maps not supported for testing map's key.\n");
assert(false);
$elseif(keytypecode.isUnionType)$
printf("Unions not supported for testing map's key.\n");
assert(false);
$elseif(keytypecode.isStructType)$
$keytypecode.cppTypename$ var_map_Key$loopvar$ = createKey$keytypecode.cppTypename$($loopvar$);
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$else$
printf("Unsupported testing map's key type ($keytypecode.cppTypename$).\n");
assert(false);
$endif$
>>

map_member_value_assignment(ctx, valueTypeCode, name, originName, p, loopvar) ::= <<
// Value assignment
$if(valueTypeCode.isType_7)$
_$name$$p$insert({var_map_Key$loopvar$, static_cast<$valueTypeCode.cppTypename$>(rand()%2==1)});
$elseif(valueTypeCode.isWCharType)$
_$name$$p$insert({var_map_Key$loopvar$, static_cast<$valueTypeCode.cppTypename$>(L'W')});
$elseif(valueTypeCode.primitive)$
_$name$$p$insert({var_map_Key$loopvar$, static_cast<$valueTypeCode.cppTypename$>(rand())});
$elseif(valueTypeCode.isType_d)$
$if(valueTypeCode.isWStringType)$
_$name$$p$insert({var_map_Key$loopvar$, std::wstring($valueTypeCode.maxsize$,'W')});
$elseif(ctx.generateTypesC)$
free(_$name$$p$at(var_map_Key$loopvar$));
_$name$$p$insert({var_map_Key$loopvar$, (char*)malloc(6)}); // AAAAA\0
strncpy(_$name$$p$at(var_map_Key$loopvar$), "AAAAA", 6);
$else$
_$name$$p$insert({var_map_Key$loopvar$, std::string($valueTypeCode.maxsize$,'A')});
$endif$
$elseif(valueTypeCode.isType_10)$
$map_member_value_assignment(ctx=ctx, valueTypeCode=valueTypeCode.typedefContentTypeCode, name=name, originName=originName, p=p, loopvar=loopvar)$
$elseif(valueTypeCode.isSequenceType)$
_$name$$p$insert({var_map_Key$loopvar$, {}});
$sequence_assigment(ctx=ctx, typecode=valueTypeCode, name=mapName(name=name, p=p, key1="var_map_", key2=loopvar),
        loopvar=loopvar, p=".")$
$elseif(valueTypeCode.isType_f)$
_$name$$p$insert({var_map_Key$loopvar$, {}});
$array_assignment(ctx=ctx, typecode=valueTypeCode, name=mapName(name=name, p=".", key1="var_map_", key2=loopvar),
        originName=originName, dimensions=valueTypeCode.dimensions, p=".", loopvar=loopvar)$
$elseif(valueTypeCode.isMapType)$
_$name$$p$insert({var_map_Key$loopvar$, {}});
$map_assigment(ctx=ctx, typecode=valueTypeCode, name=mapName(name=name, p=p, key1="var_map_", key2=loopvar),
        originName=originName,loopvar=loopvar, p=".")$
$else$
$valueTypeCode.cppTypename$ aux$valueTypeCode.cppTypename$_$name$;
initialize$valueTypeCode.cppTypename$(&aux$valueTypeCode.cppTypename$_$name$);
_$name$$p$insert({var_map_Key$loopvar$, aux$valueTypeCode.cppTypename$_$name$});
$endif$
>>

sequence_assigment(ctx, typecode, name, p, loopvar) ::= <<
$if(typecode.contentTypeCode.forwarded)$
static bool $name$_detect_recursive_ = false;
$endif$
$if(typecode.contentTypeCode.isArrayType)$
_$name$$p$resize(50);
$endif$
$if(typecode.contentTypeCode.isMapType)$
_$name$$p$resize(50);
$endif$
for(size_t $loopvar$ = 0; $if(typecode.contentTypeCode.forwarded)$!$name$_detect_recursive_ && $endif$$loopvar$ < $if(typecode.unbound)$50$else$$typecode.maxsize$$endif$; ++$loopvar$)
{
    $if(typecode.contentTypeCode.forwarded)$
    $name$_detect_recursive_ = true;
    $endif$
    $if(typecode.contentTypeCode.isSequenceType)$
    _$name$$p$emplace_back();
    $if(ctx.generateTypesC)$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=[p, "value()"], loopvar=loopvar), originName=name, p="", loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $else$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, p="", loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $endif$
    $elseif(typecode.contentTypeCode.isArrayType)$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, p="", loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $elseif(typecode.contentTypeCode.isMapType)$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, p="", loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $else$
    $sequence_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=name, originName=name, p=p, loopvar=ctx.nextLoopVarName, currentvar=loopvar)$
    $endif$
    $if(typecode.contentTypeCode.forwarded)$
    $name$_detect_recursive_ = false;
    $endif$
}
>>

map_assigment(ctx, typecode, name, originName, p, loopvar) ::= <<
for(size_t $loopvar$ = 0; $loopvar$ < $if(typecode.unbound)$50$else$$typecode.maxsize$$endif$; ++$loopvar$)
{
    $if(typecode.valueTypeCode.isSequenceType)$
    $map_member_assignment(ctx=ctx, keytypecode=typecode.keyTypeCode, valueTypeCode=typecode.valueTypeCode, name=name,
            originName=originName, p=p, loopvar=ctx.nextLoopVarName)$
    $elseif(typecode.valueTypeCode.isMapType)$
    $map_member_assignment(ctx=ctx, keytypecode=typecode.keyTypeCode, valueTypeCode=typecode.valueTypeCode, name=name,
            originName=originName, p=p, loopvar=ctx.nextLoopVarName)$
    $elseif(typecode.valueTypeCode.isArrayType)$
    $map_member_assignment(ctx=ctx, keytypecode=typecode.keyTypeCode, valueTypeCode=typecode.valueTypeCode, name=name,
            originName=originName, p=p, loopvar=ctx.nextLoopVarName)$
    $else$
    $map_member_assignment(ctx=ctx, keytypecode=typecode.keyTypeCode, valueTypeCode=typecode.valueTypeCode, name=name,
            originName=originName, p=p, loopvar=ctx.nextLoopVarName)$
    $endif$
}
>>

array_assignment(ctx, typecode, name, originName, dimensions, p, loopvar) ::= <<
$if(rest(dimensions))$
for(size_t $loopvar$ = 0; $loopvar$ < _$name$$p$size(); ++$loopvar$)
{
    $array_assignment(ctx=ctx, typecode=typecode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, dimensions=rest(dimensions), p=".", loopvar=ctx.nextLoopVarName)$
}
$elseif(typecode.isType_f)$
for(size_t $loopvar$ = 0; $loopvar$ < _$name$$p$size(); ++$loopvar$)
{
    $array_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$elseif(typecode.contentTypeCode.primitive)$
memset(&_$name$$p$at(0), static_cast<$typecode.contentTypeCode.cppTypename$>(rand()),  sizeof(_$name$$p$));
$elseif(typecode.contentTypeCode.isType_d)$
for(size_t $loopvar$ = 0; $loopvar$ < _$name$$p$size(); ++$loopvar$)
{
    $array_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$else$
for(size_t $loopvar$ = 0; $loopvar$ < _$name$$p$size(); ++$loopvar$)
{
    $array_member_assignment(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$endif$
>>



// ========================================================================================
//                                         PRINT
// ========================================================================================
member_print(ctx, typecode, name, originName, optional, external) ::= <<
$if(optional)$
if (topic->$name$().has_value()) {
    $if(external)$
    if (topic->$name$().value()) {
    $endif$
$elseif(external)$
if (topic->$name$()) {
$endif$

$if(typecode.primitive)$
printf("$name$: 0x%" PRIx64 "\n", (uint64_t)topic->$name$()$if(optional)$.value()$endif$);
$elseif(typecode.isBitsetType)$
printf("$name$: \n"); $if(typecode.hasScope)$$typecode.scope$::$endif$print$typecode.name$(&topic->$name$()$if(optional)$.value()$endif$);
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
printf("$name$: %ls\n", topic->$name$()$if(optional)$.value()$endif$$if(external)$->$else$.$endif$c_str());
$elseif(ctx.generateTypesC)$
printf("$name$: %s\n", topic->$name$()$if(optional)$.value()$endif$);
$else$
printf("$name$: %s\n", topic->$name$()$if(optional)$.value()$endif$$if(external)$->$else$.$endif$c_str());
$endif$
$elseif(typecode.isType_10)$
$member_print(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, optional=optional, external=external)$
$elseif(typecode.isSequenceType)$
$sequence_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p=optional_external_suffix(p="()", optional=optional, external=external), loopvar=ctx.newLoopVarName)$
$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p=optional_external_suffix(p="()",
            optional=optional, external=external), loopvar=ctx.newLoopVarName)$
$elseif(typecode.isType_f)$
$array_print(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions,
        p=optional_external_suffix(p="()", optional=optional, external=external), loopvar=ctx.newLoopVarName)$
$else$
$typecode.scope$::print$typecode.name$(&$if(external)$*$endif$topic->$name$()$if(optional)$.value()$endif$);
$endif$

$if(optional)$
}
    $if(external)$
    }
    $endif$
$elseif(external)$
}
$endif$
>>

array_member_print(ctx, typecode, name, originName, loopvar) ::= <<
$if(typecode.primitive)$
printf("$name$: 0x%" PRIx64 "\n", (uint64_t)topic->$name$);
$elseif(typecode.isBitsetType)$
printf("$name$: \n"); $if(typecode.hasScope)$$typecode.scope$::$endif$print$typecode.name$(&topic->$name$);
$elseif(typecode.isType_d)$
$if(typecode.isWStringType)$
printf("$name$: %ls\n", topic->$name$.c_str());
$elseif(ctx.generateTypesC)$
printf("$name$: %s\n", topic->$name$);
$else$
printf("$name$: %s\n", topic->$name$.c_str());
$endif$
$elseif(typecode.isType_10)$
$array_member_print(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, loopvar=loopvar)$
$elseif(typecode.isSequenceType)$
$sequence_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p=".", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p=".", loopvar=loopvar)$
$elseif(typecode.isType_f)$
$array_print(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p=".", loopvar=loopvar)$
$else$
$typecode.scope$::print$typecode.name$(&topic->$name$);
$endif$
>>

sequence_print(ctx, typecode, name, originName, p, loopvar) ::= <<
printf("$name$_size: 0x%" PRIx64 "\n", (uint64_t)topic->$name$$p$size());
$if(typecode.contentTypeCode.primitive)$
printf("$name$: ");
$print_sequence(name=name, p=p, loopvar=loopvar)$
$elseif(typecode.contentTypeCode.isType_10)$
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$size(); ++$loopvar$)
{
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode.typedefContentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
}

$elseif(typecode.contentTypeCode.isMapType)$
$map_print(ctx=ctx, typecode=typecode.contentTypeCode, name=name, originName=originName, p=".", loopvar=loopvar)$

$else$
printf("$name$: \n");
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$size(); ++$loopvar$)
{
    $if(ctx.generateTypesC)$
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=[p, "value()"], loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
    $else$
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
    $endif$
}
$endif$
>>

map_print(ctx, typecode, name, originName, p, loopvar) ::= <<
printf("$name$_size: 0x%" PRIx64 "\n", (uint64_t)topic->$name$$p$size());
for (auto it_$loopvar$ = topic->$name$$p$begin(); it_$loopvar$ != topic->$name$$p$end(); ++it_$loopvar$)
{
    printf("-");
    $map_key_print(ctx=ctx, typecode=typecode.keyTypeCode, name=itMapName(name=name, p=p, loopvar=loopvar), originName=originName, p="", loopvar=loopvar)$
    printf(" : ");
    $map_value_print(ctx=ctx, typecode=typecode.valueTypeCode, name=itMapName(name=name, p=p, loopvar=loopvar), originName=originName, p="", loopvar=loopvar)$
    printf("\n");
}
>>



map_key_print(ctx, typecode, name, originName, p, loopvar) ::= <<
$if(typecode.isType_d)$
    $if(typecode.isWStringType)$
        printf("[%ls]", (it_$loopvar$->first).c_str());
    $elseif(ctx.generateTypesC)$
        printf("[%s]", (it_$loopvar$->first));
    $else$
        printf("[%s]", (it_$loopvar$->first).c_str());
    $endif$
$elseif(typecode.isSequenceType)$
$sequence_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=ctx.nextLoopVarName)$
$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p="", loopvar=ctx.nextLoopVarName)$
$elseif(typecode.isType_f)$
$array_print(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p="",
        loopvar=ctx.nextLoopVarName)$
$elseif(typecode.isType_10)$
    $map_key_print(ctx=ctx, typecode=typecode.contentTypeCode, name=name, originName=originName, p="", loopvar=loopvar)$
$elseif(typecode.primitive)$
    static_cast<void>(it_$loopvar$);
    printf("[$typecode$]");
$else$
    static_cast<void>(it_$loopvar$);
    printf("[$typecode$]");
$endif$
>>

map_value_print(ctx, typecode, name, originName, p, loopvar) ::= <<
$if(typecode.isType_d)$
    $if(typecode.isWStringType)$
        printf("[%ls]", (topic->$name$$p$).c_str());
    $elseif(ctx.generateTypesC)$
        printf("[%s]", (topic->$name$$p$));
    $else$
        printf("[%s]", (topic->$name$$p$).c_str());
    $endif$

$elseif(typecode.isSequenceType)$
$sequence_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p=".", loopvar=ctx.nextLoopVarName)$
$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p=".", loopvar=ctx.nextLoopVarName)$
$elseif(typecode.isType_f)$
$array_print(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p=".",
        loopvar=ctx.nextLoopVarName)$
$elseif(typecode.isType_10)$
    $map_value_print(ctx=ctx, typecode=typecode.contentTypeCode, name=name, originName=originName, p=".", loopvar=loopvar)$
$elseif(typecode.primitive)$
    static_cast<void>(it_$loopvar$);
    printf("[$typecode$]");
$else$
    static_cast<void>(it_$loopvar$);
    printf("[$typecode$]");
$endif$
>>

array_print(ctx, typecode, name, originName, dimensions, p, loopvar) ::= <<
$if(rest(dimensions))$
printf("$name$: \n");
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$size(); ++$loopvar$)
{
    $array_print(ctx=ctx, typecode=typecode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, dimensions=rest(dimensions), p=".", loopvar=ctx.nextLoopVarName)$
}
$elseif(typecode.contentTypeCode.primitive)$
printf("$name$: ");
$print_array(name=name, p=p, loopvar=loopvar)$
$elseif(typecode.contentTypeCode.isType_d)$
printf("$name$: \n");
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$size(); ++$loopvar$)
{
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
}

$elseif(typecode.isMapType)$
$map_print(ctx=ctx, typecode=typecode, name=name, originName=originName, p=".", loopvar=loopvar)$

$else$
printf("$name$: \n");
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$size(); ++$loopvar$)
{
    $array_member_print(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
}
$endif$
>>

print_sequence(name, p, loopvar) ::= <<
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$size(); ++$loopvar$)
{
    printf("%" PRIx64 " ", (uint64_t)topic->$name$$p$$if(ctx.generateTypesC)$value()$endif$at($loopvar$));
}
printf("\n");
>>

print_array(name, p, loopvar) ::= <<
for(size_t $loopvar$ = 0; $loopvar$ < topic->$name$$p$size(); ++$loopvar$)
{
    printf("%" PRIx64 " ", (uint64_t)topic->$name$$p$at($loopvar$));
}
printf("\n");
>>

// ========================================================================================
//                                      COMPARISION
// ========================================================================================
member_comparision(ctx, typecode, name, originName, optional, external) ::= <<
$if(optional)$
if(topic_a->$name$().has_value())
{
    $if(external)$
    if(topic_a->$name$().value())
    {
    $endif$
$elseif(external)$
if(topic_a->$name$())
{
$endif$

$if(typecode.primitive)$
if ($if(external)$*$endif$topic_a->$name$() != $if(external)$*$endif$topic_b->$name$()) return 0;
$elseif(typecode.isType_d)$
$if(typecode.isStringType)$
$if(ctx.generateTypesC)$
if (strncmp(topic_a->$name$(), topic_b->$name$(), strlen(topic_b->$name$())) != 0) return 0;
$else$
if ($if(external)$*$endif$topic_a->$name$() != $if(external)$*$endif$topic_b->$name$()) return 0;
$endif$
$else$
if ($if(external)$*$endif$topic_a->$name$() != $if(external)$*$endif$topic_b->$name$()) return 0;
$endif$
$elseif(typecode.isType_10)$
$member_comparision(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, optional=optional, external=external)$
$elseif(typecode.isSequenceType)$
$sequence_comparision(ctx=ctx, typecode=typecode, name=name, p=optional_external_suffix(p="()", optional=optional,
            external=external), loopvar=ctx.newLoopVarName)$
$elseif(typecode.isMapType)$
$map_comparision(ctx=ctx, typecode=typecode, name=name, originName=originName, p=optional_external_suffix(p="()",
            optional=optional, external=external), loopvar=ctx.newLoopVarName)$
$elseif(typecode.isType_f)$
$array_comparision(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions,
        p=optional_external_suffix(p="()", optional=optional, external=external), loopvar=ctx.newLoopVarName)$
$else$
if (!$typecode.scope$::compare$typecode.name$(&$if(external)$*$endif$topic_a->$name$()$if(optional)$.value()$endif$, &$if(external)$*$endif$topic_b->$name$()$if(optional)$.value()$endif$)) return 0;
$endif$

$if(optional)$
    $if(external)$
    }
    else
    {
        if (topic_b->$name$().value()) return 0;
    }
    $endif$
}
else
{
    if (topic_a->$name$().has_value() != topic_b->$name$().has_value()) return 0;
}
$elseif(external)$
}
else
{
    if (topic_b->$name$()) return 0;
}
$endif$
>>

array_member_comparision(ctx, typecode, name, originName, loopvar) ::= <<
$if(typecode.primitive)$
if (topic_a->$name$ != topic_b->$name$) return 0;
$elseif(typecode.isType_d)$
$if(typecode.isStringType)$
$if(ctx.generateTypesC)$
if (strncmp(topic_a->$name$, topic_b->$name$, strlen(topic_b->$name$)) != 0) return 0;
$else$
if (topic_a->$name$ != topic_b->$name$) return 0;
$endif$
$else$
if (topic_a->$name$ != topic_b->$name$) return 0;
$endif$
$elseif(typecode.isType_10)$
$array_member_comparision(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, loopvar=loopvar)$
$elseif(typecode.isSequenceType)$
$sequence_comparision(ctx=ctx, typecode=typecode, name=name, p=".", loopvar=loopvar)$
$elseif(typecode.isMapType)$
$map_comparision(ctx=ctx, typecode=typecode, name=name, originName=originName, p=".", loopvar=loopvar)$
$elseif(typecode.isType_f)$
$array_comparision(ctx=ctx, typecode=typecode, name=name, originName=originName, dimensions=typecode.dimensions, p=".", loopvar=loopvar)$
$else$
if (!$typecode.scope$::compare$typecode.name$(&topic_a->$name$, &topic_b->$name$)) return 0;
$endif$
>>

map_member_comparision(ctx, typecode, name, originName, loopvar) ::= <<
$if(typecode.valueTypeCode.primitive)$
if (topic_a->$name$ != topic_b->$name$) return 0;
$elseif(typecode.valueTypeCode.isType_d)$
$if(typecode.valueTypeCode.isStringType)$
$if(ctx.generateTypesC)$
if (strncmp(topic_a->$name$, topic_b->$name$, strlen(topic_b->$name$)) != 0) return 0;
$else$
if (topic_a->$name$ != topic_b->$name$) return 0;
$endif$
$else$
if (topic_a->$name$ != topic_b->$name$) return 0;
$endif$
$elseif(typecode.isType_10)$
$map_member_comparision(ctx=ctx, typecode=typecode.typedefContentTypeCode, name=name, originName=originName, loopvar=loopvar)$
$elseif(typecode.valueTypeCode.isSequenceType)$
$sequence_comparision(ctx=ctx, typecode=typecode.valueTypeCode, name=name, p=".", loopvar=loopvar)$
$elseif(typecode.valueTypeCode.isMapType)$
$map_comparision(ctx=ctx, typecode=typecode.valueTypeCode, name=name, originName=originName, p=".", loopvar=ctx.nextLoopVarName)$
$elseif(typecode.valueTypeCode.isType_f)$
$array_comparision(ctx=ctx, typecode=typecode.valueTypeCode, name=name, originName=originName,
        dimensions=typecode.valueTypeCode.dimensions, p=".", loopvar=loopvar)$
$else$
if (!$typecode.valueTypeCode.scope$::compare$typecode.valueTypeCode.name$(&topic_a->$name$, &topic_b->$name$)) return 0;
$endif$
>>

sequence_comparision(ctx, typecode, name, p, loopvar) ::= <<
for(size_t $loopvar$ = 0; $loopvar$ < topic_a->$name$$p$size(); ++$loopvar$)
{
    $if(ctx.generateTypesC)$
    $array_member_comparision(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=[p, "value()"], loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
    $else$
    $array_member_comparision(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=ctx.nextLoopVarName)$
    $endif$
}
>>

map_comparision(ctx, typecode, name, originName, p, loopvar) ::= <<
for (auto it_$loopvar$ = topic_a->$name$$p$begin(); it_$loopvar$ != topic_a->$name$$p$end(); ++it_$loopvar$)
{
    $map_member_comparision(ctx=ctx, typecode=typecode, name=itMapName(name=name, p=p, loopvar=loopvar), originName=originName, loopvar=loopvar)$
}
>>

array_comparision(ctx, typecode, name, originName, dimensions, p, loopvar) ::= <<
$if(rest(dimensions))$
for(size_t $loopvar$ = 0; $loopvar$ < topic_a->$name$$p$size(); ++$loopvar$)
{
    $array_comparision(ctx=ctx, typecode=typecode, name=indexName(name=name, loopvar=loopvar, p=p), originName=originName, dimensions=rest(dimensions), p=".", loopvar=ctx.nextLoopVarName)$
}
$elseif(typecode.contentTypeCode.primitive)$
if (memcmp(&topic_a->$name$$p$at(0), &topic_b->$name$$p$at(0), topic_a->$name$$p$size() * sizeof($typecode.contentTypeCode.cppTypename$)) != 0) return 0;
$elseif(typecode.contentTypeCode.isType_d)$
for(size_t $loopvar$ = 0; $loopvar$ < topic_a->$name$$p$size(); ++$loopvar$)
{
    $array_member_comparision(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$else$
for(size_t $loopvar$ = 0; $loopvar$ < topic_a->$name$$p$size(); ++$loopvar$)
{
    $array_member_comparision(ctx=ctx, typecode=typecode.contentTypeCode, name=indexName(name=name, p=p, loopvar=loopvar), originName=name, loopvar=ctx.nextLoopVarName)$
}
$endif$
>>

// ========================================================================================
//                                      AUXILIAR
// ========================================================================================
indexName(name, p, loopvar) ::= <<$name$$p$at($loopvar$)>>
mapName(name, p, key1, key2) ::= <<$name$$p$at($key1$Key$key2$)>>
itMapName(name, p, loopvar) ::= <<$name$$p$at(it_$loopvar$->first)>>

optional_external_suffix(p, optional, external) ::= <<$p$$if(optional)$.value()$endif$$if(external)$->$else$.$endif$>>

external_suffix(p, external) ::= <<$p$$if(external)$->$else$.$endif$>>

cppTypenameBetweenCdrVersions(typecode) ::= <<
$if(typecode.isStringType && typecode.isBounded)$
$! Avoid error with namespace when generated fixed_string depending on CDR version !$
eprosima::fastcdr::fixed_string<$typecode.maxsize$>


$else$
$typecode.cppTypename$
$endif$
>>

// ========================================================================================
//                                      C STRING
// ========================================================================================
// TODO: Add more cases if tests evolve...
free_member_string(ctx, typecode, name) ::= <<
$if(ctx.generateTypesC)$
$if(typecode.isType_a)$
free_string$typecode.name$(&topic->$name$());
$elseif(typecode.isSequenceType)$$if(typecode.contentTypeCode.isType_d)$
char** $name$_buffer = topic->$name$().value(true);
delete[] $name$_buffer;
$endif$$endif$$endif$
>>
