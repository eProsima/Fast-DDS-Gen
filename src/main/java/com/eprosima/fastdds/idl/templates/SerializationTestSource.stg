// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

import "eprosima.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "SerializationTest.cpp"], description=["This file contains serialization test code."])$


#include <cstdint>
#include <cinttypes>
#include <string>
#include <tuple>
#include <vector>

#include <gtest/gtest.h>

#include "$ctx.filename$PubSubTypes.h"
#include "$ctx.filename$Serialization.h"
#include <fastcdr/Cdr.h>
#include <fastrtps/rtps/common/SerializedPayload.h>

$definitions; separator="\n"$

>>

test(ctx, parent, struct) ::= <<
TEST_P($struct.formatedCppTypename$Test, encoding)
{
    eprosima::fastdds::dds::DataRepresentationId_t cdr_version {std::get<0>(GetParam())};
    bool test_null_optional {$if(struct.containsOptional)$std::get<1>(GetParam())$else$false$endif$};
    std::cout << std::endl <<"======================================== Testing $struct.name$" <<
            (true == test_null_optional ? " with a null optional" : "") << " using encoding " <<
            (eprosima::fastdds::dds::DataRepresentationId_t::XCDR_DATA_REPRESENTATION == cdr_version ? "XCDRv1" : "XCDRv2") <<
            " ========================================" << std::endl;
    using eprosima::fastrtps::rtps::SerializedPayload_t;
    $if(struct.hasScope)$    using namespace $struct.scope$;$endif$

    $struct.name$PubSubType $struct.name$_type_support;
    $struct.name$ $struct.name$_serialization_topic;
    $struct.name$ $struct.name$_deserialization_topic;

    g_$ctx.filename$_test_null_opt = test_null_optional;

    initialize$struct.name$(&$struct.name$_serialization_topic);

    $struct.name$PubSubType pst;
    uint32_t payloadSize = static_cast<uint32_t>(pst.getSerializedSizeProvider(&$struct.name$_serialization_topic,
                cdr_version)());

    SerializedPayload_t payload(payloadSize);
    ASSERT_TRUE(pst.serialize(&$struct.name$_serialization_topic, &payload, cdr_version));

    ASSERT_TRUE(pst.deserialize(&payload, &$struct.name$_deserialization_topic));

    uint32_t payloadOutSize = static_cast<uint32_t>(pst.getSerializedSizeProvider(&$struct.name$_deserialization_topic,
                cdr_version)());

    ASSERT_GT(compare$struct.name$(&$struct.name$_serialization_topic, &$struct.name$_deserialization_topic), 0);
    ASSERT_EQ(payloadOutSize, payloadSize);
    ASSERT_GE($struct.name$_type_support.m_typeSize + 4, payloadSize);
    ASSERT_EQ(payload.length, payloadSize);

    $if((ctx.generateTypesC))$
    free_string$struct.name$(&$struct.name$_serialization_topic);
    $endif$
}
>>

fwd_decl(ctx, parent, type) ::= <<>>

struct_type(ctx, parent, struct) ::= <<

std::ostream& operator<<(std::ostream& stream, $struct.cppTypename$& e)
{
    print$struct.name$(&e);
    return stream;
}

class $struct.formatedCppTypename$Test : public ::testing::TestWithParam<
$if (struct.containsOptional)$
    std::tuple<eprosima::fastdds::dds::DataRepresentationId_t, bool>
$else$
    std::tuple<eprosima::fastdds::dds::DataRepresentationId_t>
$endif$
    >
{
};

$test(ctx=ctx, parent=parent, struct=struct)$

INSTANTIATE_TEST_SUITE_P(
    $ctx.filename$Test,
    $struct.formatedCppTypename$Test,
    ::testing::Values(
$if (struct.containsOptional)$
        std::make_tuple(eprosima::fastdds::dds::DataRepresentationId_t::XCDR_DATA_REPRESENTATION, false),
        std::make_tuple(eprosima::fastdds::dds::DataRepresentationId_t::XCDR_DATA_REPRESENTATION, true),
        std::make_tuple(eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION, false),
        std::make_tuple(eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION, true)
$else$
        std::make_tuple(eprosima::fastdds::dds::DataRepresentationId_t::XCDR_DATA_REPRESENTATION),
        std::make_tuple(eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION)
$endif$
        ));
>>

union_type(ctx, parent, union) ::= <<>>

enum_type(ctx, parent, enum) ::= <<>>

typedef_decl(ctx, parent, typedefs) ::= <<>>

bitmask_type(ctx, parent, bitmask) ::= <<>>

bitset_type(ctx, parent, bitset) ::= <<>>

annotation(ctx, annotation) ::= <<>>

module(ctx, parent, module, definition_list) ::= <<>>

definition_list(definitions) ::= <<>>

const_decl(ctx, parent, const) ::= <<>>
