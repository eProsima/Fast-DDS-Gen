// Copyright 2019 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group TypeObjectSource;

import "eprosima.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx, file=[ctx.filename, "TypeObject.cpp"], description=["This source file contains the TypeObject definition of the described types in the IDL file."])$

/* *INDENT-OFF* */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
} // namespace
#endif // _WIN32

#include "$ctx.filename$TypeObject.h"

#include <cassert>
#include <mutex>

$if(ctx.cdr)$
#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>
$endif$
#include <fastcdr/FastBuffer.h>
$if(ctx.fastcdr)$
#include <fastcdr/FastCdr.h>
$endif$

#include <fastrtps/rtps/common/SerializedPayload.h>
// TODO(jlbueno) Update headers <fastdds/dds/xtypes/...>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastrtps/types/TypeIdentifier.h>
#include <fastrtps/types/TypeObject.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/utils/md5.h>

#include "$ctx.filename$.h"

using namespace eprosima::fastrtps::rtps;
// TODO(jlbueno) Update to new namespace
using namespace eprosima::fastrtps::types;

void register$ctx.filename$Types()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                // TypeObject is registered internally when calling get_<type>_identifier if not previously registered
                // into TypeObjectFactory
                $ctx.definitions: { def | $register_type(ctx=ctx, object=def)$}; separator="\n"$
            });
}

$definitions; separator="\n"$

/* *INDENT-ON* */

>>

register_type(ctx, object) ::= <%
$if(!object.isModule)$
$if(!object.isConstDeclaration)$
$if(object.isAnnotation && (object.enums || object.typeDefs))$
{
    $register_annotation_types(object)$
}
$endif$
$register_type_object(object)$
$endif$
$endif$
%>

register_annotation_types(annotation) ::= <<

    $annotation.enums : { it | $register_annotation_enum(it)$}; separator="\n"$
    $annotation.typeDefs : { it | $register_annotation_typedef(it)$}; separator="\n"$
>>

register_type_object(object) ::= <<

$if(object.hasScope)$$object.scope$::$endif$get_$object.name$_object(true);
$if(object.hasScope)$$object.scope$::$endif$get_$object.name$_object(false);
>>

register_annotation_enum(enum) ::= <<
$if(enum.hasScope)$$enum.scope$::$endif$get_$enum.name$_object(true);
$if(enum.hasScope)$$enum.scope$::$endif$get_$enum.name$_object(false);
>>

register_annotation_typedef(typedef) ::= <<
$if(typedef.hasScope)$$typedef.scope$::$endif$get_$typedef.name$_object(true);
$if(typedef.hasScope)$$typedef.scope$::$endif$get_$typedef.name$_object(false);
>>

module(ctx, parent, module, definition_list) ::= <<
namespace $module.name$ {

$definition_list$

} // namespace $module.name$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

annotation(ctx, parent, annotation) ::= <<
$get_type_identifier_impl(ctx=ctx, param=annotation)$

$get_type_object_impl(ctx=ctx, param=annotation)$

$get_minimal_type_object_impl(ctx=ctx, param=annotation)$
    type_object->minimal()._d(TK_ANNOTATION);
    $minimal_annotation_type_impl(ctx=ctx, object=annotation)$
    type_object->minimal().annotation_type($annotation.name$_minimal_annotation_type);

    $type_identifier_impl(ctx=ctx, param=annotation, complete_discr=["EK_MINIMAL"], member=["minimal().annotation_type()"], complete_flag=["false"])$
}

$get_complete_type_object_impl(ctx=ctx, param=annotation)$
    type_object->complete()._d(TK_ANNOTATION);
    $complete_annotation_type_impl(ctx=ctx, object=annotation)$
    type_object->complete().annotation_type($annotation.name$_complete_annotation_type);

    $type_identifier_impl(ctx=ctx, param= annotation, complete_discr=["EK_COMPLETE"], member=["complete().annotation_type()"], complete_flag=["true"])$
}

$if(annotation.enums || annotation.typeDefs)$
namespace $annotation.name$
{
$annotation.enums : { it | $enum_type(ctx=ctx, parent=annotation, enum=it)$}; separator="\n"$

$annotation.typeDefs : { it | $typedef_decl(ctx=ctx, parent=annotation, typedefs=it)$}; separator="\n"$

} // $annotation.name$ namespace
$endif$
>>

interface(ctx, parent, interface, export_list) ::= <<>>

export_list(exports) ::= <<>>

const_decl(ctx, parent, const, const_type) ::= <<

$const_type$

>>

fwd_decl(ctx, parent, type) ::= <<>>

typedef_decl(ctx, parent, typedefs, typedefs_type, declarator_type) ::= <<
$declarator_type$
$typedefs_type$
$get_type_identifier_impl(ctx=ctx, param=typedefs)$

$get_type_object_impl(ctx=ctx, param=typedefs)$

$get_minimal_type_object_impl(ctx=ctx, param=typedefs)$
    type_object->minimal()._d(TK_ALIAS);
    $minimal_alias_type_impl(ctx=ctx, object=typedefs)$
    type_object->minimal().alias_type($typedefs.name$_minimal_alias_type);

    $type_identifier_impl(ctx=ctx, param=typedefs, complete_discr=["EK_MINIMAL"], member=["minimal().alias_type()"], complete_flag=["false"])$
}

$get_complete_type_object_impl(ctx=ctx, param=typedefs)$
    type_object->complete()._d(TK_ALIAS);
    $complete_alias_type_impl(ctx=ctx, object=typedefs)$
    type_object->complete().alias_type($typedefs.name$_alias_type);

    $type_identifier_impl(ctx=ctx, param=typedefs, complete_discr=["EK_COMPLETE"], member=["complete().alias_type()"], complete_flag=["true"])$
}

>>

enum_type(ctx, parent, enum) ::= <<
$get_type_identifier_impl(ctx=ctx, param=enum)$

$get_type_object_impl(ctx=ctx, param=enum)$

$get_minimal_type_object_impl(ctx=ctx, param=enum)$
    type_object->minimal()._d(TK_ENUM);
    $minimal_enumerated_type_impl(ctx=ctx, object=enum)$
    type_object->minimal().enumerated_type($enum.name$_minimal_enumerated_type);

    $type_identifier_impl(ctx=ctx, param=enum, complete_discr=["EK_MINIMAL"], member=["minimal().enumerated_type()"], complete_flag=["false"])$
}

$get_complete_type_object_impl(ctx=ctx, param=enum)$
    type_object->complete()._d(TK_ENUM);
    $complete_enumerated_type_impl(ctx=ctx, object=enum)$
    type_object->complete().enumerated_type($enum.name$_complete_enumerated_type);

    $type_identifier_impl(ctx=ctx, param=enum, complete_discr=["EK_COMPLETE"], member=["complete().enumerated_type()"], complete_flag=["true"])$
}

>>

struct_type(ctx, parent, struct, extensions, member_list) ::= <<
$member_list$
$get_type_identifier_impl(ctx=ctx, param=struct)$

$get_type_object_impl(ctx=ctx, param=struct)$

$get_minimal_type_object_impl(ctx=ctx, param=struct)$
    type_object->minimal()._d(TK_STRUCTURE);
    $minimal_struct_type_impl(ctx=ctx, object=struct)$
    type_object->minimal().struct_type($struct.name$_minimal_struct_type);

    $type_identifier_impl(ctx=ctx, param=struct, complete_discr=["EK_MINIMAL"], member=["minimal().struct_type()"], complete_flag=["false"])$
}

$get_complete_type_object_impl(ctx=ctx, param=struct)$
    type_object->complete()._d(TK_STRUCTURE);
    $complete_struct_type_impl(ctx=ctx, object=struct)$
    type_object->complete().struct_type($struct.name$_complete_struct_type);

    $type_identifier_impl(ctx=ctx, param=struct, complete_discr=["EK_COMPLETE"], member=["complete().struct_type()"], complete_flag=["true"])$
}

>>

member_type(ctx, member, type_member, declarators) ::= <<

$type_member$
$declarators$

>>

union_type(ctx, parent, union, switch_type) ::= <<
$switch_type$
$get_type_identifier_impl(ctx=ctx, param=union)$

$get_type_object_impl(ctx=ctx, param=union)$

$get_minimal_type_object_impl(ctx=ctx, param=union)$
    type_object->minimal()._d(TK_UNION);
    $minimal_union_type_impl(ctx=ctx, object=union)$
    type_object->minimal().union_type($union.name$_minimal_union_type);

    $type_identifier_impl(ctx=ctx, param=union, complete_discr=["EK_MINIMAL"], member=["minimal().union_type()"], complete_flag=["false"])$
}

$get_complete_type_object_impl(ctx=ctx, param=union)$
    type_object->complete()._d(TK_UNION);
    $complete_union_type_impl(ctx=ctx, object=union)$
    type_object->complete().union_type($union.name$_complete_union_type);

    $type_identifier_impl(ctx=ctx, param=union, complete_discr=["EK_COMPLETE"], member=["complete().union_type()"], complete_flag=["true"])$
}

>>

element_type(ctx, element, type_element, declarator) ::= <<

$type_element$
$declarator$

>>

bitmask_type(ctx, parent, bitmask) ::= <<
$get_type_identifier_impl(ctx=ctx, param=bitmask)$

$get_type_object_impl(ctx=ctx, param=bitmask)$

$get_minimal_type_object_impl(ctx=ctx, param=bitmask)$
    type_object->minimal()._d(TK_BITMASK);
    $minimal_bitmask_type_impl(ctx=ctx, object=bitmask)$
    type_object->minimal().bitmask_type($bitmask.name$_minimal_bitmask_type);

    $type_identifier_impl(ctx=ctx, param=bitmask, complete_discr=["EK_MINIMAL"], member=["minimal().bitmask_type()"], complete_flag=["false"])$
}

$get_complete_type_object_impl(ctx=ctx, param=bitmask)$
    type_object->complete()._d(TK_BITMASK);
    $complete_bitmask_type_impl(ctx=ctx, object=bitmask)$
    type_object->complete().bitmask_type($bitmask.name$_complete_bitmask_type);

    $type_identifier_impl(ctx=ctx, param=bitmask, complete_discr=["EK_COMPLETE"], member=["complete().bitmask_type()"], complete_flag=["true"])$
}

>>

bitset_type(ctx, parent, bitset, extensions) ::= <<
$get_type_identifier_impl(ctx=ctx, param=bitset)$

$get_type_object_impl(ctx=ctx, param=bitset)$

$get_minimal_type_object_impl(ctx=ctx, param=bitset)$
    type_object->minimal()._d(TK_BITSET);
    $minimal_bitset_type_impl(ctx=ctx, object=bitset)$
    type_object->minimal().bitset_type($bitset.name$_minimal_bitset_type);

    $type_identifier_impl(ctx=ctx, param=bitset, complete_discr=["EK_MINIMAL"], member=["minimal().bitset_type()"], complete_flag=["false"])$
}

$get_complete_type_object_impl(ctx=ctx, param=bitset)$
    type_object->complete()._d(TK_BITSET);
    $complete_bitset_type_impl(ctx=ctx, object=bitset)$
    type_object->complete().bitset_type($bitset.name$_complete_bitset_type);

    $type_identifier_impl(ctx=ctx, param=bitset, complete_discr=["EK_COMPLETE"], member=["complete().bitset_type()"], complete_flag=["true"])$
}

>>

sequence_type(ctx, sequence, type_sequence) ::= <<

$type_sequence$

>>

map_type(ctx, map, key_type, value_type) ::= <<

$key_type$
$value_type$

>>

string_type(ctx, string) ::= <<>>

wide_string_type(ctx, wstring) ::= <<>>

array_declarator(ctx, array, array_type) ::= <<>>

/***** Utils *****/
get_type_identifier_impl(ctx, param) ::= <<
const TypeIdentifier* get_$param.name$_identifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier(
        "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$",
        complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    get_$param.name$_object(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier(
        "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$",
        complete);
}
>>

get_type_object_impl(ctx, param) ::= <<
const TypeObject* get_$param.name$_object(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object(
        "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$",
        complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return get_complete_$param.name$_object();
    }
    // else
    return get_minimal_$param.name$_object();
}
>>

get_minimal_type_object_impl(ctx, param) ::= <<
const TypeObject* get_minimal_$param.name$_object()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object(
        "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$",
        false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    // MinimalTypeObject
>>

get_complete_type_object_impl(ctx, param) ::= <<
const TypeObject* get_complete_$param.name$_object()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object(
        "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$",
        true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    // CompleteTypeObject
>>

type_identifier_impl(ctx, param, complete_discr, member, complete_flag) ::= <<
TypeIdentifier identifier;
identifier._d($complete_discr$);

eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
size_t current_alignment {0};
SerializedPayload_t payload(static_cast<uint32_t>(
    calculator.calculate_serialized_size(type_object->$member$, current_alignment) + 4));
eprosima::fastcdr::FastBuffer fastbuffer(static_cast<char*>(payload.data), payload.max_size);
// XTypes v1.3 Annex B: EquivalenceHash, first 14 bytes of MD5 of the serialized TypeObject using XCDR version 2.
eprosima::fastcdr::Cdr ser(
    fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
    eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

ser << *type_object;
payload.length = static_cast<uint32_t>(ser.get_serialized_data_length()); //Get the serialized length
MD5 objectHash;
objectHash.update(static_cast<char*>(payload.data), payload.length);
objectHash.finalize();
// XTypes v1.3 Annex B: Little Endian encoding.
for(int i = 0; i < 14; ++i)
{
    identifier.equivalence_hash()[i] = objectHash.digest[13-i];
}

TypeObjectFactory::get_instance()->add_type_object(
    "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$",
    &identifier,
    type_object);
delete type_object;
return TypeObjectFactory::get_instance()->get_type_object(
    "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$",
    $complete_flag$);
>>

string_s_type_defn_impl(ctx, object) ::= <<
// StringSTypeDefn
StringSTypeDefn $object.name$_string_s_type_defn;
// - SBound TODO(jlbueno) Collection Type
$object.name$_string_s_type_defn.bound($object.bound$);
>>

string_l_type_defn_impl(ctx, object) ::= <<
// StringLTypeDefn
StringLTypeDefn $object.name$_string_l_type_defn;
// -LBound TODO(jlbueno) Collection Type
$object.name$_string_l_type_defn.bound($object.bound$);
>>

collection_element_flag_impl(ctx, object) ::= <<
// - CollectionElementFlag: T1, T2, X
CollectionElementFlag $object.name$_collection_element_flag;
$member_flag_try_construct_impl(ctx=ctx, object=object, name=["_collection_element_flag"])$
$if(object.annotationExternal)$
$object.name$_collection_element_flag |= MemberFlagBits::IS_EXTERNAL;
$endif$
>>

plain_collection_header_impl(ctx, object) ::= <<
//PlainCollectionHeader
PlainCollectionHeader $object.name$_plain_collection_header;
// - EquivalenceKind
// TODO(jlbueno) Collection Type
$collection_element_flag_impl(ctx=ctx, object=object)$
$object.name$_plain_collection_header.element_flags($object.name$_collection_element_flag);
>>

plain_sequence_s_elem_defn_impl(ctx, object) ::= <<
// PlainSequenceSElemDefn
PlainSequenceSElemDefn $object.name$_plain_sequence_s_elem_defn;
$plain_collection_header_impl(ctx=ctx, object=object)$
$object.name$_plain_sequence_s_elem_defn.header($object.name$_plain_collection_header);
// - SBound TODO(jlbueno) Collection Type
$object.name$_plain_sequence_s_elem_defn.bound();
// - TypeIdentifier TODO(jlbueno) Collection Type
$common_member_type_id_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_plain_sequence_s_elem_defn.element_identifier($object.name$_common_member_type_id);
>>

plain_sequence_l_elem_defn_impl(ctx, object) ::= <<
// PlainSequenceLElemDefnImpl
PlainSequenceLElemDefnImpl $object.name$_plain_sequence_l_elem_defn_impl;
$plain_collection_header_impl(ctx=ctx, object=object)$
$object.name$_plain_sequence_l_elem_defn_impl.header($object.name$_plain_collection_header);
// - LBound TODO(jlbueno) Collection Type
$object.name$_plain_sequence_l_elem_defn_impl.bound();
// - TypeIdentifier TODO(jlbueno) Collection Type
$common_member_type_id_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_plain_sequence_l_elem_defn_impl.element_identifier($object.name$_common_member_type_id);
>>

plain_array_s_elem_defn_impl(ctx, object) ::= <<
// PlainArraySElemDefn
PlainArraySElemDefn $object.name$_plain_array_s_elem_defn;
$plain_collection_header_impl(ctx=ctx, object=object)$
$object.name$_plain_array_s_elem_defn.header($object.name$_plain_collection_header);
// - SBoundSeq TODO(jlbueno) Collection Type
$object.dimensions:{ dimension |
$object.name$_plain_array_s_elem_defn.array_bound_seq().push_back($dimension$);
}; separator="\n"$
// - TODO(jlbueno) Collection Type
$common_member_type_id_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_plain_array_s_elem_defn.element_identifier($object.name$_common_member_type_id);
>>

plain_array_l_elem_defn_impl(ctx, object) ::= <<
// PlainArrayLElemDefn
PlainArrayLElemDefn $object.name$_plain_array_l_elem_defn;
$plain_collection_header_impl(ctx=ctx, object=object)$
$object.name$_plain_array_l_elem_defn.header($object.name$_plain_collection_header);
// - LBoundSeq TODO(jlbueno) Collection Type
$object.dimensions:{ dimension |
$object.name$_plain_array_l_elem_defn.array_bound_seq().push_back($dimension$);
}; separator="\n"$
// - TODO(jlbueno) Collection Type
$common_member_type_id_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_plain_array_l_elem_defn.element_identifier($object.name$_common_member_type_id);
>>

plain_map_s_type_defn_impl(ctx, object) ::= <<
// PlainMapSTypeDefn
PlainMapSTypeDefn $object.name$_plain_map_s_type_defn;
$plain_collection_header_impl(ctx=ctx, object=object)$
$object.name$_plain_map_s_type_defn.header($object.name$_plain_collection_header);
// - TODO(jlbueno) Collection Type
$common_member_type_id_impl(ctx=ctx, object=object.element, complete=["false"])$
$object.name$_plain_map_s_type_defn.element_identifier($object.element.name$_common_member_type_id);
$collection_element_flag_impl(ctx=ctx, object=object.key)$
$object.name$_plain_map_s_type_defn.key_flags($object.key.name$_collection_element_flag);
$common_member_type_id_impl(ctx=ctx, object=object.key, complete=["false"])$
$object.name$_plain_map_s_type_defn.key_identifier($object.key.name$_common_member_type_id);
>>

plain_map_l_type_defn_impl(ctx, object) ::= <<
// PlainMapLTypeDefn
PlainMapLTypeDefn $object.name$_plain_map_l_type_defn;
$plain_collection_header_impl(ctx=ctx, object=object)$
$object.name$_plain_map_l_type_defn.header($object.name$_plain_collection_header);
// - TODO(jlbueno) Collection Type
$common_member_type_id_impl(ctx=ctx, object=object.element, complete=["false"])$
$object.name$_plain_map_l_type_defn.element_identifier($object.element.name$_common_member_type_id);
$collection_element_flag_impl(ctx=ctx, object=object.key)$
$object.name$_plain_map_l_type_defn.key_flags($object.key.name$_collection_element_flag);
$common_member_type_id_impl(ctx=ctx, object=object.key, complete=["false"])$
$object.name$_plain_map_l_type_defn.key_identifier($object.key.name$_common_member_type_id);
>>

/* StronglyConnectedComponentId not yet supported */

extended_annotation_parameter_value_impl(ctx, object) ::= <<
// ExtendedAnnotationParameterValue: Empty. Available for future extension.
ExtendedAnnotationParameterValue $object.name$_extended_annotation_parameter_value;
>>

annotation_parameter_value_impl(ctx, object, name, ek) ::= <<
AnnotationParameterValue $object.name$_annotation_parameter_value;
$if(object.typecode.isEnumType || !object.typecode.primitive)$
const TypeObject* $object.name$_annotation_parameter_type_ob =
    TypeObjectFactory::get_instance()->get_type_object(
        $if(object.typecode.isStringType)$"DDS::String"$else$"$object.typecode.cppTypename$"$endif$,
        $ek$);
assert(nullptr != $object.name$_annotation_parameter_type_ob);
$object.name$_annotation_parameter_value._d($object.name$_annotation_parameter_type_ob->$name$()._d())
$else$
    const TypeIdentifier* $object.name$_annotation_parameter_type_id =
        TypeObjectFactory::get_instance()->get_type_identifier(
            $if(object.typecode.isStringType)$"DDS::String"$else$"$object.typecode.cppTypename$"$endif$,
            false);
    assert(nullptr != $object.name$_annotation_parameter_type_id);
$object.name$_annotation_parameter_value._d($object.name$_annotation_parameter_type_id->_d());
$endif$
$if(object.value)$
$annotation_parameter_value_value_impl(ctx=ctx, object=object)$
$endif$
>>

annotation_parameter_value_value_impl(ctx, object) ::= <<
$if(object.typecode.primitiveType)$
$if(object.typecode.isBooleanType)$
$object.name$_annotation_parameter_value.boolean_value($object.value$);
$elseif(object.typecode.isByteType)$
$object.name$_annotation_parameter_value.byte_value($object.value$);
$elseif(object.typecode.isInt8Type)$
$object.name$_annotation_parameter_value.int8_value($object.value$);
$elseif(object.typecode.isUint8Type)$
$object.name$_annotation_parameter_value.uint8_value($object.value$);
$elseif(object.typecode.isInt16Type)$
$object.name$_annotation_parameter_value.int16_value($object.value$);
$elseif(object.typecode.isUint16Type)$
$object.name$_annotation_parameter_value.uint16_value($object.value$);
$elseif(object.typecode.isInt32Type)$
$object.name$_annotation_parameter_value.int32_value($object.value$);
$elseif(object.typecode.isUint32Type)$
$object.name$_annotation_parameter_value.uint32_value($object.value$);
$elseif(object.typecode.isInt64Type)$
$object.name$_annotation_parameter_value.int64_value($object.value$);
$elseif(object.typecode.isUint64Type)$
$object.name$_annotation_parameter_value.uint64_value($object.value$);
$elseif(object.typecode.isFloat32Type)$
$object.name$_annotation_parameter_value.float32_value($object.value$);
$elseif(object.typecode.isFloat64Type)$
$object.name$_annotation_parameter_value.float64_value($object.value$);
$elseif(object.typecode.isFloat128Type)$
$object.name$_annotation_parameter_value.float128_value($object.value$);
$elseif(object.typecode.isCharType)$
$object.name$_annotation_parameter_value.char_value($object.value$);
$elseif(object.typecode.isWCharType)$
$object.name$_annotation_parameter_value.wchar_value($object.value$);
$endif$
$elseif(object.typecode.isEnumType)$
$object.name$_annotation_parameter_value.enumerated_value($object.value$);
$elseif(object.typecode.isStringType)$
$object.name$_annotation_parameter_value.string8_value("$object.value$");
$elseif(object.typecode.isWStringType)$
$object.name$_annotation_parameter_value.string16_value("$object.value$");
$else$
$extended_annotation_parameter_value_impl(ctx=ctx, object=object)$
$object.name$_annotation_parameter_value.extended_value($object.name$_extended_annotation_parameter_value);
$endif$
>>

applied_annotation_parameter_impl(ctx, object) ::= <<
// AppliedAnnotationParameter
AppliedAnnotationParameter $object.name$_applied_annotation_parameter;
// - NameHash
$md5_hash(ctx=ctx, object=object, name=["_applied_annotation_parameter.paramname_hash()"])$
// - AnnotationParameterValue
$annotation_parameter_value_impl(ctx=ctx, object=object, name=["complete"], ek=["true"])$
$object.name$_applied_annotation_parameter.value($object.name$_annotation_parameter_value);
>>

md5_hash(ctx, object, name) ::= <<
MD5 $object.name$_hash("$object.name$");
for (int i = 0; i < 4; ++i)
{
    $object.name$$name$[i] = $object.name$_hash.digest[i];
}
>>

applied_annotation_impl(ctx, object) ::= <<
// AppliedAnnotation
AppliedAnnotation $object.name$_applied_annotation;
// - TypeIdentifier
TypeIdentifier* $object.name$_annotation_type_id = TypeObjectFactory::get_instace()::get_type_identifier(
    "$if(ctx.GenerateTypesROS2)$$object.ROS2Scopedname$$else$$object.scopedname$$endif$",
    true);
assert(nullptr != $object.name$_annotation_type_id);
$object.name$_applied_annotation.annotation_typeid(*$object.name$_annotation_type_id);
$if(object.valueList)$
// - @optional AppliedAnnotationParameterSeq
$object.valueList : { annotation_parameter |
$applied_annotation_parameter_impl(ctx=ctx, object=annotation_parameter)$
$object.name$_applied_annotation.param_seq().push_back($annotation_parameter.name$_applied_annotation_parameter);
}; separator="\n"$
$endif$
>>

applied_verbatim_annotation_impl(ctx, object) ::= <<
$if(object.valueList)$
// @optional AppliedVerbatimAnnotation
AppliedVerbatimAnnotation $object.name$_applied_verbatim_annotation;
$object.valueList : { annotation_parameter |
$if(annotation_parameter.isVerbatimPlacement)$
// string<32>
$object.name$_applied_verbatim_annotation.placement("$annotation_parameter.enumStringValue$");
$elseif(annotation_parameter.isVerbatimLanguage)$
// string<32>
$object.name$_applied_verbatim_annotation.language("$annotation_parameter.value$");
$elseif(annotation_parameter.isVerbatimText)$
// string
$object.name$_applied_verbatim_annotation.text("$annotation_parameter.value$");
$endif$
}; separator=""$
$endif$
>>

applied_builtin_member_annotation_impl(ctx, object) ::= <<
$if(object.isUnit)$
// @optional string
$object.name$_applied_builtin_member_annotation.unit("$annotation_parameter.value$");
$elseif(object.isMin)$
$applied_builtin_member_min_annotation_impl(ctx=ctx, object=object)$
$elseif(object.isMax)$
$applied_builtin_member_max_annotation_impl(ctx=ctx, object=object)$
$elseif(object.isRange)$
$if(object.valueList)$
$object.valueList : { annotation_parameter |
$if(annotation_parameter.isMin)$
$applied_builtin_member_min_annotation_impl(ctx=ctx, object=annotation_parameter)$
$elseif(annotation_parameter.isMax)$
$applied_builtin_member_max_annotation_impl(ctx=ctx, object=annotation_parameter)$
$endif$
}; separator=""$
$endif$
$elseif(object.isHashId)$
// @optional string
$object.name$_applied_builtin_member_annotation.hash_id("$annotation_parameter.value$");
$endif$
>>

applied_builtin_member_max_annotation_impl(ctx, object) ::= <<
// @optional AnnotationParameterValue
$annotation_parameter_value_impl(ctx=ctx, object=object, name=["complete"], ek=["true"])$
$object.name$_applied_builtin_member_annotation.max($object.name$_annotation_parameter_value);
>>

applied_builtin_member_min_annotation_impl(ctx, object) ::= <<
// @optional AnnotationParameterValue
$annotation_parameter_value_impl(ctx=ctx, object=object, name=["complete"], ek=["true"])$
$object.name$_applied_builtin_member_annotation.min($object.name$_annotation_parameter_value);
>>

member_flag_try_contruct_impl(ctx, object, name) ::= <<
$if(object.annotationTryConstruct)$
$if(object.annotationDiscard)$
$object.name$$name$ |= MemberFlagBits::TRY_CONSTRUCT1;
$elseif(object.annotationUseDefault)$
$object.name$$name$ |= MemberFlagBits::TRY_CONSTRUCT2;
$elseif(object.annotationTrim)$
$object.name$$name$ |= MemberFlagBits::TRY_CONSTRUCT1 | MemberFlagBits::TRY_CONSTRUCT2;
$endif$
$else$
// XTypes v1.3 Clause 7.2.2.7 The default behavior unless otherwise specified using the TryConstruct annotation is
// DISCARD
$object.name$$name$ |= MemberFlagBits::TRY_CONSTRUCT1;
$endif$
>>

common_member_type_id_impl(ctx, object, complete) ::= <<
// - TypeIdentifier
const TypeIdentifier* $object.name$_common_member_type_id =
    TypeObjectFactory::get_instance()->get_type_identifier(
        $if(object.typecode.isStringType)$"DDS::String"$else$"$object.typecode.cppTypename$"$endif$,
        $if(object.typecode.isEnumType || !object.typecode.primitive)$$complete$$else$false$endif$);
assert(nullptr != $object.name$_common_member_type_id);
>>

common_struct_member_impl(ctx, object, complete) ::= <<
// CommonStructMember
CommonStructMember $object.name$_common_struct_member;
// - MemberId
$object.name$_common_struct_member.member_id(member_id++);
// - StructMemberFlag: T1, T2, O, M, K, X
StructMemberFlag $object.name$_struct_member_flag;
$member_flag_try_contruct_impl(ctx=ctx, object=object, name=["_struct_member_flag"])$
$if(object.annotationOptional)$
$object.name$_struct_member_flag |= MemberFlagBits::IS_OPTIONAL;
$endif$
$if(object.annotationMustUnderstand)$
$object.name$_struct_member_flag |= MemberFlagBits::IS_MUST_UNDERSTAND;
$endif$
$if(object.annotationKey)$
$object.name$_struct_member_flag |= MemberFlagBits::IS_KEY;
$endif$
$if(object.annotationExternal)$
$object.name$_struct_member_flag |= MemberFlagBits::IS_EXTERNAL;
$endif$
$object.name$_common_struct_member.member_flags($object.name$_struct_member_flag);
$common_member_type_id_impl(ctx=ctx, object=object, complete=complete)$
$object.name$_common_struct_member.member_type_id(*$object.name$_common_member_type_id);
>>

complete_member_detail_impl(ctx, object) ::= <<
// CompleteMemberDetail
CompleteMemberDetail $object.name$_complete_member_detail;
// - MemberName
$object.name$_complete_member_detail.name("$object.name$");
$if(object.annotationList)$
// - @optional AppliedBuiltinMemberAnnotations
AppliedBuiltinMemberAnnotations $object.name$_applied_builtin_member_annotation;
// - @optional AppliedAnnotationSeq
$object.annotationList: { annotation |
$if(annotation.isUnit || annotation.isMin || annotation.isMax || annotation.isRange || annotation.isHashId)$
$applied_builtin_member_annotation_impl(ctx=ctx, object=annotation)$
$else$
$applied_annotation_impl(ctx=ctx, object=annotation)$
$object.name$_complete_member_detail.ann_custom().push_back($annotation.name$_applied_annotation);
$endif$
}; separator=""$
$object.name$_complete_member_detail.ann_builtin($object.name$_applied_builtin_member_annotation);
$endif$
>>

minimal_member_detail_impl(ctx, object) ::= <<
// MinimalMemberDetail
MinimalMemberDetail $object.name$_minimal_member_detail;
// - NameHash
$md5_hash(ctx=ctx, object=object, name=["_minimal_member_detail.name_hash()"])$
>>

complete_struct_member_impl(ctx, object) ::= <<
// CompleteStructMember
CompleteStructMember $object.name$_complete_struct_member;
$common_struct_member_impl(ctx=ctx, object=object, complete=["true"])$
$object.name$_complete_struct_member.common($object.name$_common_struct_member);
$complete_member_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_struct_member.detail($object.name$_complete_member_detail);
>>

minimal_struct_member_impl(ctx, object) ::= <<
// MinimalStructMember
MinimalStructMember $object.name$_minimal_struct_member;
$common_struct_member_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_minimal_struct_member.common($object.name$_common_struct_member);
$minimal_member_detail_impl(ctx=ctx, object=object)$
$object.name$_minimal_struct_member.detail($object.name$_minimal_member_detail);
>>

applied_builtin_type_annotations_impl(ctx, object) ::= <<
AppliedBuiltinTypeAnnotations $object.name$_applied_builtin_type_annotations;
$applied_verbatim_annotation_impl(ctx=ctx, object=object)$
$object.name$_applied_builtin_type_annotations.verbatim($object.name$_applied_verbatim_annotation);
>>

minimal_type_detail_impl(ctx, object) ::= <<
// MinimalTypeDetail: Empty. Available for future extension
MinimalTypeDetail $object.name$_minimal_type_detail;
>>

applied_annotations_impl(ctx, object, name) ::= <<
$if(object.annotationList)$
// - @optional AppliedAnnotationSeq
$object.annotationList: { annotation |
$if(annotation.isVerbatim)$
// - @optional AppliedBuiltinTypeAnnotations
$applied_builtin_type_annotations_impl(ctx=ctx, object=annotation)$
$object.name$$name$.ann_builtin($annotation.name$_applied_builtin_type_annotations);
$else$
$applied_annotation_impl(ctx=ctx, object=annotation)$
$object.name$$name$.ann_custom().push_back($annotation.name$_applied_annotation);
$endif$
}; separator=""$
$endif$
>>

complete_type_detail_impl(ctx, object) ::= <<
// CompleteTypeDetail
CompleteTypeDetail $object.name$_complete_type_detail;
$applied_annotations_impl(ctx=ctx, object=object, name=["_complete_type_detail"])$
// - QualifiedTypeName
$object.name$_complete_type_detail.type_name(
    "$if(ctx.GenerateTypesROS2)$$object.ROS2Scopedname$$else$$object.scopedname$$endif$");
>>

complete_struct_header_impl(ctx, object) ::= <<
// CompleteStructHeader
CompleteStructHeader $object.name$_complete_struct_header;
// - TypeIdentifier
$if(object.inheritance)$
TypeIdentifier* $object.inheritance.name$_type_id = TypeObjectFactory::get_instace()::get_type_identifier(
    "$if(ctx.GenerateTypesROS2)$$object.inheritance.ROS2Scopedname$$else$$object.inheritance.scopedname$$endif$",
    true);
assert(nullptr != $object.inheritance.name$_type_id);
$object.name$_complete_struct_header.base_type(*$object.inheritance.name$_type_id);
$endif$

$complete_type_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_struct_header.detail($object.name$_complete_type_detail);
>>

minimal_struct_header_impl(ctx, object) ::= <<
// MinimalStructHeader
MinimalStructHeader $object.name$_minimal_struct_header;
// - TypeIdentifier
$if(object.inheritance)$
TypeIdentifier* $object.inheritance.name$_type_id = TypeObjectFactory::get_instace()::get_type_identifier(
    "$if(ctx.GenerateTypesROS2)$$object.inheritance.ROS2Scopedname$$else$$object.inheritance.scopedname$$endif$",
    false);
assert(nullptr != $object.inheritance.name$_type_id);
$object.name$_minimal_struct_header.base_type(*$object.inheritance.name$_type_id);
$endif$

$minimal_type_detail_impl(ctx=ctx, object=object)$
$object.name$_minimal_struct_header.detail($object.name$_minimal_type_detail);
>>

type_flag_impl(ctx, object, name) ::= <<
$if(object.annotationFinal)$
$object.name$$name$ |= TypeFlagBits::IS_FINAL;
$elseif(object.annotationAppendable)$
$object.name$$name$ |= TypeFlagBits::IS_APPENDABLE;
$elseif(object.annotationMutable)$
$object.name$$name$ |= TypeFlagBits::IS_MUTABLE;
$endif$
$if(object.annotationNested)$
$object.name$$name$ |= TypeFlagBits::IS_NESTED;
$endif$
$if(object.annotationAutoidHash)$
$object.name$$name$ |= TypeFlagBits::IS_AUTOID_HASH;
$endif$
>>

complete_struct_type_impl(ctx, object) ::= <<
// CompleteStructType
CompleteStructType $object.name$_complete_struct_type;
// - StructTypeFlag
StructTypeFlag $object.name$_struct_type_flag;
$type_flag_impl(ctx=ctx, object=object, name=["_struct_type_flag"])$
$object.name$_complete_struct_type.struct_flags($object.name$_struct_type_flag);
$complete_struct_header_impl(ctx=ctx, object=object)$
$object.name$_complete_struct_type.header($object.name$_complete_struct_header);
$if(object.members)$
// - CompleteStructMemberSeq

MemberId member_id = 0;
$object.members:{ member |
$complete_struct_member_impl(ctx=ctx, object=member)$
$object.name$_complete_struct_type.member_seq().push_back($member.name$_complete_struct_member);
}; separator="\n"$
$endif$
>>

minimal_struct_type_impl(ctx, object) ::= <<
// MinimalStructType
MinimalStructType $object.name$_minimal_struct_type;
// - StructTypeFlag
StructTypeFlag $object.name$_struct_type_flag;
$type_flag_impl(ctx=ctx, object=object, name=["_struct_type_flag"])$
$object.name$_minimal_struct_type.struct_flags($object.name$_struct_type_flag);
$minimal_struct_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_struct_type.header($object.name$_minimal_struct_header);
$if(object.members)$
// - MinimalStructMemberSeq

MemberId member_id = 0;
$object.members:{ member |
$minimal_struct_member_impl(ctx=ctx, object=member)$
$object.name$_minimal_struct_type.member_seq().push_back($member.name$_minimal_struct_member);
}; separator="\n"$
$endif$
>>

common_union_member_impl(ctx, object, complete) ::= <<
// CommonUnionMember
CommonUnionMember $object.name$_common_union_member;
// - MemberId
$object.name$_common_union_member.member_id(member_id++);
// - UnionMemberFlag: T1, T2, D, X
UnionMemberFlag $object.name$_union_member_flag;
$member_flag_try_contruct_impl(ctx=ctx, object=object, name=["_union_member_flag"])$
$if(object.annotationExternal)$
$object.name$_union_member_flag |= MemberFlagBits::IS_EXTERNAL;
$endif$
$if(object.annotationDefaultLiteral)$
$object.name$_union_member_flag = MemberFlagBits::IS_DEFAULT;
$endif$
$object.name$_common_union_member.member_flags($object.name$_union_member_flag);
$common_member_type_id_impl(ctx=ctx, object=object, complete=complete)$
$object.name$_common_struct_member.member_type_id(*$object.name$_common_member_type_id);
$if(object.labels)$
// - UnionCaseLabelSeq
$object.labels:{ label | $object.name$.common_union_member.label_seq().emplace_back($label$);}; separator="\n"$
$endif$
>>

complete_union_member_impl(ctx, object) ::= <<
// CompleteUnionMember
CompleteUnionMember $object.name$_complete_union_member;
$common_union_member_impl(ctx=ctx, object=object, complete=["true"])$
$object.name$_complete_union_member.common($object.name$_common_union_member);
$complete_member_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_union_member.detail($object.name$_complete_member_detail);
>>

minimal_union_member_impl(ctx, object) ::= <<
// MinimalUnionMember
MinimalUnionMember $object.name$_minimal_union_member;
$common_union_member_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_minimal_union_member.common($object.name$_common_union_member);
$minimal_member_detail_impl(ctx=ctx, object=object)$
$object.name$_minimal_union_member.detail($object.name$_minimal_member_detail);
>>

common_discriminator_member_impl(ctx, object, complete) ::= <<
// CommonDiscriminatorMember
CommonDiscriminatorMember $object.name$_common_discriminator_member;
// - UnionDiscriminatorFlag: T1, T2, K
UnionDiscriminatorFlag $object.name$_union_member_flag;
$member_flag_try_contruct_impl(ctx=ctx, object=object, name=["_union_member_flag"])$
$if(object.annotationKey)$
$object.name$_union_member_flag |= MemberFlagBits::IS_KEY;
$endif$
$object.name$_common_discriminator_member.member_flags($object.name$_union_member_flag);
$common_member_type_id_impl(ctx=ctx, object=object, complete=complete)$
$object.name$_common_discriminator_member.member_type_id(*$object.name$_common_member_type_id);
>>

complete_discriminator_member_impl(ctx, object) ::= <<
// CompleteDiscriminatorMember
CompleteDiscriminatorMember $object.name$_complete_discriminator_member;
$common_discriminator_member_impl(ctx=ctx, object=object, complete=["true"])$
$object.name$_complete_discriminator_member.common($object.name$_common_discriminator_member);
$applied_annotations_impl(ctx=ctx, object=object, name=["_complete_discriminator_member"])$
>>

minimal_discriminator_member_impl(ctx, object) ::= <<
// MinimalDiscriminatorMember
MinimalDiscriminatorMember $object.name$_minimal_discriminator_member;
$common_discriminator_member_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_minimal_discriminator_member.common($object.name$_common_discriminator_member);
>>

complete_union_header_impl(ctx, object) ::= <<
// CompleteUnionHeader
CompleteUnionHeader $object.name$_complete_union_header;
$complete_type_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_union_header.detail($object.name$_complete_type_detail);
>>

minimal_union_header_impl(ctx, object) ::= <<
// MinimalUnionHeader
MinimalUnionHeader $object.name$_minimal_union_header;
$minimal_type_detail_impl(ctx=ctx, object=object)$
$object.name$_minimal_union_header.detail($object.name$_minimal_type_detail);
>>

complete_union_type_impl(ctx, object) ::= <<
// CompleteUnionType
CompleteUnionType $object.name$_complete_union_type;
// - UnionTypeFlag
UnionTypeFlag $object.name$_union_type_flag;
$type_flag_impl(ctx=ctx, object=object, name=["_union_type_flag"])$
$object.name$_complete_union_type.union_flags($object.name$_union_type_flag);
$complete_union_header_impl(ctx=ctx, object=object)$
$object.name$_complete_union_type.header($object.name$_complete_union_header);
$complete_discriminator_member_impl(ctx=ctx, object=object)$
$object.name$_complete_union_type.discriminator($object.name$_complete_discriminator_member);
$if(object.members)$
// - CompleteUnionMemberSeq

MemberId member_id = 0;
$object.members:{ member |
$complete_union_member_impl(ctx=ctx, object=member)$
$object.name$_complete_union_type.member_seq().push_back($member.name$_complete_union_member);
}; separator="\n"$
$endif$
>>

minimal_union_type_impl(ctx, object) ::= <<
// MinimalUnionType
MinimalUnionType $object.name$_minimal_union_type;
// - UnionTypeFlag
UnionTypeFlag $object.name$_union_type_flag;
$type_flag_impl(ctx=ctx, object=object, name=["_union_type_flag"])$
$object.name$_minimal_union_type.union_flags($object.name$_union_type_flag);
$minimal_union_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_union_type.header($object.name$_minimal_union_header);
$minimal_discriminator_member_impl(ctx=ctx, object=object)$
$object.name$_minimal_union_type.discriminator($object.name$_minimal_discriminator_member);
$if(object.members)$
// - MinimalUnionMemberSeq

MemberId member_id = 0;
$object.members:{ member |
$minimal_union_member_impl(ctx=ctx, object=member)$
$object.name$_minimal_union_type.member_seq().push_back($member.name$_minimal_union_member);
}; separator="\n"$
$endif$
>>

common_annotation_parameter_impl(ctx, object, complete) ::= <<
// CommonAnnotationParameter
CommonAnnotationParameter $object.name$_common_annotation_parameter;
// - AnnotationParameterFlag: Unused. No flags apply
// - TypeIdentifier
const TypeIdentifier* $object.name$_common_annotation_parameter_type_id =
    TypeObjectFactory::get_instance()->get_type_identifier(
        $if(object.typecode.isStringType)$"DDS::String"$else$"$object.typecode.cppTypename$"$endif$,
        $if(object.typecode.isEnumType || !object.typecode.primitive)$$complete$$else$false$endif$);
assert(nullptr != $object.name$_common_annotation_parameter_type_id);
$object.name$_common_annotation_parameter.member_type_id(*$object.name$_common_annotation_parameter_type_id);
>>

complete_annotation_parameter_impl(ctx, object) ::= <<
// CompleteAnnotationParameter
CompleteAnnotationParameter $object.name$_complete_annotation_parameter;
$common_annotation_parameter_impl(ctx=ctx, object=object, complete=["true"])$
$object.name$_complete_annotation_parameter.common($object.name$_common_annotation_parameter);
// - MemberName
$object.name$_complete_annotation_parameter.name("$object.name$");
// - AnnotationParameterValue
$annotation_parameter_value_impl(ctx=ctx, object=object, name=["complete"], ek=["true"])$
$object.name$_complete_annotation_parameter.default_value($object.name$_annotation_parameter_value);
>>

minimal_annotation_parameter_impl(ctx, object) ::= <<
// MinimalAnnotationParameter
MinimalAnnotationParameter $object.name$_minimal_annotation_parameter;
$common_annotation_parameter_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_minimal_annotation_parameter.common($object.name$_common_annotation_parameter);
// - NameHash
$md5_hash(ctx=ctx, object=object, name=["_minimal_annotation_parameter.name_hash()"])$
// - AnnotationParameterValue
$annotation_parameter_value_impl(ctx=ctx, object=object, name=["minimal"], ek=["false"])$
$object.name$_minimal_annotation_parameter.default_value($object.name$_annotation_parameter_value);
>>

complete_annotation_header_impl(ctx, object) ::= <<
// CompleteAnnotationHeader
CompleteAnnotationHeader $object.name$_complete_annotation_header;
// - QualifiedTypeName
$object.name$_complete_annotation_header.annotation_name(
    "$if(ctx.GenerateTypesROS2)$$annotation.ROS2Scopedname$$else$$annotation.scopedname$$endif$");
>>

minimal_annotation_header_impl(ctx, object) ::= <<
// MinimalAnnotationHeader: Empty. Available for future extension.
MinimalAnnotationHeader $object.name$_minimal_annotation_header;
>>

complete_annotation_type_impl(ctx, object) ::= <<
// CompleteAnnotationType
CompleteAnnotationType $object.name$_complete_annotation_type;
// - AnnotationTypeFlag: unused. No flags apply.
$complete_annotation_header_impl(ctx=ctx, object=object)$
$object.name$_complete_annotation_type.header($object.name$_complete_annotation_header);
// - CompleteAnnotationParameterSeq

$object.members:{ member |
$complete_annotation_parameter_impl(ctx=ctx, object=member)$
$object.name$_complete_annotation_type.member_seq().push_back($member.name$_complete_annotation_parameter);
}; separator="\n"$
>>

minimal_annotation_type_impl(ctx, object) ::= <<
// MinimalAnnotationType
MinimalAnnotationType $object.name$_minimal_annotation_type;
// - AnnotationTypeFlag: unused. No flags apply.
$minimal_annotation_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_annotation_type.header($object.name$_minimal_annotation_header);
// - MinimalAnnotationParameterSeq

$object.members:{ member |
$minimal_annotation_parameter_impl(ctx=ctx, object=member)$
$object.name$_minimal_annotation_type.member_seq().push_back($member.name$_minimal_annotation_parameter);
}; separator="\n"$
>>

common_alias_body_impl(ctx, object, complete) ::= <<
// CommonAliasBody
CommonAliasBody $object.name$_common_alias_body;
// - AliasMemberFlag: unused. No flags apply.
// - TypeIdentifier
$common_member_type_id_impl(ctx=ctx, object=object, complete=complete)$
$object.name$_common_alias_body.related_type($object.name$_common_member_type_id);
>>

complete_alias_body_impl(ctx, object) ::= <<
// CompleteAliasBody
CompleteAliasBody $object.name$_complete_alias_body;
$common_alias_body_impl(ctx=ctx, object=object, complete=["true"])$
$object.name$_complete_alias_body.common($object.name$_common_alias_body);
$applied_annotations_impl(ctx=ctx, object=object, name=["_complete_alias_body"])$
>>

minimal_alias_body_impl(ctx, object) ::= <<
// MinimalAliasBody
MinimalAliasBody $object.name$_minimal_alias_body;
$common_alias_body_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_minimal_alias_body.common($object.name$_common_alias_body);
>>

complete_alias_header_impl(ctx, object) ::= <<
// CompleteAliasHeader
CompleteAliasHeader $object.name$_complete_alias_header;
$complete_type_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_alias_header.detail($object.name$_complete_type_detail);
>>

minimal_alias_header_impl(ctx, object) ::= <<
// MinimalAliasHeader: Empty. Available for future extension
MinimalAliasHeader $object.name$_minimal_alias_header;
>>

complete_alias_type_impl(ctx, object) ::= <<
// CompleteAliasType
CompleteAliasType $object.name$_complete_alias_type;
// - AliasTypeFlag: Unused. No flags apply
$complete_alias_header_impl(ctx=ctx, object=object)$
$object.name$_complete_alias_type.header($object.name$_complete_alias_header);
$complete_alias_body_impl(ctx=ctx, object=object)$
$object.name$_complete_alias_type.body($object.name$_complete_alias_body);
>>

minimal_alias_type_impl(ctx, object) ::= <<
// MinimalAliasType
MinimalAliasType $object.name$_minimal_alias_type;
// - AliasTypeFlag: Unused. No flags apply
$minimal_alias_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_alias_type.header($object.name$_minimal_alias_header);
$minimal_alias_body_impl(ctx=ctx, object=object)$
$object.name$_minimal_alias_type.body($object.name$_minimal_alias_body);
>>

complete_element_detail_impl(ctx, object) ::= <<
// CompleteElementDetail
CompleteElementDetail $object.name$_complete_element_detail;
$applied_annotations_impl(ctx=ctx, object=object, name=["_complete_element_detail"])$
>>

common_collection_element_impl(ctx, object, complete) ::= <<
// CommonCollectionElement
CommonCollectionElement $object.name$_common_collection_element;
$collection_element_flag_impl(ctx=ctx, object=object)$
$object.name$_common_collection_element.element_flags($object.name$_collection_element_flag);
$common_member_type_id_impl(ctx=ctx, object=object, complete=complete)$
$object.name$_common_collection_element.type(*$object.name$_common_member_type_id);
>>

complete_collection_element_impl(ctx, object) ::= <<
// CompleteCollectionElement
CompleteCollectionElement $object.name$_complete_collection_element;
$common_collection_element_impl(ctx=ctx, object=object, complete=["true"])$
$object.name$_complete_collection_element.common($object.name$_common_collection_element);
$complete_element_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_collection_element.detail($object.name$_complete_element_detail);
>>

minimal_collection_element_impl(ctx, object) ::= <<
// MinimalCollectionElement
MinimalCollectionElement $object.name$_minimal_collection_element;
$common_collection_element_impl(ctx=ctx, object=object, complete=["false"])$
$object.name$_minimal_collection_element.common($object.name$_common_collection_element);
>>

common_collection_header_impl(ctx, object) ::= <<
// CommonCollectionHeader
CommonCollectionHeader $object.name$_common_collection_header;
// - LBound: TODO(jlbueno) Collection types
$object.name$_common_collection_header.bound();
>>

complete_collection_header_impl(ctx, object) ::= <<
// CompleteCollectionHeader
CompleteCollectionHeader $object.name$_complete_collection_header;
$common_collection_header_impl(ctx=ctx, object=object)$
$object.name$_complete_collection_header.common($object.name$_common_collection_header);
// TODO(jlbueno) Collection Types
$if(object.name)$
// - @optional: not present for anonymous
$complete_type_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_collection_header.detail($object.name$_complete_type_detail);
$endif$
>>

minimal_collection_header_impl(ctx, object) ::= <<
// MinimalCollectionHeader
MinimalCollectionHeader $object.name$_minimal_collection_header;
$common_collection_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_collection_header.common($object.name$_common_collection_header);
>>

complete_sequence_type_impl(ctx, object) ::= <<
// CompleteSequenceType
CompleteSequenceType $object.name$_complete_sequence_type;
// - CollectionTypeFlag: Unused. No flags apply
$complete_collection_header_impl(ctx=ctx, object=object)$
$object.name$_complete_sequence_type.header($object.name$_complete_collection_header);
$complete_collection_element_impl(ctx=ctx, object=object)$
$object.name$_complete_sequence_type.element($object.name$_complete_collection_element);
>>

minimal_sequence_type_impl(ctx, object) ::= <<
// MinimalSequenceType
MinimalSequenceType $object.name$_minimal_sequence_type;
// - CollectionTypeFlag: Unused. No flags apply
$minimal_collection_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_sequence_type.header($object.name$_minimal_collection_header);
$minimal_collection_element_impl(ctx=ctx, object=object)$
$object.name$_minimal_sequence_type.element($object.name$_minimal_collection_element);
>>

common_array_header_impl(ctx, object) ::= <<
// CommonArrayHeader
CommonArrayHeader $object.name$_common_array_header;
// - LBoundSeq: TODO(jlbueno) Collection Types
$object.dimensions:{ dimension |
$object.name$_common_array_header.bound_seq().push_back($dimension$);
}; separator="\n"$
>>

complete_array_header_impl(ctx, object) ::= <<
// CompleteArrayHeader
CompleteArrayHeader $object.name$_complete_array_header;
$common_array_header_impl(ctx=ctx, object=object)$
$object.name$_complete_array_header.common($object.name$_common_array_header);
$complete_type_detail(ctx=ctx, object=object)$
$object.name$_complete_array_header.detail($object.name$_complete_type_detail);
>>

minimal_array_header_impl(ctx, object) ::= <<
// MinimalArrayHeader
MinimalArrayHeader $object.name$_minimal_array_header;
$common_array_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_array_header.common($object.name$_common_array_header);
>>

complete_array_type_impl(ctx, object) ::= <<
// CompleteArrayType
CompleteArrayType $object.name$_complete_array_type;
// - CollectionTypeFlag: Unused. No flags apply
$complete_array_header_impl(ctx=ctx, object=object)$
$object.name$_complete_array_type.header($object.name$_complete_array_header);
$complete_collection_element_impl(ctx=ctx, object=object)$
$object.name$_complete_array_type.element($object.name$_complete_collection_element);
>>

minimal_array_type_impl(ctx, object) ::= <<
// MinimalArrayType
MinimalArrayType $object.name$_minimal_array_type;
// - CollectionTypeFlag: Unused. No flags apply
$minimal_array_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_array_type.header($object.name$_minimal_array_header);
$minimal_collection_element_impl(ctx=ctx, object=object)$
$object.name$_minimal_array_type.element($object.name$_minimal_collection_element);
>>

complete_map_type_impl(ctx, object) ::= <<
// CompleteMapType
CompleteMapType $object.name$_complete_map_type;
// - CollectionTypeFlag: Unused. No flags apply
$complete_collection_header_impl(ctx=ctx, object=object)$
$object.name$_complete_map_type.header($object.name$_complete_collection_header);
// TODO(jlbueno) Collection Type
$complete_collection_element_impl(ctx=ctx, object=object.key)$
$object.name$_complete_map_type.key($object.key.name$_complete_collection_element);
$complete_collection_element_impl(ctx=ctx, object=object.element)$
$object.name$_complete_map_type.element($object.element.name$_complete_collection_element);
>>

minimal_map_type_impl(ctx, object) ::= <<
// MinimalMapType
MinimalMapType $object.name$_minimal_map_type;
// - CollectionTypeFlag: Unused. No flags apply
$minimal_collection_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_map_type.header($object.name$_minimal_collection_header);
// TODO(jlbueno) Collection Type
$minimal_collection_element_impl(ctx=ctx, object=object.key)$
$object.name$_minimal_map_type.key($object.key.name$_minimal_collection_element);
$minimal_collection_element_impl(ctx=ctx, object=object.element)$
$object.name$_minimal_map_type.element($object.element.name$_minimal_collection_element);
>>

common_enumerated_literal_impl(ctx, object) ::= <<
// CommonEnumeratedLiteral
CommonEnumeratedLiteral $object.name$_common_enumerated_literal;
// - long: value
$object.name$_common_enumerated_literal.value(value++);
// - EnumeratedLiteralFlag: IS_DEFAULT (D) flag
$if(object.annotationDefaultLiteral)$
EnumeratedLiteralFlag $object.name$_enumerated_literal_flag = MemberFlagBits::IS_DEFAULT;
$object.name$_common_enumerated_literal.flags($object.name$_enumerated_literal_flag);
$endif$
>>

complete_enumerated_literal_impl(ctx, object) ::= <<
// CompleteEnumeratedLiteral
CompleteEnumeratedLiteral $object.name$_complete_enumerated_literal;
$common_enumerated_literal_impl(ctx=ctx, object=object)$
$object.name$_complete_enumerated_literal.common($object.name$_common_enumerated_literal);
$complete_member_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_enumerated_literal.detail($object.name$_complete_member_detail);
>>

minimal_enumerated_literal_impl(ctx, object) ::= <<
// MinimalEnumeratedLiteral
MinimalEnumeratedLiteral $object.name$_minimal_enumerated_literal;
$common_enumerated_literal_impl(ctx=ctx, object=object)$
$object.name$_minimal_enumerated_literal.common($object.name$_common_enumerated_literal);
$minimal_member_detail_impl(ctx=ctx, object=object)$
$object.name$_minimal_enumerated_literal.detail($object.name$_minimal_member_detail);
>>

common_enumerated_header_impl(ctx, object) ::= <<
// CommonEnumeratedHeader
CommonEnumeratedHeader $object.name$_common_enumerated_header;
// - BitBound
$if(object.isEnumType)$
// TODO: XTypes v1.3 Clause 7.3.1.2.1.5 Prior to this specification, it was impossible to indicate that objects of
//       enumerated types could be stored using an integer size other than 32 bits. This specification uses the
//       @bit_bound annotation defined in Sub Clause 8.3.4.1 of [IDL] for this purpose.
//       It is important to note that the value member of the annotation may take any value from 1 to 32, inclusive,
//       when this annotation is applied to an enumerated type.
$object.name$_common_enumerated_header.bit_bound(32);
$elseif(object.isBitmaskType)$
$object.name$_common_enumerated_header.bit_bound($object.bitBound$);
$endif$
>>

complete_enumerated_header_impl(ctx, object) ::= <<
// CompleteEnumeratedHeader
CompleteEnumeratedHeader $object.name$_complete_enumerated_header;
$common_enumerated_header_impl(ctx=ctx, object=object)$
$object.name$_complete_enumerated_header.common($object.name$_common_enumerated_header);
$complete_type_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_enumerated_header.detail($object.name$_complete_type_detail);
>>

minimal_enumerated_header_impl(ctx, object) ::= <<
// MinimalEnumeratedHeader
MinimalEnumeratedHeader $object.name$_minimal_enumerated_header;
$common_enumerated_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_enumerated_header.common($object.name$_common_enumerated_header);
>>

complete_enumerated_type_impl(ctx, object) ::= <<
// CompleteEnumeratedType
CompleteEnumeratedType $object.name$_complete_enumerated_type;
// - EnumTypeFlag: Unused. No flags apply
$complete_enumerated_header_impl(ctx=ctx, object=object)$
$object.name$_complete_enumerated_type.header($object.name$_complete_enumerated_header);
// - CompleteEnumeratedLiteralSeq

uint32_t value = 0;
$enum.members:{ member |
$complete_enumerated_literal_impl(ctx=ctx, object=member)$
$object.name$_complete_enumerated_type.literal_seq().push_back($member.name$_complete_enumerated_literal);
}; separator="\n"$
>>

minimal_enumerated_type_impl(ctx, object) ::= <<
// MinimalEnumeratedType
MinimalEnumeratedType $object.name$_minimal_enumerated_type;
// - EnumTypeFlag: Unused. No flags apply
$minimal_enumerated_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_enumerated_type.header($object.name$_minimal_enumerated_header);
// - MinimalEnumeratedLiteralSeq

uint32_t value = 0;
$enum.members:{ member |
$minimal_enumerated_literal_impl(ctx=ctx, object=member)$
$object.name$_minimal_enumerated_type.literal_seq().push_back($member.name$_minimal_enumerated_literal);
}; separator="\n"$
>>

common_bitflag_impl(ctx, object) ::= <<
// CommonBitflag
CommonBitflag $object.name$_common_bitflag;
// - unsigned short: position
$object.name$_common_bitflag.position($object.position$);
// - BitflagFlag: unused. No flags apply
>>

complete_bitflag_impl(ctx, object) ::= <<
// CompleteBitflag
CompleteBitflag $object.name$_complete_bitflag;
$common_bitflag_impl(ctx=ctx, object=object)$
$object.name$_complete_bitflag.common($object.name$_common_bitflag);
$complete_member_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_bitflag.detail($object.name$_complete_member_detail);
>>

minimal_bitflag_impl(ctx, object) ::= <<
// MinimalBitflag
MinimalBitflag $object.name$_minimal_bitflag;
$common_bitflag_impl(ctx=ctx, object=object)$
$object.name$_minimal_bitflag.common($object.name$_common_bitflag);
$minimal_member_detail_impl(ctx=ctx, object=object)$
$object.name$_minimal_bitflag.detail($object.name$_minimal_member_detail);
>>

/* CommonBitmaskHeader is not included as it is not used by any other type */

complete_bitmask_type_impl(ctx, object) ::= <<
// CompleteBitmaskType
CompleteBitmaskType $object.name$_complete_bitmask_type;
// - BitmaskTypeFlag: Unused. No flags apply
// - CompleteBitmaskHeader: CompleteEnumeratedHeader
$complete_enumerated_header_impl(ctx=ctx, object=object)$
$object.name$_complete_bitmask_type.header($object.name$_complete_enumerated_header);
// - CompleteBitflagSeq

$bitmask.members:{ member |
$complete_bitflag_impl(ctx=ctx, object=member)$
$object.name$_complete_bitmask_type.flag_seq().push_back($member.name$_complete_bitflag);
}; separator="\n"$
>>

minimal_bitmask_type_impl(ctx, object) ::= <<
// MinimalBitmaskType
MinimalBitmaskType $object.name$_minimal_bitmask_type;
// - BitmaskTypeFlag: Unused. No flags apply
// - MinimalBitmaskHeader: MinimalEnumeratedHeader
$minimal_enumerated_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_bitmask_type.header($object.name$_minimal_enumerated_header);
//    - MinimalBitflagSeq

$bitmask.bitmasks:{ member |
$minimal_bitflag_impl(ctx=ctx, object=member)$
$object.name$_minimal_bitmask_type.flag_seq().push_back($member.name$_minimal_bitflag)
}; separator="\n"$
>>

common_bitfield_impl(ctx, object) ::= <<
// CommonBitfield
CommonBitfield $object.name$_common_bitfield;
// - unsigned short: position
$object.name$_common_bitfield.position($object.basePosition$);
// - BitsetMemberFlag: Unused. No flags apply
// - octet: bitcount
$object.name$_common_bitfield.bitcount($object.spec.bitSize$);
// - TypeKind
$object.name$_common_bitfield.holder_type($object.spec.typecode.typeIdentifier$);
>>

complete_bitfield_impl(ctx, object) ::= <<
// CompleteBitfield
CompleteBitfield $object.name$_complete_bitfield;
$common_bitfield_impl(ctx=ctx, object=object)$
$object.name$_complete_bitfield.common($object.name$_common_bitfield);
$complete_member_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_bitfield.detail($object.name$_complete_member_detail);
>>

minimal_bitfield_impl(ctx, object) ::= <<
// MinimalBitfield
MinimalBitfield $object.name$_minimal_bitfield;
$common_bitfield_impl(ctx=ctx, object=object)$
$object.name$_minimal_bitfield.common($object.name$_common_bitfield);
// - Name Hash
$md5_hash(ctx=ctx, object=object, name=["_minimal_bitfield.name_hash()"])$
>>

complete_bitset_header_impl(ctx, object) ::= <<
// CompleteBitsetHeader
CompleteBitsetHeader $object.name$_complete_bitset_header;
$complete_type_detail_impl(ctx=ctx, object=object)$
$object.name$_complete_bitset_header.detail($object.name$_complete_type_detail);
>>

minimal_bitset_header_impl(ctx, object) ::= <<
// MinimalBitsetHeader: Empty. Available for future extension
MinimalBitsetHeader $object.name$_minimal_bitset_header;
>>

complete_bitset_type_impl(ctx, object) ::= <<
// CompleteBitsetType
CompleteBitsetType $object.name$_complete_bitset_type;
// - BitsetTypeFlag: Unused. No flags apply
$complete_bitset_header_impl(ctx=ctx, object=object)$
$object.name$_complete_bitset_type.header($object.name$_complete_bitset_header);
$if(object.bitfields)$
// - CompleteBitfieldSeq

$object.bitfields:{ bitfield |
$complete_bitfield_impl(ctx=ctx, object=bitfield)$
$object.name$_complete_bitset_type.field_seq().push_back($bitfield.name$_complete_bitfield);
}; separator="\n"$
$endif$
>>

minimal_bitset_type_impl(ctx, object) ::= <<
// MinimalBitsetType
MinimalBitsetType $object.name$_minimal_bitset_type;
// - BitsetTypeFlag: Unused. No flags apply
$minimal_bitset_header_impl(ctx=ctx, object=object)$
$object.name$_minimal_bitset_type.header($object.name$_minimal_bitset_header);
$if(object.bitfields)$
// - MinimalBitfieldSeq

$object.bitfields:{ bitfield |
$minimal_bitfield_impl(ctx=ctx, object=bitfield)$
$object.name$_minimal_bitset_type.field_seq().push_back($bitfield.name$_minimal_bitfield);
}; separator="\n"$
$endif$
>>
