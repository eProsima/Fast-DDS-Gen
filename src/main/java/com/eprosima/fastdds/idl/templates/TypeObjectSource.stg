// Copyright 2019 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group TypeObjectSource;

import "eprosima.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx, file=[ctx.filename, "TypeObject.cpp"], description=["This source file contains the TypeObject definition of the described types in the IDL file."])$

/* *INDENT-OFF* */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
} // namespace
#endif // _WIN32

#include "$ctx.filename$TypeObject.h"

#include <mutex>

$if(ctx.cdr)$
#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>

$endif$
#include <fastcdr/FastBuffer.h>
$if(ctx.fastcdr)$
#include <fastcdr/FastCdr.h>

$endif$
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/utils/md5.h>

#include "$ctx.filename$.h"

using namespace eprosima::fastrtps::rtps;

void register$ctx.filename$Types()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory* factory = TypeObjectFactory::get_instance();
                $ctx.definitions: { def | $register_type(ctx=ctx, object=def)$}; separator="\n"$
            });
}

$definitions; separator="\n"$

/* *INDENT-ON* */

>>

register_type(ctx, object) ::= <<
$if(!object.isModule)$
$if(!object.isConstDeclaration)$
// TypeObject is registered internally if not previously registered into TypeObjectFactory
$if(object.hasScope)$$object.scope$::$endif$get_$object.name$_identifier(true);
$if(object.hasScope)$$object.scope$::$endif$get_$object.name$_identifier(false);
$if(object.isAnnotation)$
{
    using namespace $object.name$;
    $register_annotation_types(object)$
}
$endif$
$endif$
$endif$
>>

register_annotation_types(annotation) ::= <<

$annotation.enums : { it | $register_annotation_enum(it)$}; separator="\n"$

$annotation.typeDefs : { it | $register_annotation_typedef(it)$}; separator="\n"$

>>

register_annotation_enum(enum) ::= <<
$if(enum.hasScope)$$enum.scope$::$endif$get_$enum.name$_identifier(true);
$if(enum.hasScope)$$enum.scope$::$endif$get_$enum.name$_identifier(false);
>>

register_annotation_typedef(typedef) ::= <<
$if(typedef.hasScope)$$typedef.scope$::$endif$get_$typedef.name$_identifier(true);
$if(typedef.hasScope)$$typedef.scope$::$endif$get_$typedef.name$_identifier(false);
>>

module(ctx, parent, module, definition_list) ::= <<
namespace $module.name$ {

$definition_list$

} // namespace $module.name$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

annotation(ctx, annotation) ::= <<
const TypeIdentifier* get_$annotation.name$_identifier(
        bool complete)
{
    $get_type_identifier_impl(ctx=ctx, param=annotation)$
}

const TypeObject* get_$annotation.name$_object(
        bool complete)
{
    $get_type_object_impl(ctx=ctx, param=annotation)$
}

const TypeObject* get_minimal_$annotation.name$_object()
{
    using namespace $annotation.name$;
    $get_minimal_type_object_impl(ctx=ctx, param=annotation)$
    type_object->minimal()._d(TK_ANNOTATION);

    $annotation.members:{ member | $minimal_annotation_member(ctx=ctx, object=member)$}; separator="\n"$

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().annotation_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=annotation, complete=["false"])$
}

const TypeObject* get_complete_$annotation.name$_object()
{
    using namespace $annotation.name$;
    $get_complete_type_object_impl(ctx=ctx, param=annotation)$
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(false);

    type_object->complete().annotation_type().header().annotation_name("$annotation.name$");

    $annotation.members:{ member | $complete_annotation_member(ctx=ctx, object=member)$}; separator="\n"$

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().annotation_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=annotation, complete=["true"])$
}

namespace $annotation.name$
{
$annotation.enums : { it |$enum_type(ctx=ctx, parent=annotation, enum=it)$}; separator="\n"$

$annotation.typeDefs : { it |$typedef_decl(ctx=ctx, parent=annotation, typedefs=it)$}; separator="\n"$

} // $annotation.name$ namespace
>>

minimal_annotation_member(ctx, object) ::= <<
MinimalAnnotationParameter mam_$object.name$;
TypeIdentifier* mam_$object.name$_typeId = $get_type_identifier(ctx=ctx, type=object.typecode, ek="false")$;
if (mam_$object.name$_typeId != nullptr)
{
    mam_$object.name$.common().member_type_id(*mam_$object.name$_typeId);
}
mam_$object.name$.name("$object.name$");

$if(object.value)$
AnnotationParameterValue def_value_$object.name$;
def_value_$object.name$._d(mam_$object.name$.common().member_type_id()._d());
def_value_$object.name$.from_string("$object.value$");
mam_$object.name$.default_value(def_value_$object.name$);
$endif$

type_object->minimal().annotation_type().member_seq().emplace_back(mam_$object.name$);

>>

complete_annotation_member(ctx, object) ::= <<
CompleteAnnotationParameter cam_$object.name$;
TypeIdentifier* cam_$object.name$_typeId = $get_type_identifier(ctx=ctx, type=object.typecode, ek="true")$;
if (mam_$object.name$_typeId != nullptr)
{
    cam_$object.name$.common().member_type_id(*cam_$object.name$_typeId);
}
cam_$object.name$.name("$object.name$");

$if(object.value)$
AnnotationParameterValue def_value_$object.name$;
def_value_$object.name$._d(cam_$object.name$.common().member_type_id()._d());
def_value_$object.name$.from_string("$object.value$");
cam_$object.name$.default_value(def_value_$object.name$);
$endif$

type_object->complete().annotation_type().member_seq().emplace_back(cam_$object.name$);

>>

interface(ctx, parent, interface, export_list) ::= <<>>

export_list(exports) ::= <<>>

const_decl(ctx, parent, const) ::= <<>>

fwd_decl(ctx, parent, type) ::= <<>>

typedef_decl(ctx, parent, typedefs) ::= <<
const TypeIdentifier* get_$typedefs.name$_identifier(
        bool complete)
{
    $get_type_identifier_impl(ctx=ctx, param=typedefs)$
}

const TypeObject* get_$typedefs.name$_object(
        bool complete)
{
    $get_type_object_impl(ctx=ctx, param=typedefs)$
}

const TypeObject* get_minimal_$typedefs.name$_object()
{
    $get_minimal_type_object_impl(ctx=ctx, param=typedefs)$
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier($get_content_type(ctx=ctx, type=typedefs.typedefContentTypeCode)$, false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().alias_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("$typedefs.name$", $get_content_type(ctx=ctx, type=typedefs.typedefContentTypeCode)$);

    TypeObjectFactory::get_instance()->add_type_object("$typedefs.name$", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("$typedefs.name$", false);
}

const TypeObject* get_complete_$typedefs.name$_object()
{
    $get_complete_type_object_impl(ctx=ctx, param=typedefs)$
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("$typedefs.name$");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete($get_content_type(ctx=ctx, type=typedefs.typedefContentTypeCode)$);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().alias_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("$typedefs.name$", $get_content_type(ctx=ctx, type=typedefs.typedefContentTypeCode)$);

    TypeObjectFactory::get_instance()->add_type_object("$typedefs.name$", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("$typedefs.name$", true);
}

>>

enum_type(ctx, parent, enum) ::= <<
const TypeIdentifier* get_$enum.name$_identifier(
        bool complete)
{
    $get_type_identifier_impl(ctx=ctx, param=enum)$
}

const TypeObject* get_$enum.name$_object(
        bool complete)
{
    $get_type_object_impl(ctx=ctx, param=enum)$
}

const TypeObject* get_minimal_$enum.name$_object()
{
    $get_minimal_type_object_impl(ctx=ctx, param=enum)$
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    $enum.members:{ member | $minimal_enumerated_literal(ctx=ctx, object=member)$}; separator="\n"$

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=enum, complete=["false"])$
}

const TypeObject* get_complete_$enum.name$_object()
{
    $get_complete_type_object_impl(ctx=ctx, param=enum)$
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("$enum.name$");

    $if(enum.annotationList)$
    $enum.annotationList:{ ann |
{
    AppliedAnnotation ann;
    //ann.annotation_typeid(get_$ann.name$_identifier(true));
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
    $if(ann.valueList)$
    $ann.valueList:{ annval |
{
    AppliedAnnotationParameter annParam;
    MD5 message_hash("$annval.name$");
    for(int i = 0; i < 4; ++i)
    {
        annParam.paramname_hash()[i] = message_hash.digest[i];
    \}
    AnnotationParameterValue paramValue;
    paramValue._d($annval.typecode.typeIdentifier$);
    paramValue.from_string("$annval.value$");
    annParam.value(paramValue);
    ann.param_seq().push_back(annParam);
\}
    };separator="\n"$
    $endif$
    type_object->complete().enumerated_type().header().detail().ann_custom().push_back(ann);
\}
    }; separator="\n"$
    $endif$

    uint32_t value = 0;
    $enum.members:{ member | $complete_enumerated_literal(ctx=ctx, object=member)$}; separator="\n"$

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().enumerated_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=enum, complete=["true"])$
}

>>

minimal_enumerated_literal(ctx, object) ::= <<
MinimalEnumeratedLiteral mel_$object.name$;
mel_$object.name$.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
mel_$object.name$.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
mel_$object.name$.common().flags().IS_EXTERNAL(false); // Doesn't apply
mel_$object.name$.common().flags().IS_OPTIONAL(false); // Doesn't apply
mel_$object.name$.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
mel_$object.name$.common().flags().IS_KEY(false); // Doesn't apply
mel_$object.name$.common().flags().IS_DEFAULT($object.annotationDefaultLiteral$);
mel_$object.name$.common().value(value++);
MD5 $object.name$_hash("$object.name$");
for(int i = 0; i < 4; ++i)
{
    mel_$object.name$.detail().name_hash()[i] = $object.name$_hash.digest[i];
}
type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_$object.name$);

>>

complete_enumerated_literal(ctx, object) ::= <<
CompleteEnumeratedLiteral cel_$object.name$;
cel_$object.name$.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
cel_$object.name$.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
cel_$object.name$.common().flags().IS_EXTERNAL(false); // Doesn't apply
cel_$object.name$.common().flags().IS_OPTIONAL(false); // Doesn't apply
cel_$object.name$.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
cel_$object.name$.common().flags().IS_KEY(false); // Doesn't apply
cel_$object.name$.common().flags().IS_DEFAULT($object.annotationDefaultLiteral$);
cel_$object.name$.common().value(value++);
cel_$object.name$.detail().name("$object.name$");

$if(object.annotationList)$
$object.annotationList:{ ann |
{
    AppliedAnnotation ann;
    //ann.annotation_typeid(get_$ann.name$_identifier(true));
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
    $if(ann.valueList)$
    $ann.valueList:{ annval |
    {
        AppliedAnnotationParameter annParam;
        MD5 message_hash("$annval.name$");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        \}
        AnnotationParameterValue paramValue;
        paramValue._d($annval.typecode.typeIdentifier$);
        paramValue.from_string("$annval.value$");
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);
    \}
    };separator="\n"$
    $endif$
    cel_$object.name$.detail().ann_custom().push_back(ann);
\}
}; separator="\n"$
$endif$

type_object->complete().enumerated_type().literal_seq().emplace_back(cel_$object.name$);

>>

struct_type(ctx, parent, struct, extensions) ::= <<
const TypeIdentifier* get_$struct.name$_identifier(
        bool complete)
{
    $get_type_identifier_impl(ctx=ctx, param=struct)$
}

const TypeObject* get_$struct.name$_object(
        bool complete)
{
    $get_type_object_impl(ctx=ctx, param=struct)$
}

const TypeObject* get_minimal_$struct.name$_object()
{
    $get_minimal_type_object_impl(ctx=ctx, param=struct)$
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL($struct.annotationFinal$);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE($struct.annotationAppendable$);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE($struct.annotationMutable$);
    type_object->minimal().struct_type().struct_flags().IS_NESTED($struct.annotationNested$);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    $struct.members:{ member | $minimal_member_object_type(ctx=ctx, object=member)$}; separator="\n"$

    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    $struct.inheritances:{ it | $minimal_struct_inheritance(it)$}; separator="\n"$

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=struct, complete=["false"])$
}

const TypeObject* get_complete_$struct.name$_object()
{
    $get_complete_type_object_impl(ctx=ctx, param=struct)$
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL($struct.annotationFinal$);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE($struct.annotationAppendable$);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE($struct.annotationMutable$);
    type_object->complete().struct_type().struct_flags().IS_NESTED($struct.annotationNested$);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    $struct.members:{ member | $complete_member_object_type(ctx=ctx, object=member)$}; separator="\n"$

    // Header
    type_object->complete().struct_type().header().detail().type_name("$struct.name$");
    // TODO inheritance
    $struct.inheritances:{ it | $complete_struct_inheritance(it)$}; separator="\n"$

    $if(struct.annotationList)$
    $struct.annotationList:{ ann |
{
    AppliedAnnotation ann;
    //ann.annotation_typeid(get_$ann.name$_identifier(true));
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
    $if(ann.valueList)$
    $ann.valueList:{ annval |
{
    AppliedAnnotationParameter annParam;
    MD5 message_hash("$annval.name$");
    for(int i = 0; i < 4; ++i)
    {
        annParam.paramname_hash()[i] = message_hash.digest[i];
    \}
    AnnotationParameterValue paramValue;
    paramValue._d($annval.typecode.typeIdentifier$);
    paramValue.from_string("$annval.value$");
    annParam.value(paramValue);
    ann.param_seq().push_back(annParam);
\}
    };separator="\n"$
    $endif$
    type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
\}
    }; separator="\n"$
    $endif$

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=struct, complete=["true"])$
}

>>

minimal_struct_inheritance(parent) ::= <<
type_object->minimal().struct_type().header().base_type(*get_$parent.name$_identifier(false));
>>

complete_struct_inheritance(parent) ::= <<
type_object->complete().struct_type().header().base_type(*get_$parent.name$_identifier(true));
>>

minimal_member_object_type(ctx, object) ::= <<
MinimalStructMember mst_$object.name$;
mst_$object.name$.common().member_id(memberId++);
mst_$object.name$.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
mst_$object.name$.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
mst_$object.name$.common().member_flags().IS_EXTERNAL(false); // Unsupported
mst_$object.name$.common().member_flags().IS_OPTIONAL($object.annotationOptional$);
mst_$object.name$.common().member_flags().IS_MUST_UNDERSTAND($object.annotationMustUnderstand$);
mst_$object.name$.common().member_flags().IS_KEY($object.annotationKey$);
mst_$object.name$.common().member_flags().IS_DEFAULT(false); // Doesn't apply
$if(object.typecode.plainType)$
mst_$object.name$.common().member_type_id(*$get_type_identifier(ctx=ctx, type=object.typecode, ek="false")$);
$elseif(object.typecode.objectType)$
mst_$object.name$.common().member_type_id(*$if(object.typecode.hasScope)$$object.typecode.scope$::$endif$get_$object.typecode.name$_identifier(false));
$else$
mst_$object.name$.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("$object.typecode.cppTypenameForTypeId$", false));
$endif$


MD5 $object.name$_hash("$object.name$");
for(int i = 0; i < 4; ++i)
{
    mst_$object.name$.detail().name_hash()[i] = $object.name$_hash.digest[i];
}
type_object->minimal().struct_type().member_seq().emplace_back(mst_$object.name$);

>>

complete_member_object_type(ctx, object) ::= <<
CompleteStructMember cst_$object.name$;
cst_$object.name$.common().member_id(memberId++);
cst_$object.name$.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
cst_$object.name$.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
cst_$object.name$.common().member_flags().IS_EXTERNAL(false); // Unsupported
cst_$object.name$.common().member_flags().IS_OPTIONAL($object.annotationOptional$);
cst_$object.name$.common().member_flags().IS_MUST_UNDERSTAND($object.annotationMustUnderstand$);
cst_$object.name$.common().member_flags().IS_KEY($object.annotationKey$);
cst_$object.name$.common().member_flags().IS_DEFAULT(false); // Doesn't apply
$if(object.typecode.plainType)$
cst_$object.name$.common().member_type_id(*$get_type_identifier(ctx=ctx, type=object.typecode, ek="true")$);
$elseif(object.typecode.objectType)$
cst_$object.name$.common().member_type_id(*$if(object.typecode.hasScope)$$object.typecode.scope$::$endif$get_$object.typecode.name$_identifier(true));
$else$
cst_$object.name$.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("$object.typecode.cppTypenameForTypeId$", false));
$endif$


cst_$object.name$.detail().name("$object.name$");

$if(object.annotationList)$
$object.annotationList:{ ann |
{
    AppliedAnnotation ann;
    //ann.annotation_typeid(get_$ann.name$_identifier(true));
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
    $if(ann.valueList)$
    $ann.valueList:{ annval |
    {
        AppliedAnnotationParameter annParam;
        MD5 message_hash("$annval.name$");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        \}
        AnnotationParameterValue paramValue;
        paramValue._d($annval.typecode.typeIdentifier$);
        paramValue.from_string("$annval.value$");
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);
    \}
    };separator="\n"$
    $endif$
    cst_$object.name$.detail().ann_custom().push_back(ann);
\}
}; separator="\n"$
$endif$

type_object->complete().struct_type().member_seq().emplace_back(cst_$object.name$);

>>

get_type_identifier(ctx, type, ek) ::= <<$if(type.isSequenceType)$TypeObjectFactory::get_instance()->get_sequence_identifier($get_content_type(ctx=ctx, type=type.contentTypeCode)$, $type.maxsize$, $ek$)$elseif(type.isArrayType)$TypeObjectFactory::get_instance()->get_array_identifier($get_content_type(ctx=ctx, type=type.contentTypeCode)$, {$type.dimensions:{ dim |$dim$}; separator=", "$}, $ek$)$elseif(type.isSetType)$TypeObjectFactory::get_instance()->get_sequence_identifier($get_content_type(ctx=ctx, type=type.contentTypeCode)$, $type.maxsize$, $ek$)$elseif(type.isMapType)$TypeObjectFactory::get_instance()->get_map_identifier($get_content_type(ctx=ctx, type=type.keyTypeCode)$, $get_content_type(ctx=ctx, type=type.valueTypeCode)$, $type.maxsize$, $ek$)$elseif(type.isStringType)$TypeObjectFactory::get_instance()->get_string_identifier($type.maxsize$, false)$elseif(type.isWStringType)$TypeObjectFactory::get_instance()->get_string_identifier($type.maxsize$, true)$elseif(type.objectType)$get_$type.name$_identifier($ek$)$elseif(type.plainType)$TypeObjectFactory::get_instance()->get_type_identifier("$type.cppTypenameForTypeId$", false)$else$TypeObjectFactory::get_instance()->get_type_identifier("$type.cppTypenameForTypeId$", false)$endif$>>

get_content_type(ctx, type) ::= <<$if(type.plainType)$$if(type.isSequenceType)$TypeNamesGenerator::get_sequence_type_name($get_content_type(ctx=ctx, type=type.contentTypeCode)$, $type.maxsize$)$elseif(type.isArrayType)$TypeNamesGenerator::get_array_type_name($get_content_type(ctx=ctx, type=type.contentTypeCode)$, {$type.dimensions:{ dim |$dim$}; separator=", "$})$elseif(type.isSetType)$TypeNamesGenerator::get_sequence_type_name($get_content_type(ctx=ctx, type=type.contentTypeCode)$, $type.maxsize$)$elseif(type.isMapType)$TypeNamesGenerator::get_map_type_name($get_content_type(ctx=ctx, type=type.keyTypeCode)$, $get_content_type(ctx=ctx, type=type.valueTypeCode)$, $type.maxsize$)$elseif(type.isStringType)$TypeNamesGenerator::get_string_type_name($type.maxsize$, false)$elseif(type.isWStringType)$TypeNamesGenerator::get_string_type_name($type.maxsize$, true)$else$"$type.cppTypenameForTypeId$"$endif$$else$"$type.cppTypenameForTypeId$"$endif$>>

union_type(ctx, parent, union) ::= <<
const TypeIdentifier* get_$union.name$_identifier(
        bool complete)
{
    $get_type_identifier_impl(ctx=ctx, param=union)$
}

const TypeObject* get_$union.name$_object(
        bool complete)
{
    $get_type_object_impl(ctx=ctx, param=union)$
}

const TypeObject* get_minimal_$union.name$_object()
{
    $get_minimal_type_object_impl(ctx=ctx, param=union)$
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL($union.annotationFinal$);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE($union.annotationAppendable$);
    type_object->minimal().union_type().union_flags().IS_MUTABLE($union.annotationMutable$);
    type_object->minimal().union_type().union_flags().IS_NESTED($union.annotationNested$);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*$get_type_identifier(ctx=ctx, type=union.discriminator, ek="false")$);

    MemberId memberId = 0;
    $union.members:{ member | $minimal_union_member_object_type(ctx=ctx, object=member, discriminator=union.discriminator)$}; separator="\n"$

    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().union_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=union, complete=["false"])$
}

const TypeObject* get_complete_$union.name$_object()
{
    $get_complete_type_object_impl(ctx=ctx, param=union)$
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL($union.annotationFinal$);
    type_object->complete().union_type().union_flags().IS_APPENDABLE($union.annotationAppendable$);
    type_object->complete().union_type().union_flags().IS_MUTABLE($union.annotationMutable$);
    type_object->complete().union_type().union_flags().IS_NESTED($union.annotationNested$);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*$get_type_identifier(ctx=ctx, type=union.discriminator, ek="true")$);

    $if(union.discriminator.annotationList)$
    $union.discriminator.annotationList:{ ann |
{
    AppliedAnnotation ann;
    //ann.annotation_typeid(get_$ann.name$_identifier(true));
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
    $if(ann.valueList)$
    $ann.valueList:{ annval |
{
    AppliedAnnotationParameter annParam;
    MD5 message_hash("$annval.name$");
    for(int i = 0; i < 4; ++i)
    {
        annParam.paramname_hash()[i] = message_hash.digest[i];
    \}
    AnnotationParameterValue paramValue;
    paramValue._d($annval.typecode.typeIdentifier$);
    paramValue.from_string("$annval.value$");
    annParam.value(paramValue);
    ann.param_seq().push_back(annParam);
\}
    };separator="\n"$
    $endif$
    type_object->complete().union_type().discriminator().ann_custom().push_back(ann);
\}
    }; separator="\n"$
    $endif$

    MemberId memberId = 0;
    $union.members:{ member | $complete_union_member_object_type(ctx=ctx, object=member, discriminator=union.discriminator)$}; separator="\n"$

    // Header
    type_object->complete().union_type().header().detail().type_name("$union.name$");

    $if(union.annotationList)$
    $union.annotationList:{ ann |
{
    AppliedAnnotation ann;
    //ann.annotation_typeid(get_$ann.name$_identifier(true));
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
    $if(ann.valueList)$
    $ann.valueList:{ annval |
{
    AppliedAnnotationParameter annParam;
    MD5 message_hash("$annval.name$");
    for(int i = 0; i < 4; ++i)
    {
        annParam.paramname_hash()[i] = message_hash.digest[i];
    \}
    AnnotationParameterValue paramValue;
    paramValue._d($annval.typecode.typeIdentifier$);
    paramValue.from_string("$annval.value$");
    annParam.value(paramValue);
    ann.param_seq().push_back(annParam);
\}
    };separator="\n"$
    $endif$
    type_object->complete().union_type().header().detail().ann_custom().push_back(ann);
\}
    }; separator="\n"$
    $endif$

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().union_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=union, complete=["true"])$
}

>>

minimal_union_member_object_type(ctx, object, discriminator) ::= <<
MinimalUnionMember mst_$object.name$;
mst_$object.name$.common().member_id(memberId++);
mst_$object.name$.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
mst_$object.name$.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
mst_$object.name$.common().member_flags().IS_EXTERNAL(false); // Unsupported
mst_$object.name$.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
mst_$object.name$.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
mst_$object.name$.common().member_flags().IS_KEY(false); // Doesn't apply
mst_$object.name$.common().member_flags().IS_DEFAULT($object.annotationDefault$);
$if(object.typecode.plainType)$
mst_$object.name$.common().type_id(*$get_type_identifier(ctx=ctx, type=object.typecode, ek="false")$);
$elseif(object.typecode.objectType)$
mst_$object.name$.common().type_id(*$if(object.typecode.hasScope)$$object.typecode.scope$::$endif$get_$object.typecode.name$_identifier(false));
$else$
mst_$object.name$.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("$object.typecode.cppTypenameForTypeId$", false));
$endif$


$if(object.labels)$
$object.labels:{ label | mst_$object.name$.common().label_seq().emplace_back($label$);}; separator="\n"$
$endif$

MD5 $object.name$_hash("$object.name$");
for(int i = 0; i < 4; ++i)
{
    mst_$object.name$.detail().name_hash()[i] = $object.name$_hash.digest[i];
}
type_object->minimal().union_type().member_seq().emplace_back(mst_$object.name$);

>>

complete_union_member_object_type(ctx, object, discriminator) ::= <<
CompleteUnionMember cst_$object.name$;
cst_$object.name$.common().member_id(memberId++);
cst_$object.name$.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
cst_$object.name$.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
cst_$object.name$.common().member_flags().IS_EXTERNAL(false); // Unsupported
cst_$object.name$.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
cst_$object.name$.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
cst_$object.name$.common().member_flags().IS_KEY(false); // Doesn't apply
cst_$object.name$.common().member_flags().IS_DEFAULT($object.annotationDefault$);
$if(object.typecode.plainType)$
cst_$object.name$.common().type_id(*$get_type_identifier(ctx=ctx, type=object.typecode, ek="false")$);
$elseif(object.typecode.objectType)$
cst_$object.name$.common().type_id(*$if(object.typecode.hasScope)$$object.typecode.scope$::$endif$get_$object.typecode.name$_identifier(true));
$else$
cst_$object.name$.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("$object.typecode.cppTypenameForTypeId$", false));
$endif$

$if(object.labels)$
$object.labels:{ label | cst_$object.name$.common().label_seq().emplace_back($label$);}; separator="\n"$
$endif$


cst_$object.name$.detail().name("$object.name$");

$if(object.annotationList)$
$object.annotationList:{ ann |
{
    AppliedAnnotation ann;
    //ann.annotation_typeid(get_$ann.name$_identifier(true));
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
    $if(ann.valueList)$
    $ann.valueList:{ annval |
    {
        AppliedAnnotationParameter annParam;
        MD5 message_hash("$annval.name$");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        \}
        AnnotationParameterValue paramValue;
        paramValue._d($annval.typecode.typeIdentifier$);
        paramValue.from_string("$annval.value$");
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);
    \}
    };separator="\n"$
    $endif$
    cst_$object.name$.detail().ann_custom().push_back(ann);
\}
}; separator="\n"$
$endif$

type_object->complete().union_type().member_seq().emplace_back(cst_$object.name$);

>>

bitmask_type(ctx, parent, bitmask) ::= <<
const TypeIdentifier* get_$bitmask.name$_identifier(
        bool complete)
{
    $get_type_identifier_impl(ctx=ctx, param=bitmask)$
}

const TypeObject* get_$bitmask.name$_object(
        bool complete)
{
    $get_type_object_impl(ctx=ctx, param=bitmask)$
}

const TypeObject* get_minimal_$bitmask.name$_object()
{
    $get_minimal_type_object_impl(ctx=ctx, param=bitmask)$
    type_object->minimal()._d(TK_BITMASK);

    type_object->minimal().bitmask_type().header().common().bit_bound($bitmask.bitBound$);

    $bitmask.bitmasks:{ member | $minimal_bitmask_flag(ctx=ctx, object=member)$}; separator="\n"$

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().bitmask_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=bitmask, complete=["false"])$
}

const TypeObject* get_complete_$bitmask.name$_object()
{
    $get_complete_type_object_impl(ctx=ctx, param=bitmask)$
    type_object->complete()._d(TK_BITMASK);

    // No flags apply
    //type_object->complete().bitmask_type().bitmask_flags().IS_FINAL(false);
    //type_object->complete().bitmask_type().bitmask_flags().IS_APPENDABLE(false);
    //type_object->complete().bitmask_type().bitmask_flags().IS_MUTABLE(false);
    //type_object->complete().bitmask_type().bitmask_flags().IS_NESTED(false);
    //type_object->complete().bitmask_type().bitmask_flags().IS_AUTOID_HASH(false);

    type_object->complete().bitmask_type().header().common().bit_bound($bitmask.bitBound$);

    $if(union.annotationList)$
    $union.annotationList:{ ann |
{
    AppliedAnnotation ann;
    //ann.annotation_typeid(get_$ann.name$_identifier(true));
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
    $if(ann.valueList)$
    $ann.valueList:{ annval |
{
    AppliedAnnotationParameter annParam;
    MD5 message_hash("$annval.name$");
    for(int i = 0; i < 4; ++i)
    {
        annParam.paramname_hash()[i] = message_hash.digest[i];
    \}
    AnnotationParameterValue paramValue;
    paramValue._d($annval.typecode.typeIdentifier$);
    paramValue.from_string("$annval.value$");
    annParam.value(paramValue);
    ann.param_seq().push_back(annParam);
\}
    };separator="\n"$
    $endif$
    type_object->complete().bitmask_type().header().detail().ann_custom().push_back(ann);
\}
    }; separator="\n"$
    $endif$

    type_object->complete().bitmask_type().header().detail().type_name("$bitmask.name$");

    $bitmask.members:{ member | $complete_bitmask_flag(ctx=ctx, object=member)$}; separator="\n"$

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().bitmask_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=bitmask, complete=["true"])$
}

>>

minimal_bitmask_flag(ctx, object) ::= <<
MinimalBitflag mbf_$object.name$;
mbf_$object.name$.common().flags().TRY_CONSTRUCT1(false);
mbf_$object.name$.common().flags().TRY_CONSTRUCT2(false);
mbf_$object.name$.common().flags().IS_EXTERNAL(false);
mbf_$object.name$.common().flags().IS_OPTIONAL(false);
mbf_$object.name$.common().flags().IS_MUST_UNDERSTAND(false);
mbf_$object.name$.common().flags().IS_KEY(false);
mbf_$object.name$.common().flags().IS_DEFAULT(false);
mbf_$object.name$.common().position($object.position$);
MD5 $object.name$_hash("$object.name$");
for(int i = 0; i < 4; ++i)
{
    mbf_$object.name$.detail().name_hash()[i] = $object.name$_hash.digest[i];
}
type_object->minimal().bitmask_type().flag_seq().emplace_back(mbf_$object.name$);

>>

complete_bitmask_flag(ctx, object) ::= <<
CompleteBitflag cbf_$object.name$;
cbf_$object.name$.common().flags().TRY_CONSTRUCT1(false);
cbf_$object.name$.common().flags().TRY_CONSTRUCT2(false);
cbf_$object.name$.common().flags().IS_EXTERNAL(false);
cbf_$object.name$.common().flags().IS_OPTIONAL(false);
cbf_$object.name$.common().flags().IS_MUST_UNDERSTAND(false);
cbf_$object.name$.common().flags().IS_KEY(false);
cbf_$object.name$.common().flags().IS_DEFAULT(false);
cbf_$object.name$.common().position($object.position$);
cbf_$object.name$.detail().name("$object.name$");

// Position annotation always present
{
    AppliedAnnotation ann;
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
    AppliedAnnotationParameter annParam;
    MD5 message_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        annParam.paramname_hash()[i] = message_hash.digest[i];
    }
    AnnotationParameterValue paramValue;
    paramValue._d(TK_UINT16);
    paramValue.uint_16_value($object.position$);
    annParam.value(paramValue);
    ann.param_seq().push_back(annParam);

    cbf_$object.name$.detail().ann_custom().push_back(ann);
}

$if(object.annotationList)$
$object.annotationList:{ ann |
{
    if (std::strcmp("position", "$ann.name$") != 0)
    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(get_$ann.name$_identifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
        $if(ann.valueList)$
        $ann.valueList:{ annval |
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("$annval.name$");
            for(int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            \}
            AnnotationParameterValue paramValue;
            paramValue._d($annval.typecode.typeIdentifier$);
            paramValue.from_string("$annval.value$");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        \}
        };separator="\n"$
        $endif$
        cbf_$object.name$.detail().ann_custom().push_back(ann);
    \}
\}
}; separator="\n"$
$endif$

type_object->complete().bitmask_type().flag_seq().emplace_back(cbf_$object.name$);

>>

bitset_type(ctx, parent, bitset, extensions) ::= <<
const TypeIdentifier* get_$bitset.name$_identifier(
        bool complete)
{
    $get_type_identifier_impl(ctx=ctx, param=bitset)$
}

const TypeObject* get_$bitset.name$_object(
        bool complete)
{
    $get_type_object_impl(ctx=ctx, param=bitset)$
}

const TypeObject* get_minimal_$bitset.name$_object()
{
    $get_minimal_type_object_impl(ctx=ctx, param=bitset)$
    type_object->minimal()._d(TK_BITSET);

    $bitset.bitfields:{ member | $minimal_bitfield(ctx=ctx, object=member)$}; separator="\n"$

    $bitset.parents:{ it | $minimal_bitset_inheritance(it)$}; separator="\n"$

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().bitset_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=bitset, complete=["false"])$
}

const TypeObject* get_complete_$bitset.name$_object()
{
    $get_complete_type_object_impl(ctx=ctx, param=bitset)$
    type_object->complete()._d(TK_BITSET);

    // No flags apply
    //type_object->complete().bitset_type().bitset_flags().IS_FINAL(false);
    //type_object->complete().bitset_type().bitset_flags().IS_APPENDABLE(false);
    //type_object->complete().bitset_type().bitset_flags().IS_MUTABLE(false);
    //type_object->complete().bitset_type().bitset_flags().IS_NESTED(false);
    //type_object->complete().bitset_type().bitset_flags().IS_AUTOID_HASH(false);

    $if(union.annotationList)$
    $union.annotationList:{ ann |
{
    AppliedAnnotation ann;
    //ann.annotation_typeid(get_$ann.name$_identifier(true));
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
    $if(ann.valueList)$
    $ann.valueList:{ annval |
{
    AppliedAnnotationParameter annParam;
    MD5 message_hash("$annval.name$");
    for(int i = 0; i < 4; ++i)
    {
        annParam.paramname_hash()[i] = message_hash.digest[i];
    \}
    AnnotationParameterValue paramValue;
    paramValue._d($annval.typecode.typeIdentifier$);
    paramValue.from_string("$annval.value$");
    annParam.value(paramValue);
    ann.param_seq().push_back(annParam);
\}
    };separator="\n"$
    $endif$
    type_object->complete().bitset_type().header().detail().ann_custom().push_back(ann);
\}
    }; separator="\n"$
    $endif$

    type_object->complete().bitset_type().header().detail().type_name("$bitset.name$");

    $bitset.bitfields:{ member | $complete_bitfield(ctx=ctx, object=member)$}; separator="\n"$

    $bitset.parents:{ it | $complete_bitset_inheritance(it)$}; separator="\n"$

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().bitset_type(), current_alignment) + 4));
    $type_identifier_impl(ctx=ctx, param=bitset, complete=["true"])$
}

>>

minimal_bitfield(ctx, object) ::= <<
$if(object.name)$
MinimalBitfield mbf_$object.name$;
mbf_$object.name$.common().flags().TRY_CONSTRUCT1(false);
mbf_$object.name$.common().flags().TRY_CONSTRUCT2(false);
mbf_$object.name$.common().flags().IS_EXTERNAL(false);
mbf_$object.name$.common().flags().IS_OPTIONAL(false);
mbf_$object.name$.common().flags().IS_MUST_UNDERSTAND(false);
mbf_$object.name$.common().flags().IS_KEY(false);
mbf_$object.name$.common().flags().IS_DEFAULT(false);
mbf_$object.name$.common().position($object.basePosition$);
mbf_$object.name$.common().bitcount($object.spec.bitSize$);
mbf_$object.name$.common().holder_type($object.spec.typecode.typeIdentifier$);
MD5 $object.name$_hash("$object.name$");
for(int i = 0; i < 4; ++i)
{
    mbf_$object.name$.name_hash()[i] = $object.name$_hash.digest[i];
}
type_object->minimal().bitset_type().field_seq().emplace_back(mbf_$object.name$);
$endif$

>>

complete_bitfield(ctx, object) ::= <<
$if(object.name)$
CompleteBitfield cbf_$object.name$;
cbf_$object.name$.common().flags().TRY_CONSTRUCT1(false);
cbf_$object.name$.common().flags().TRY_CONSTRUCT2(false);
cbf_$object.name$.common().flags().IS_EXTERNAL(false);
cbf_$object.name$.common().flags().IS_OPTIONAL(false);
cbf_$object.name$.common().flags().IS_MUST_UNDERSTAND(false);
cbf_$object.name$.common().flags().IS_KEY(false);
cbf_$object.name$.common().flags().IS_DEFAULT(false);
cbf_$object.name$.common().position($object.basePosition$);
cbf_$object.name$.common().bitcount($object.spec.bitSize$);
cbf_$object.name$.common().holder_type($object.spec.typecode.typeIdentifier$);
cbf_$object.name$.detail().name("$object.name$");

// Position annotation always present
{
    // Position
    AppliedAnnotation ann;
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
    AppliedAnnotationParameter annParam;
    MD5 message_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        annParam.paramname_hash()[i] = message_hash.digest[i];
    }
    AnnotationParameterValue paramValue;
    paramValue._d(TK_UINT16);
    paramValue.uint_16_value($object.basePosition$);
    annParam.value(paramValue);
    ann.param_seq().push_back(annParam);

    cbf_$object.name$.detail().ann_custom().push_back(ann);
}

// Use bit_bound as bitcount.
{
    // Position
    AppliedAnnotation ann;
    ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("bit_bound"));
    AppliedAnnotationParameter annParam;
    MD5 message_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        annParam.paramname_hash()[i] = message_hash.digest[i];
    }
    AnnotationParameterValue paramValue;
    paramValue._d(TK_UINT16);
    paramValue.uint_16_value($object.spec.bitSize$);
    annParam.value(paramValue);
    ann.param_seq().push_back(annParam);

    cbf_$object.name$.detail().ann_custom().push_back(ann);
}

$if(object.annotationList)$
$object.annotationList:{ ann |
{
    if (std::strcmp("position", "$ann.name$") != 0 && std::strcmp("bit_bound", "$ann.name$") != 0)
    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(get_$ann.name$_identifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("$ann.name$"));
        $if(ann.valueList)$
        $ann.valueList:{ annval |
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("$annval.name$");
            for(int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            \}
            AnnotationParameterValue paramValue;
            paramValue._d($annval.typecode.typeIdentifier$);
            paramValue.from_string("$annval.value$");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        \}
        };separator="\n"$
        $endif$
        cbf_$object.name$.detail().ann_custom().push_back(ann);
    \}
\}
}; separator="\n"$
$endif$

type_object->complete().bitset_type().field_seq().emplace_back(cbf_$object.name$);
$endif$

>>

minimal_bitset_inheritance(parent) ::= <<
type_object->minimal().bitset_type().header().base_type(*get_$parent.name$_identifier(false));
>>

complete_bitset_inheritance(parent) ::= <<
type_object->complete().bitset_type().header().base_type(*get_$parent.name$_identifier(true));
>>

/***** Utils *****/
get_type_identifier_impl(ctx, param) ::= <<
const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier(
    "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$", complete);
if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
{
    return c_identifier;
}

get_$param.name$_object(complete); // Generated inside
return TypeObjectFactory::get_instance()->get_type_identifier(
    "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$", complete);
>>

get_type_object_impl(ctx, param) ::= <<
const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object(
    "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$", complete);
if (c_type_object != nullptr)
{
    return c_type_object;
}
else if (complete)
{
    return get_complete_$param.name$_object();
}
// else
return get_minimal_$param.name$_object();
>>

get_minimal_type_object_impl(ctx, param) ::= <<
const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object(
    "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$", false);
if (c_type_object != nullptr)
{
    return c_type_object;
}

TypeObject* type_object = new TypeObject();
type_object->_d(EK_MINIMAL);
>>

get_complete_type_object_impl(ctx, param) ::= <<
const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object(
    "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$", true);
if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
{
    return c_type_object;
}

TypeObject* type_object = new TypeObject();
type_object->_d(EK_COMPLETE);
>>

type_identifier_impl(ctx, param, complete) ::= <<
eprosima::fastcdr::FastBuffer fastbuffer(static_cast<char*>(payload.data), payload.max_size);
// XTypes v1.3 Annex B: EquivalenceHash, first 14 bytes of MD5 of the serialized TypeObject using XCDR version 2.
eprosima::fastcdr::Cdr ser(
    fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
    eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

ser << *type_object;
payload.length = static_cast<uint32_t>(ser.get_serialized_data_length()); //Get the serialized length
MD5 objectHash;
objectHash.update(static_cast<char*>(payload.data), payload.length);
objectHash.finalize();
for(int i = 0; i < 14; ++i)
{
    identifier.equivalence_hash()[i] = objectHash.digest[i];
}

TypeObjectFactory::get_instance()->add_type_object(
    "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$", &identifier, type_object);
delete type_object;
return TypeObjectFactory::get_instance()->get_type_object(
    "$if(ctx.GenerateTypesROS2)$$param.ROS2Scopedname$$else$$param.scopedname$$endif$", $complete$);
>>
