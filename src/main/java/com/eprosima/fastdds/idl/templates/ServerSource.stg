// Copyright 2025 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

import "eprosima.stg"
import "com/eprosima/fastcdr/idl/templates/FastCdrCommon.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "Server.cxx"], description=["Server implementation for interfaces"])$

#include "$ctx.filename$Server.hpp"

#include <atomic>
#include <condition_variable>
#include <map>
#include <memory>
#include <mutex>
#include <queue>
#include <stdexcept>
#include <string>
#include <thread>
#include <vector>

#include <fastdds/dds/builtin/topic/PublicationBuiltinTopicData.hpp>
#include <fastdds/dds/core/condition/Condition.hpp>
#include <fastdds/dds/core/condition/GuardCondition.hpp>
#include <fastdds/dds/core/condition/WaitSet.hpp>
#include <fastdds/dds/core/Time_t.hpp>
#include <fastdds/dds/domain/DomainParticipant.hpp>
#include <fastdds/dds/domain/qos/ReplierQos.hpp>
#include <fastdds/dds/rpc/exceptions.hpp>
#include <fastdds/dds/rpc/interfaces.hpp>
#include <fastdds/dds/rpc/RequestInfo.hpp>
#include <fastdds/dds/rpc/Replier.hpp>
#include <fastdds/dds/rpc/Service.hpp>
#include <fastdds/dds/rpc/ServiceTypeSupport.hpp>
#include <fastdds/dds/subscriber/DataReader.hpp>

#include "$ctx.filename$.hpp"
#include "$ctx.filename$_details.hpp"
#include "$ctx.filename$PubSubTypes.hpp"

$definitions; separator="\n"$

#include "$ctx.filename$Server.ipp"

>>

module(ctx, parent, module, definition_list) ::= <<
namespace $module.name$ {

$definition_list$

} // namespace $module.name$

>>

interface(ctx, parent, interface, export_list) ::= <<
//{ interface $interface.name$

namespace detail {

namespace fdds = eprosima::fastdds::dds;
namespace frpc = eprosima::fastdds::dds::rpc;
namespace frtps = eprosima::fastdds::rtps;

class $interface.name$ServerLogic
    : public $interface.name$Server
{
    using RequestType = $interface.name$_Request;
    using ReplyType = $interface.name$_Reply;

public:

    $interface.name$ServerLogic(
            eprosima::fastdds::dds::DomainParticipant& part,
            const char* service_name,
            const eprosima::fastdds::dds::ReplierQos& qos,
            size_t thread_pool_size)
        : $interface.name$Server()
        , participant_(part)
        , thread_pool_(*this, thread_pool_size)
    {
        // Register the service type support
        auto service_type = create_$interface.name$_service_type_support();
        auto ret = service_type.register_service_type(&participant_, "$interface.scopedname$");
        if (ret != fdds::RETCODE_OK)
        {
            throw std::runtime_error("Error registering service type");
        }

        // Create the service
        service_ = participant_.create_service(service_name, "$interface.scopedname$");
        if (nullptr == service_)
        {
            throw std::runtime_error("Error creating service");
        }

        // Create the replier
        replier_ = participant_.create_service_replier(service_, qos);
        if (nullptr == replier_)
        {
            throw std::runtime_error("Error creating requester");
        }
    }

    ~$interface.name$ServerLogic() override
    {
        stop();

        if (nullptr != replier_)
        {
            participant_.delete_service_replier(service_->get_service_name(), replier_);
        }

        if (nullptr != service_)
        {
            participant_.delete_service(service_);
        }
    }

    void run() override
    {
        finish_condition_.set_trigger_value(false);
        fdds::WaitSet waitset;
        waitset.attach_condition(finish_condition_);
        waitset.attach_condition(replier_->get_replier_reader()->get_statuscondition());

        while (true)
        {
            fdds::ConditionSeq active_conditions;
            waitset.wait(active_conditions, fdds::c_TimeInfinite);

            // Early exit if the finish condition is triggered
            if (finish_condition_.get_trigger_value())
            {
                break;
            }

            // Take and process the requests
            auto ctx = std::make_shared<RequestContext>();
            while (fdds::RETCODE_OK == ctx->take_from(replier_))
            {
                if (ctx->validate_request())
                {
                    process_request(ctx);
                }
                else
                {
                    ctx->send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_INVALID_ARGUMENT, replier_);
                }

                // Prepare next request context
                ctx = std::make_shared<RequestContext>();
            }
        }
    }

    void stop() override
    {
        finish_condition_.set_trigger_value(true);
        thread_pool_.stop();

        std::lock_guard<std::mutex> _(mtx_);
        // TODO: Cancel all pending requests
        processing_requests_.clear();
    }

private:

    $interface.all_operations:{op | $operation_declarations(op)$}; separator="\n\n"$

    struct RequestContext : ClientContext
    {
        RequestType request;
        frpc::RequestInfo info;
        frtps::GUID_t client_id;
        fdds::PublicationBuiltinTopicData pub_data;

        $interface.all_operations:{op | $operation_feed_members(op)$}; separator="\n\n"$

        const frtps::GUID_t& get_client_id() const override
        {
            return client_id;
        }

        const frtps::RemoteLocatorList& get_client_locators() const override
        {
            return pub_data.remote_locators;
        }

        fdds::ReturnCode_t take_from(
                frpc::Replier* replier)
        {
            fdds::ReturnCode_t ret = replier->take_request(&request, info);
            if (ret == fdds::RETCODE_OK)
            {
                client_id = info.sample_identity.writer_guid();
                ret = replier->get_replier_reader()->get_matched_publication_data(pub_data, client_id);
            }
            return ret;
        }

        bool validate_request() const
        {
            size_t n_fields = 0;
            $interface.requestTypeCode.members:{member | n_fields += request.$member.name$.has_value() ? 1 : 0;}; separator="\n"$

            return n_fields == 1U;
        }

        void process_additional_request(
                const std::shared_ptr<RequestContext>& ctx,
                frpc::Replier* replier,
                bool& should_erase)
        {
            should_erase = false;
            if (ctx->info.related_sample_identity == info.related_sample_identity)
            {
                // TODO: Pass values from input streams
                send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_INVALID_ARGUMENT, replier);
                should_erase = true;
            }
            else
            {
                // This is not the expected request
                should_erase = true;
            }
        }

        bool prepare(
                frpc::Replier* replier)
        {
            $interface.all_operations:{op | $operation_prepare_call(op)$}; separator="\n"$

            send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_UNKNOWN_OPERATION, replier);
            return false;
        }

        void send_exception(
                frpc::RemoteExceptionCode_t ex,
                frpc::Replier* replier)
        {
            ReplyType reply{};
            reply.remoteEx = ex;
            replier->send_reply(&reply, info);
        }

    private:

        $interface.all_operations:{op | $operation_prepare_impl(op)$}; separator="\n\n"$

    };

    struct ThreadPool
    {
        ThreadPool(
                $interface.name$ServerLogic& server,
                size_t num_threads)
            : server_(server)
        {
            // Create worker threads (at least one)
            if (num_threads == 0)
            {
                num_threads = 1;
            }

            auto process_requests = [this]()
            {
                while (!finished_)
                {
                    std::shared_ptr<RequestContext> req;
                    {
                        std::unique_lock<std::mutex> lock(mtx_);
                        cv_.wait(lock, [this]
                        {
                            return finished_ || !requests_.empty();
                        });
                        if (finished_)
                        {
                            break;
                        }
                        req = requests_.front();
                        requests_.pop();
                    }

                    // Process the request
                    server_.execute_request(req);
                }
            };

            for (size_t i = 0; i < num_threads; ++i)
            {
                threads_.emplace_back(process_requests);
            }
        }

        void new_request(
                const std::shared_ptr<RequestContext>& req)
        {
            std::lock_guard<std::mutex> lock(mtx_);
            if (!finished_)
            {
                requests_.push(req);
                cv_.notify_one();
            }
        }

        void stop()
        {
            // Notify all threads in the pool to stop
            {
                std::lock_guard<std::mutex> lock(mtx_);
                finished_ = true;
                cv_.notify_all();
            }

            // Wait for all threads to finish
            for (auto& thread : threads_)
            {
                if (thread.joinable())
                {
                    thread.join();
                }
            }
            threads_.clear();
        }

        $interface.name$ServerLogic& server_;
        std::mutex mtx_;
        std::condition_variable cv_;
        std::queue<std::shared_ptr<RequestContext\>> requests_;
        bool finished_{ false };
        std::vector<std::thread> threads_;
    };

    void process_request(
            const std::shared_ptr<RequestContext>& ctx)
    {
        auto id = ctx->info.related_sample_identity;

        {
            std::lock_guard<std::mutex> _(mtx_);
            auto it = processing_requests_.find(id);
            if (it != processing_requests_.end())
            {
                bool should_erase = false;
                it->second->process_additional_request(ctx, replier_, should_erase);
                if (should_erase)
                {
                    processing_requests_.erase(it);
                }
                return;
            }

            if (!ctx->prepare(replier_))
            {
                return;
            }

            processing_requests_[id] = ctx;
        }

        thread_pool_.new_request(ctx);
    }

    void execute_request(
            const std::shared_ptr<RequestContext>& req)
    {
        try
        {
            for(;;)
            {
                $interface.all_operations:{op | $call_operation(op)$}; separator="\n\n"$

                req->send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_UNSUPPORTED, replier_);
                break;
            }
        }
        catch (const frpc::RpcRemoteException& ex)
        {
            req->send_exception(ex.code(), replier_);
        }
        catch (...)
        {
            req->send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_UNKNOWN_EXCEPTION, replier_);
        }

        {
            std::lock_guard<std::mutex> _(mtx_);
            processing_requests_.erase(req->info.related_sample_identity);
        }
    }

    fdds::DomainParticipant& participant_;
    frpc::Service* service_ = nullptr;
    frpc::Replier* replier_ = nullptr;
    fdds::GuardCondition finish_condition_;
    std::mutex mtx_;
    std::map<frtps::SampleIdentity, std::shared_ptr<RequestContext\>> processing_requests_;
    ThreadPool thread_pool_;

};

}  // namespace detail

std::shared_ptr<$interface.name$Server> create_$interface.name$Server(
        eprosima::fastdds::dds::DomainParticipant& part,
        const char* service_name,
        const eprosima::fastdds::dds::ReplierQos& qos,
        size_t thread_pool_size)
{
    return std::make_shared<detail::$interface.name$ServerLogic>(part, service_name, qos, thread_pool_size);
}

//} interface $interface.name$

>>

operation_prepare_call(op) ::= <<
if (request.$op.name$.has_value())
{
    return prepare_$op.name$(replier);
}

>>

operation_prepare_impl(op) ::= <<
bool prepare_$op.name$(
        frpc::Replier* replier)
{
    static_cast<void>(replier);
$if(op.annotationFeed)$
    $op.name$_feeds.result_writer = std::make_shared<$op.name$_result_writer>(info, replier);
$endif$
$if(op.hasInputFeeds)$
    // TODO: prepare input feed handlers
$endif$
    return true;
}
>>

operation_declarations(op) ::= <<
//{ operation $op.name$

$if(op.annotationFeed)$
struct $op.name$_result_writer :
    public frpc::RpcServerWriter<$paramRetType(op.rettype)$>
{
    $op.name$_result_writer(
            const frpc::RequestInfo& info,
            frpc::Replier* replier)
        : info_(info)
        , replier_(replier)
    {
        reply_.$op.name$ = $op.parent.name$_$op.name$_Result{};
        reply_.$op.name$->result = $op.parent.name$_$op.name$_Out{};
    }

    void write(
            const $paramRetType(op.rettype)$& value) override
    {
        reply_.$op.name$->result->return_ = value;
        replier_->send_reply(&reply_, info_);
    }

    void write(
            $paramRetType(op.rettype)$&& value) override
    {
        reply_.$op.name$->result->return_ = value;
        replier_->send_reply(&reply_, info_);
    }

private:

    frpc::RequestInfo info_;
    frpc::Replier* replier_ = nullptr;
    ReplyType reply_{};

};

void $op.name$(
        const ClientContext& info,
$if(op.parameters)$
        $operation_parameters(op.parameters)$,
$endif$
        /*result*/ frpc::RpcServerWriter<$paramRetType(op.rettype)$>& result_writer);
$else$
$if(op.parameters)$
$paramRetType(op.rettype)$ $op.name$(
        const ClientContext& info,
        $operation_parameters(op.parameters)$);
$else$
$paramRetType(op.rettype)$ $op.name$(
        const ClientContext& info);
$endif$
$endif$

//} operation $op.name$
>>

operation_feed_members(op) ::= <<
struct $op.name$_feeds_t
{
$if(op.annotationFeed)$
    std::shared_ptr<$op.name$_result_writer> result_writer;
$endif$
} $op.name$_feeds;
>>

call_operation(op) ::= <<
if(req->request.$op.name$.has_value())
{
$if(op.exceptions)$
    try
$endif$
    {
$if(op.hasInputFeeds)$
        // TODO: Input feed operations
        req->send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_UNSUPPORTED, replier_);
$elseif(op.annotationFeed)$
        $op.name$(
            *req,
$if(op.parameters)$
            $op.parameters : {param | req->request.$op.name$->$param.name$}; separator=",\n"$,
$endif$
            *(req->$op.name$_feeds.result_writer));
        ReplyType reply{};
        reply.$op.name$ = $op.parent.name$_$op.name$_Result{};
        reply.$op.name$->result = $op.parent.name$_$op.name$_Out{};
        reply.$op.name$->result->finished_ = true;
        replier_->send_reply(&reply, req->info);
$else$
        $op.outputparam : {param | $param.typecode.cppTypename$ $param.name$ $if(param.onlyOutput)${\}$else$= req->request.$op.name$->$param.name$$endif$;}; separator="\n"$
        $if(op.rettype)$$op.rettype.cppTypename$ result = $else$/*void*/ $endif$$op.name$(
            *req$if(op.parameters)$,$else$);$endif$
$if(op.parameters)$
            $op.parameters : {param | $if(param.output)$$param.name$$else$req->request.$op.name$->$param.name$$endif$}; separator=",\n"$);
$endif$
        ReplyType reply{};
        reply.$op.name$ = $op.parent.name$_$op.name$_Result{};
        reply.$op.name$->result = $op.parent.name$_$op.name$_Out{};
        $op.outputparam : {param | reply.$op.name$->result->$param.name$ = $param.name$;}; separator="\n"$
$if(op.rettype)$
        reply.$op.name$->result->return_ = result;
$endif$
        replier_->send_reply(&reply, req->info);
$endif$
    }
    $op.exceptions : {ex | $operation_result_exception(op=op, typename=ex.scopedname, name=[ex.formatedScopedname, "_ex"])$}; separator="\n"$
    break;
}
>>

operation_parameters(params) ::= <<
$params : {param | /*$param.comment$*/ $if(param.output)$$paramTypeByRef(typecode=param.typecode)$$else$$paramTypeByValue(typecode=param.typecode, feed=param.annotationFeed, is_server=true)$$endif$ $param.name$}; anchor, separator=",\n"$
>>

operation_result_exception(op, typename, name) ::= <<
catch (const $typename$& ex)
{
    ReplyType reply{};
    reply.$op.name$ = $op.parent.name$_$op.name$_Result{};
    reply.$op.name$->$name$ = ex;
    replier_->send_reply(&reply, req->info);
}
>>
