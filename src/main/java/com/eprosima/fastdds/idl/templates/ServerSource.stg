// Copyright 2025 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

import "eprosima.stg"
import "com/eprosima/fastcdr/idl/templates/FastCdrCommon.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "Server.cxx"], description=["Server implementation for interfaces"])$

#include "$ctx.filename$Server.hpp"

#include <map>
#include <memory>
#include <mutex>
#include <stdexcept>
#include <string>

#include <fastdds/dds/builtin/topic/PublicationBuiltinTopicData.hpp>
#include <fastdds/dds/core/condition/Condition.hpp>
#include <fastdds/dds/core/condition/GuardCondition.hpp>
#include <fastdds/dds/core/condition/WaitSet.hpp>
#include <fastdds/dds/core/Time_t.hpp>
#include <fastdds/dds/domain/DomainParticipant.hpp>
#include <fastdds/dds/domain/qos/ReplierQos.hpp>
#include <fastdds/dds/rpc/exceptions.hpp>
#include <fastdds/dds/rpc/interfaces.hpp>
#include <fastdds/dds/rpc/RequestInfo.hpp>
#include <fastdds/dds/rpc/Replier.hpp>
#include <fastdds/dds/rpc/Service.hpp>
#include <fastdds/dds/rpc/ServiceTypeSupport.hpp>
#include <fastdds/dds/subscriber/DataReader.hpp>

#include "$ctx.filename$.hpp"
#include "$ctx.filename$_details.hpp"
#include "$ctx.filename$PubSubTypes.hpp"

$definitions; separator="\n"$
>>

module(ctx, parent, module, definition_list) ::= <<
namespace $module.name$ {

$definition_list$

} // namespace $module.name$

>>

interface(ctx, parent, interface, export_list) ::= <<
//{ interface $interface.name$

namespace detail {

namespace fdds = eprosima::fastdds::dds;
namespace frpc = eprosima::fastdds::dds::rpc;
namespace frtps = eprosima::fastdds::rtps;

class $interface.name$ServerLogic
    : public $interface.name$Server
{
    using RequestType = $interface.name$_Request;
    using ReplyType = $interface.name$_Reply;

public:

    $interface.name$ServerLogic(
            eprosima::fastdds::dds::DomainParticipant& part,
            const char* service_name,
            const eprosima::fastdds::dds::ReplierQos& qos,
            size_t thread_pool_size)
        : $interface.name$Server()
        , participant_(part)
    {
        // Register the service type support
        auto service_type = create_$interface.name$_service_type_support();
        auto ret = service_type.register_service_type(&participant_, "$interface.scopedname$");
        if (ret != fdds::RETCODE_OK)
        {
            throw std::runtime_error("Error registering service type");
        }

        // Create the service
        service_ = participant_.create_service(service_name, "$interface.scopedname$");
        if (nullptr == service_)
        {
            throw std::runtime_error("Error creating service");
        }

        // Create the replier
        replier_ = participant_.create_service_replier(service_, qos);
        if (nullptr == replier_)
        {
            throw std::runtime_error("Error creating requester");
        }

        // TODO: Create thread pool
        static_cast<void>(thread_pool_size);
    }

    ~$interface.name$ServerLogic() override
    {
        if (nullptr != replier_)
        {
            participant_.delete_service_replier(service_->get_service_name(), replier_);
        }
        if (nullptr != service_)
        {
            participant_.delete_service(service_);
        }
    }

    void run() override
    {
        finish_condition_.set_trigger_value(false);
        fdds::WaitSet waitset;
        waitset.attach_condition(finish_condition_);
        waitset.attach_condition(replier_->get_replier_reader()->get_statuscondition());

        while (true)
        {
            fdds::ConditionSeq active_conditions;
            waitset.wait(active_conditions, fdds::c_TimeInfinite);

            // Early exit if the finish condition is triggered
            if (finish_condition_.get_trigger_value())
            {
                break;
            }

            // Take and process the requests
            auto ctx = std::make_shared<RequestContext>();
            while (fdds::RETCODE_OK == ctx->take_from(replier_))
            {
                if (ctx->validate_request())
                {
                    process_request(ctx);
                }
                else
                {
                    ctx->send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_INVALID_ARGUMENT, replier_);
                }

                // Prepare next request context
                ctx = std::make_shared<RequestContext>();
            }
        }
    }

    void stop() override
    {
        finish_condition_.set_trigger_value(true);

        // TODO: Cancel all pending requests
        // TODO: Wait for all processing threads to finish
    }

private:

    struct RequestContext : ClientContext
    {
        RequestType request;
        frpc::RequestInfo info;
        frtps::GUID_t client_id;
        fdds::PublicationBuiltinTopicData pub_data;

        const frtps::GUID_t& get_client_id() const override
        {
            return client_id;
        }

        const frtps::RemoteLocatorList& get_client_locators() const override
        {
            return pub_data.remote_locators;
        }

        fdds::ReturnCode_t take_from(
                frpc::Replier* replier)
        {
            fdds::ReturnCode_t ret = replier->take_request(&request, info);
            if (ret == fdds::RETCODE_OK)
            {
                client_id = info.sample_identity.writer_guid();
                ret = replier->get_replier_reader()->get_matched_publication_data(pub_data, client_id);
            }
            return ret;
        }

        bool validate_request() const
        {
            size_t n_fields = 0;
            $interface.requestTypeCode.members:{member | n_fields += request.$member.name$.has_value() ? 1 : 0;}; separator="\n"$

            return n_fields == 1U;
        }

        void process_additional_request(
                const std::shared_ptr<RequestContext>& ctx,
                frpc::Replier* replier,
                bool& should_erase)
        {
            should_erase = false;
            if (ctx->info.related_sample_identity == info.related_sample_identity)
            {
                // TODO: Pass values from input streams
                send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_INVALID_ARGUMENT, replier);
                should_erase = true;
            }
            else
            {
                // This is not the expected request
                should_erase = true;
            }
        }

        bool prepare(
                frpc::Replier* replier)
        {
            send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_UNSUPPORTED, replier);
            return false;
        }

        void send_exception(
                frpc::RemoteExceptionCode_t ex,
                frpc::Replier* replier)
        {
            ReplyType reply{};
            reply.remoteEx = ex;
            replier->send_reply(&reply, info);
        }

    };

    void process_request(
            const std::shared_ptr<RequestContext>& ctx)
    {
        auto id = ctx->info.related_sample_identity;

        std::lock_guard<std::mutex> _(mtx_);
        auto it = processing_requests_.find(id);
        if (it != processing_requests_.end())
        {
            bool should_erase = false;
            it->second->process_additional_request(ctx, replier_, should_erase);
            if (should_erase)
            {
                processing_requests_.erase(it);
            }
            return;
        }

        if (!ctx->prepare(replier_))
        {
            return;
        }
        processing_requests_[id] = ctx;
    }

    fdds::DomainParticipant& participant_;
    frpc::Service* service_ = nullptr;
    frpc::Replier* replier_ = nullptr;
    fdds::GuardCondition finish_condition_;
    std::mutex mtx_;
    std::map<frtps::SampleIdentity, std::shared_ptr<RequestContext\>> processing_requests_;

};

}  // namespace detail

std::shared_ptr<$interface.name$Server> create_$interface.name$Server(
        eprosima::fastdds::dds::DomainParticipant& part,
        const char* service_name,
        const eprosima::fastdds::dds::ReplierQos& qos,
        size_t thread_pool_size)
{
    return std::make_shared<detail::$interface.name$ServerLogic>(part, service_name, qos, thread_pool_size);
}

//} interface $interface.name$

>>
