// Copyright 2023 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group XTypesTypeObjectSource;

import "eprosima.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx, file=[ctx.filename, "TypeObjectSupport.cxx"], description=["Source file containing the implementation to register the TypeObject representation of the described types in the IDL file"])$

#include "$ctx.filename$TypeObjectSupport.hpp"

#include <mutex>
#include <string>

#include <fastcdr/xcdr/external.hpp>
#include <fastcdr/xcdr/optional.hpp>
#include <fastdds/dds/domain/DomainParticipantFactory.hpp>
#include <fastdds/dds/log/Log.hpp>
#include <fastdds/dds/xtypes/common.hpp>
#include <fastdds/dds/xtypes/type_representation/ITypeObjectRegistry.hpp>
#include <fastdds/dds/xtypes/type_representation/TypeObject.hpp>
#include <fastdds/dds/xtypes/type_representation/TypeObjectUtils.hpp>

#include "$ctx.filename$.hpp"

$ctx.directIncludeDependencies : {include | #include "$include$.hpp"}; separator="\n"$

using namespace eprosima::fastdds::dds::xtypes;

$definitions; separator=""$

>>

module(ctx, parent, module, definition_list) ::= <<
namespace $module.name$ {
$definition_list$
} // namespace $module.name$

>>

definition_list(definitions) ::= <%
$definitions; separator=""$
%>

annotation(ctx, annotation) ::= <<

namespace $annotation.name$ {
    $annotation.enums : { enum | $enum_type(ctx=ctx, parent=annotation, enum=enum)$}; separator="\n"$

    $annotation.typeDefs : { typedef | $typedef_decl(ctx=ctx, parent=annotation, typedefs=typedef, typedefs_type="", declarator_type="")$}; separator="\n"$

    $annotation.constDecls : { const | $const_decl(ctx=ctx, parent=annotation, const=const, const_type="")$}; separator="\n"$

} // namespace $annotation.name$

void register_$annotation.name$_type_identifier(
        TypeIdentifierPair& type_ids_$annotation.name$)
{
    ReturnCode_t return_code_$annotation.name$ {eprosima::fastdds::dds::RETCODE_OK};
    $get_type_identifier_registry(typename=annotation.scopedname, name=annotation.name)$
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_$annotation.name$)
    {
        AnnotationTypeFlag annotation_flag_$annotation.name$ = 0;
        QualifiedTypeName annotation_name_$annotation.name$ = "$annotation.scopedname$";
        CompleteAnnotationHeader header_$annotation.name$ = TypeObjectUtils::build_complete_annotation_header(annotation_name_$annotation.name$);
        CompleteAnnotationParameterSeq member_seq_$annotation.name$;
        $if (annotation.members)$
        $annotation.members: { member | $annotation_parameter(param=member, parent=annotation)$}; separator="\n"$
        $endif$
        CompleteAnnotationType annotation_type_$annotation.name$ = TypeObjectUtils::build_complete_annotation_type(annotation_flag_$annotation.name$, header_$annotation.name$,
                member_seq_$annotation.name$);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_annotation_type_object(annotation_type_$annotation.name$,
                    annotation_name_$annotation.name$.to_string(), type_ids_$annotation.name$))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$annotation.scopedname$ already registered in TypeObjectRegistry for a different type.");
        }
    }
}

>>

bitmask_type(ctx, parent, bitmask) ::= <<
void register_$bitmask.name$_type_identifier(
        TypeIdentifierPair& type_ids_$bitmask.name$)
{
    ReturnCode_t return_code_$bitmask.name$ {eprosima::fastdds::dds::RETCODE_OK};
    $get_type_identifier_registry(typename=bitmask.scopedname, name=bitmask.name)$
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_$bitmask.name$)
    {
        BitmaskTypeFlag bitmask_flags_$bitmask.name$ = 0;
        BitBound bit_bound_$bitmask.name$ = $bitmask.bitBound$;
        CommonEnumeratedHeader common_$bitmask.name$ = TypeObjectUtils::build_common_enumerated_header(bit_bound_$bitmask.name$, true);
        $complete_type_detail(type=bitmask, type_kind=" Bitmask", name=bitmask.name)$
        CompleteEnumeratedHeader header_$bitmask.name$ = TypeObjectUtils::build_complete_enumerated_header(common_$bitmask.name$, detail_$bitmask.name$, true);
        CompleteBitflagSeq flag_seq_$bitmask.name$;
        $bitmask.bitmasks: { bitflag | $bitflag_member(bitflag=bitflag, parent=bitmask, name=bitmask.name)$}; separator="\n"$
        CompleteBitmaskType bitmask_type_$bitmask.name$ = TypeObjectUtils::build_complete_bitmask_type(bitmask_flags_$bitmask.name$, header_$bitmask.name$, flag_seq_$bitmask.name$);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_bitmask_type_object(bitmask_type_$bitmask.name$,
                    type_name_$bitmask.name$.to_string(), type_ids_$bitmask.name$))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$bitmask.scopedname$ already registered in TypeObjectRegistry for a different type.");
        }
    }
}
>>


bitset_type(ctx, parent, bitset, extensions) ::= <<
void register_$bitset.name$_type_identifier(
        TypeIdentifierPair& type_ids_$bitset.name$)
{
    ReturnCode_t return_code_$bitset.name$ {eprosima::fastdds::dds::RETCODE_OK};
    $get_type_identifier_registry(typename=bitset.scopedname, name=bitset.name)$
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_$bitset.name$)
    {
        BitsetTypeFlag bitset_flags_$bitset.name$ = 0;
        $complete_type_detail(type=bitset, type_kind= " Bitset", name=bitset.name)$
        CompleteBitsetHeader header_$bitset.name$ = TypeObjectUtils::build_complete_bitset_header(detail_$bitset.name$);
        CompleteBitfieldSeq field_seq_$bitset.name$;
        $bitset.definedBitfields: { bitfield | $bitfield_member(bitfield=bitfield, parent=bitset, name=bitset.name)$}; separator="\n"$
        CompleteBitsetType bitset_type_$bitset.name$ = TypeObjectUtils::build_complete_bitset_type(bitset_flags_$bitset.name$, header_$bitset.name$, field_seq_$bitset.name$);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_bitset_type_object(bitset_type_$bitset.name$,
                    type_name_$bitset.name$.to_string(), type_ids_$bitset.name$))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$bitset.scopedname$ already registered in TypeObjectRegistry for a different type.");
        }
    }
}
>>


enum_type(ctx, parent, enum) ::= <<
void register_$enum.name$_type_identifier(
        TypeIdentifierPair& type_ids_$enum.name$)
{
    ReturnCode_t return_code_$enum.name$ {eprosima::fastdds::dds::RETCODE_OK};
    $get_type_identifier_registry(typename=enum.scopedname, name=enum.name)$
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_$enum.name$)
    {
        EnumTypeFlag enum_flags_$enum.name$ = 0;
        BitBound bit_bound_$enum.name$ = $enum.bitBound$;
        CommonEnumeratedHeader common_$enum.name$ = TypeObjectUtils::build_common_enumerated_header(bit_bound_$enum.name$);
        $complete_type_detail(type=enum, type_kind=" Enum", name=enum.name)$
        CompleteEnumeratedHeader header_$enum.name$ = TypeObjectUtils::build_complete_enumerated_header(common_$enum.name$, detail_$enum.name$);
        CompleteEnumeratedLiteralSeq literal_seq_$enum.name$;
        $enum.members: { member | $enum_literal(literal=member, parent=enum, name=enum.name)$}; separator="\n"$
        CompleteEnumeratedType enumerated_type_$enum.name$ = TypeObjectUtils::build_complete_enumerated_type(enum_flags_$enum.name$, header_$enum.name$,
                literal_seq_$enum.name$);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_enumerated_type_object(enumerated_type_$enum.name$, type_name_$enum.name$.to_string(), type_ids_$enum.name$))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$enum.scopedname$ already registered in TypeObjectRegistry for a different type.");
        }
    }
}
>>

struct_type(ctx, parent, struct, member_list) ::= <<
// TypeIdentifier is returned by reference: dependent structures/unions are registered in this same method
void register_$struct.name$_type_identifier(
        TypeIdentifierPair& type_ids_$struct.name$)
{
    $if (struct.nonForwardedContent)$

    ReturnCode_t return_code_$struct.name$ {eprosima::fastdds::dds::RETCODE_OK};
    $if (ctx.GenerateTypesROS2)$
    $get_type_identifier_registry(typename=struct.ROS2Scopedname, name=struct.name)$
    $else$
    $get_type_identifier_registry(typename=struct.scopedname, name=struct.name)$
    $endif$
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_$struct.name$)
    {
        StructTypeFlag struct_flags_$struct.name$ = TypeObjectUtils::build_struct_type_flag($extensibility(object=struct)$
                $struct.annotationNested$, $struct.annotationAutoidHash$);
        $if (struct.inheritance)$
        $get_type_identifier(type=struct.inheritance, name=struct.name)$
        if (return_code_$struct.name$ != eprosima::fastdds::dds::RETCODE_OK)
        {
            $struct.inheritance.scope$::register_$struct.inheritance.name$_type_identifier(type_ids_$struct.name$);
        }
        $endif$
        $complete_type_detail(type=struct, type_kind=" Structure", name=struct.name)$
        CompleteStructHeader header_$struct.name$;
        $if (struct.inheritance)$
        if (EK_COMPLETE == type_ids_$struct.name$.type_identifier1()._d())
        {
            header_$struct.name$ = TypeObjectUtils::build_complete_struct_header(type_ids_$struct.name$.type_identifier1(), detail_$struct.name$);
        }
        else if (EK_COMPLETE == type_ids_$struct.name$.type_identifier2()._d())
        {
            header_$struct.name$ = TypeObjectUtils::build_complete_struct_header(type_ids_$struct.name$.type_identifier2(), detail_$struct.name$);
        }
        else
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "$struct.scopedname$ Structure: base_type TypeIdentifier registered in TypeObjectRegistry is inconsistent.");
            return;
        }
        $else$
        header_$struct.name$ = TypeObjectUtils::build_complete_struct_header(TypeIdentifier(), detail_$struct.name$);
        $endif$
        CompleteStructMemberSeq member_seq_$struct.name$;
        $if (struct.members)$
        $struct.members: { member | $struct_member(member=member, parent=struct)$}; separator="\n"$
        $endif$
        CompleteStructType struct_type_$struct.name$ = TypeObjectUtils::build_complete_struct_type(struct_flags_$struct.name$, header_$struct.name$, member_seq_$struct.name$);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_struct_type_object(struct_type_$struct.name$, type_name_$struct.name$.to_string(), type_ids_$struct.name$))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "$struct.scopedname$ already registered in TypeObjectRegistry for a different type.");
        }
    }
    $else$
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "$struct.scopedname$ contains forward declarations (not yet supported).");
    $endif$
}

>>

typedef_decl(ctx, parent, typedefs, typedefs_type, declarator_type) ::= <<
$typedefs : { typedef |
void register_$typedef.name$_type_identifier(
        TypeIdentifierPair& type_ids_$typedef.name$)
{
    $! TODO(jlbueno): annotated collections aliases are considered non-anonymous collections.
                      pending implementation of annotated collection support !$
    ReturnCode_t return_code_$typedef.name$ {eprosima::fastdds::dds::RETCODE_OK\};
    $get_type_identifier_registry(typename=typedef.scopedname, name=typedef.name)$
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_$typedef.name$)
    {
        AliasTypeFlag alias_flags_$typedef.name$ = 0;
        $complete_type_detail(type=typedef, type_kind=" Alias", name=typedef.name)$
        CompleteAliasHeader header_$typedef.name$ = TypeObjectUtils::build_complete_alias_header(detail_$typedef.name$);
        AliasMemberFlag related_flags_$typedef.name$ = 0;
        $get_type_identifier(type=typedef.typedefContentTypeCode, name=typedef.name)$
        $check_register_type_identifier(type=typedef.typedefContentTypeCode, message=[typedef.scopedname, " related"], name=typedef.name)$
        bool common_$typedef.name$_ec {false\};
        CommonAliasBody common_$typedef.name$ {TypeObjectUtils::build_common_alias_body(related_flags_$typedef.name$,
                TypeObjectUtils::retrieve_complete_type_identifier(type_ids_$typedef.name$, common_$typedef.name$_ec))\};
        if (!common_$typedef.name$_ec)
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "$typedef.scopedname$ related TypeIdentifier inconsistent.");
            return;
        \}
        eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_$typedef.name$;
        ann_custom_$typedef.name$.reset();
        $if (typedef.annotationList)$
        eprosima::fastcdr::optional<std::string> unit_$typedef.name$;
        eprosima::fastcdr::optional<AnnotationParameterValue> min_$typedef.name$;
        eprosima::fastcdr::optional<AnnotationParameterValue> max_$typedef.name$;
        eprosima::fastcdr::optional<std::string> hash_id_$typedef.name$;
        $typedef.annotationList : { annotation |
        $if (annotation.isUnit)$
        unit_$typedef.name$ = $annotation.value$;
        $elseif (annotation.isMin || annotation.isMax || annotation.isRange)$
        EPROSIMA_LOG_WARNING(XTYPES_TYPE_REPRESENTATION,
                "$typedef.scopedname$ Alias: @min, @max, and @range builtin annotations not yet supported");
        $elseif (annotation.isHashId)$
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$typedef.scopedname$ Alias: @hashid builtin annotation does not apply to aliases");
        return;
        $endif$
        }; separator="\n"$
        if (unit_$typedef.name$.has_value() || min_$typedef.name$.has_value() || max_$typedef.name$.has_value() ||
                hash_id_$typedef.name$.has_value())
        {
            member_ann_builtin_$typedef.name$ =
                TypeObjectUtils::build_applied_builtin_member_annotations(unit_$typedef.name$, min_$typedef.name$,
                        max_$typedef.name$, hash_id_$typedef.name$);
        \}
        $endif$
        CompleteAliasBody body_$typedef.name$ = TypeObjectUtils::build_complete_alias_body(common_$typedef.name$,
                member_ann_builtin_$typedef.name$, ann_custom_$typedef.name$);
        CompleteAliasType alias_type_$typedef.name$ = TypeObjectUtils::build_complete_alias_type(alias_flags_$typedef.name$,
                header_$typedef.name$, body_$typedef.name$);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_alias_type_object(alias_type_$typedef.name$,
                    type_name_$typedef.name$.to_string(), type_ids_$typedef.name$))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$typedef.scopedname$ already registered in TypeObjectRegistry for a different type.");
        \}
    \}
\}

}; separator="\n"$
>>

union_type(ctx, parent, union, extensions, switch_type) ::= <<
// TypeIdentifier is returned by reference: dependent structures/unions are registered in this same method
void register_$union.name$_type_identifier(
        TypeIdentifierPair& type_ids_$union.name$)
{
    $if (union.nonForwardedContent)$
    ReturnCode_t return_code_$union.name$ {eprosima::fastdds::dds::RETCODE_OK};
    $get_type_identifier_registry(typename=union.scopedname, name=union.name)$
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_$union.name$)
    {
        UnionTypeFlag union_flags_$union.name$ = TypeObjectUtils::build_union_type_flag($extensibility(object=union)$
                $union.annotationNested$, $union.annotationAutoidHash$);
        $complete_type_detail(type=union, type_kind=" Union", name=union.name)$
        CompleteUnionHeader header_$union.name$ = TypeObjectUtils::build_complete_union_header(detail_$union.name$);
        UnionDiscriminatorFlag member_flags_$union.name$ = TypeObjectUtils::build_union_discriminator_flag($try_construct(object=union.discriminator)$
                $union.discriminator.annotationKey$);
        $get_type_identifier(type=union.discriminator.typecode, name=union.name)$
        if (return_code_$union.name$ != eprosima::fastdds::dds::RETCODE_OK)
        {
            $if (union.discriminator.typecode.isAliasType)$
            $union.discriminator.typecode.scope$::register_$union.discriminator.typecode.name$_type_identifier(type_ids_$union.name$);
            $elseif (union.discriminator.typecode.isEnumType)$
            $union.discriminator.typecode.scope$::register_$union.discriminator.typecode.name$_type_identifier(type_ids_$union.name$);
            $else$
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "Union discriminator TypeIdentifier unknown to TypeObjectRegistry.");
            return;
            $endif$
        }
        CommonDiscriminatorMember common_$union.name$;
        if (EK_COMPLETE == type_ids_$union.name$.type_identifier1()._d() || TK_NONE == type_ids_$union.name$.type_identifier2()._d())
        {
            common_$union.name$ = TypeObjectUtils::build_common_discriminator_member(member_flags_$union.name$, type_ids_$union.name$.type_identifier1());
        }
        else if (EK_COMPLETE == type_ids_$union.name$.type_identifier2()._d())
        {
            common_$union.name$ = TypeObjectUtils::build_common_discriminator_member(member_flags_$union.name$, type_ids_$union.name$.type_identifier2());
        }
        else
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "$union.scopedname$ discriminator TypeIdentifier inconsistent.");
            return;
        }
        type_ann_builtin_$union.name$.reset();
        ann_custom_$union.name$.reset();
        $type_annotations(type=union.discriminator, type_kind=" Union Discriminator", name=union.name)$
        CompleteDiscriminatorMember discriminator_$union.name$ = TypeObjectUtils::build_complete_discriminator_member(common_$union.name$,
                type_ann_builtin_$union.name$, ann_custom_$union.name$);
        CompleteUnionMemberSeq member_seq_$union.name$;
        $union.members : { member | $union_member(member=member, parent=union)$}; separator="\n"$
        CompleteUnionType union_type_$union.name$ = TypeObjectUtils::build_complete_union_type(union_flags_$union.name$, header_$union.name$, discriminator_$union.name$,
                member_seq_$union.name$);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_union_type_object(union_type_$union.name$, type_name_$union.name$.to_string(), type_ids_$union.name$))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "$union.scopedname$ already registered in TypeObjectRegistry for a different type.");
        }
    }
    $else$
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "$union.scopedname$ contains forward declarations (not yet supported).");
    $endif$
}

>>

/***** Utils *****/
register_type(ctx, object) ::= <<
$if (object.isTypeDeclaration)$
$if ((object.typeCode.isStructType || object.typeCode.isUnionType) && !object.typeCode.forwarded)$
$if (!object.scope.empty)$$object.scope$::$endif$register_$object.name$_type_identifier(type_id);
$endif$
$elseif (object.isAnnotation)$
$if (!object.scope.empty)$$object.scope$::$endif$register_$object.name$_type_identifier(type_id);
$endif$
>>

get_type_identifier(type, name) ::= <<
$if (type.isAliasType)$
$get_type_identifier_registry(typename=type.scopedname, name=name)$
$elseif (type.primitive && !type.isEnumType)$
$get_type_identifier_registry(typename=["_", type.cppTypenameForTypeId], name=name)$
$elseif (type.isStringType)$
$get_type_identifier_registry(typename=string_name(string=type), name=name)$
$elseif (type.isWStringType)$
$get_type_identifier_registry(typename=wstring_name(wstring=type), name=name)$
$elseif (type.isArrayType)$
$get_type_identifier_registry(typename=array_name(array=type), name=name)$
$elseif (type.isSequenceType)$
$get_type_identifier_registry(typename=sequence_name(sequence=type), name=name)$
$elseif (type.isMapType)$
$get_type_identifier_registry(typename=map_name(map=type), name=name)$
$elseif (type.isStructType && ctx.GenerateTypesROS2)$
$get_type_identifier_registry(typename=type.ROS2Scopedname, name=name)$
$else$
$get_type_identifier_registry(typename=type.scopedname, name=name)$
$endif$
>>

get_type_identifier_registry(typename, name) ::= <<
return_code_$name$ =
    eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
    "$typename$", type_ids_$name$);
>>

applied_annotation_sequence(annotation, typename, member, name) ::= <<
{
    eprosima::fastcdr::optional<AppliedAnnotationParameterSeq> applied_annotation_parameter_seq_$member.name$;
    AppliedAnnotationParameterSeq tmp_applied_annotation_parameter_seq_$member.name$;
    $if (annotation.valueList)$
$annotation.valueList : { param |
{
    NameHash paramname_hash_$param.name$ = TypeObjectUtils::name_hash("$param.name$");
    $annotation_parameter_value(param=param, type=param.typecode)$
    AppliedAnnotationParameter applied_param_$param.name$ = TypeObjectUtils::build_applied_annotation_parameter(paramname_hash_$param.name$,
            param_value_$param.name$);
    TypeObjectUtils::add_applied_annotation_parameter(tmp_applied_annotation_parameter_seq_$member.name$, applied_param_$param.name$);
\}
}; separator="\n"$
$endif$
    {
        AppliedAnnotation applied_annotation_$member.name$;
        ReturnCode_t return_code_$annotation.name$ {eprosima::fastdds::dds::RETCODE_OK};
        TypeIdentifierPair type_ids_$annotation.annotationDeclaration.name$;
        $get_type_identifier_registry(typename=annotation.scopedname, name=annotation.name)$
        if (return_code_$annotation.name$ != eprosima::fastdds::dds::RETCODE_OK)
        {
            $annotation.annotationDeclaration.scope$::register_$annotation.annotationDeclaration.name$_type_identifier(type_ids_$annotation.annotationDeclaration.name$);
        }
        if (!tmp_applied_annotation_parameter_seq_$member.name$.empty())
        {
            applied_annotation_parameter_seq_$member.name$ = tmp_applied_annotation_parameter_seq_$member.name$;
        }
        if (EK_COMPLETE == type_ids_$annotation.annotationDeclaration.name$.type_identifier1()._d())
        {
            applied_annotation_$member.name$ =
                TypeObjectUtils::build_applied_annotation(type_ids_$annotation.annotationDeclaration.name$.type_identifier1(), applied_annotation_parameter_seq_$member.name$);
        }
        else if (EK_COMPLETE == type_ids_$annotation.annotationDeclaration.name$.type_identifier2()._d())
        {
            applied_annotation_$member.name$ =
                TypeObjectUtils::build_applied_annotation(type_ids_$annotation.annotationDeclaration.name$.type_identifier2(), applied_annotation_parameter_seq_$member.name$);
        }
        else
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "$typename$: Given Annotation TypeIdentifier is inconsistent.");
            return;
        }
        TypeObjectUtils::add_applied_annotation(tmp_ann_custom_$member.name$, applied_annotation_$member.name$);
    \}
}
>>

annotation_parameter_value(param, type) ::= <<
$if (type.isAliasType)$
$annotation_parameter_value(param=param, type=param.typecode.typedefContentTypeCode)$
$elseif (type.isEnumType)$
AnnotationParameterValue param_value_$param.name$ = TypeObjectUtils::build_annotation_parameter_value_enum($param.value$);
$elseif (type.isByteType)$
AnnotationParameterValue param_value_$param.name$ = TypeObjectUtils::build_annotation_parameter_value_byte($param.value$);
$elseif (param.typecode.isStringType)$
AnnotationParameterValue param_value_$param.name$ = TypeObjectUtils::build_annotation_parameter_value(eprosima::fastcdr::fixed_string<128>("$param.value$"));
$else$
AnnotationParameterValue param_value_$param.name$ = TypeObjectUtils::build_annotation_parameter_value(static_cast<$type.cppTypename$>($param.value$));
$endif$
>>

applied_verbatim_annotation(annotation, name) ::= <<
PlacementKindValue placement_$name$ = BEFORE_DECLARATION;
eprosima::fastcdr::fixed_string<32> language_$name$ = "*";
std::string text_$name$;
$annotation.valueList : { verbatim_param |
$if (verbatim_param.isVerbatimPlacement)$
placement_$name$ = $verbatim_param.enumStringValue$;
$elseif (verbatim_param.isVerbatimLanguage)$
language_$name$ = "$verbatim_param.value$";
$elseif (verbatim_param.isVerbatimText)$
text_$name$ = "$verbatim_param.value$";
$endif$
}; separator="\n"$
verbatim_$name$ = TypeObjectUtils::build_applied_verbatim_annotation(placement_$name$, language_$name$, text_$name$);
type_ann_builtin_$name$ = TypeObjectUtils::build_applied_builtin_type_annotations(verbatim_$name$);
>>

annotation_parameter(param, parent) ::= <<
{
    ReturnCode_t return_code_$param.name$;
    TypeIdentifierPair type_ids_$param.name$;
    AnnotationParameterFlag member_flags_$param.name$ = 0;
    $get_type_identifier(type=param.typecode, name=param.name)$
    if (return_code_$param.name$ != eprosima::fastdds::dds::RETCODE_OK)
    {
        $if (param.typecode.isAliasType)$
        $param.typecode.scope$::register_$param.typecode.name$_type_identifier(type_ids_$param.name$);
        $elseif (param.typecode.isEnumType)$
        $param.typecode.scope$::register_$param.typecode.name$_type_identifier(type_ids_$param.name$);
        $elseif (param.typecode.isStringType)$
        $register_string_type(string=param.typecode, name=param.name)$
        $elseif (param.typecode.isWStringType)$
        $register_wstring_type(wstring=param.typecode, name=param.name)$
        $else$
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$param.name$ annotation parameter TypeIdentifier unknown to TypeObjectRegistry.");
        return;
        $endif$
    }
    CommonAnnotationParameter common_$param.name$;
    if (EK_COMPLETE == type_ids_$param.name$.type_identifier1()._d() || TK_NONE == type_ids_$param.name$.type_identifier2()._d())
    {
        common_$param.name$ = TypeObjectUtils::build_common_annotation_parameter(member_flags_$param.name$, type_ids_$param.name$.type_identifier1());
    }
    else if (EK_COMPLETE == type_ids_$param.name$.type_identifier2()._d())
    {
        common_$param.name$ = TypeObjectUtils::build_common_annotation_parameter(member_flags_$param.name$, type_ids_$param.name$.type_identifier2());
    }
    else
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$param.name$ annotation parameter TypeIdentifier inconsistent.");
        return;
    }
    MemberName name_$param.name$ = "$param.name$";
    $annotation_parameter_value(param=param, type=param.typecode)$
    CompleteAnnotationParameter param_$param.name$ = TypeObjectUtils::build_complete_annotation_parameter(common_$param.name$, name_$param.name$, param_value_$param.name$);
    TypeObjectUtils::add_complete_annotation_parameter(member_seq_$parent.name$, param_$param.name$);
}
>>

struct_member(member, parent) ::= <<
{
    TypeIdentifierPair type_ids_$member.name$;
    ReturnCode_t return_code_$member.name$ {eprosima::fastdds::dds::RETCODE_OK};
    $get_type_identifier(type=member.typecode, name=member.name)$
    $check_register_type_identifier(type=member.typecode, message=[member.name, " Structure member"], name=[member.name])$
    StructMemberFlag member_flags_$member.name$ = TypeObjectUtils::build_struct_member_flag($try_construct(object=member)$
            $member.annotationOptional$, $member.annotationMustUnderstand$, $member.annotationKey$, $member.annotationExternal$);
    MemberId member_id_$member.name$ = $member.id$;
    bool common_$member.name$_ec {false};
    CommonStructMember common_$member.name$ {TypeObjectUtils::build_common_struct_member(member_id_$member.name$, member_flags_$member.name$, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_$member.name$, common_$member.name$_ec))};
    if (!common_$member.name$_ec)
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure $member.name$ member TypeIdentifier inconsistent.");
        return;
    }
    $complete_member_detail(member=member, parent=parent, type_kind="Structure", name=parent.name)$
    CompleteStructMember member_$member.name$ = TypeObjectUtils::build_complete_struct_member(common_$member.name$, detail_$member.name$);
    TypeObjectUtils::add_complete_struct_member(member_seq_$parent.name$, member_$member.name$);
}
>>

union_member(member, parent) ::= <<
{
    $get_type_identifier(type=member.typecode, name=parent.name)$
    $check_register_type_identifier(type=member.typecode, message=[member.name, " Union member"], name=[parent.name])$
    UnionMemberFlag member_flags_$member.name$ = TypeObjectUtils::build_union_member_flag($try_construct(object=member)$
            $member.default$, $member.annotationExternal$);
    UnionCaseLabelSeq label_seq_$member.name$;
    $if (member.labels)$
    $member.labels : { label | TypeObjectUtils::add_union_case_label(label_seq_$member.name$, static_cast<int32_t>($label$));}; separator="\n"$
    $endif$
    MemberId member_id_$member.name$ = $member.id$;
    bool common_$member.name$_ec {false};
    CommonUnionMember common_$member.name$ {TypeObjectUtils::build_common_union_member(member_id_$member.name$,
            member_flags_$member.name$, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_$parent.name$,
                common_$member.name$_ec), label_seq_$member.name$)};
    if (!common_$member.name$_ec)
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Union $member.name$ member TypeIdentifier inconsistent.");
        return;
    }
    $complete_member_detail(member=member, parent=parent, type_kind="Union", name=parent.name)$
    CompleteUnionMember member_$member.name$ = TypeObjectUtils::build_complete_union_member(common_$member.name$, detail_$member.name$);
    TypeObjectUtils::add_complete_union_member(member_seq_$parent.name$, member_$member.name$);
}
>>

bitfield_member(bitfield, parent, name) ::= <<
{
    uint16_t position_$bitfield.name$ = $bitfield.basePosition$;
    BitsetMemberFlag flags_$bitfield.name$ = 0;
    uint8_t bitcount_$bitfield.name$ = $bitfield.spec.bitSize$;
    TypeKind holder_type_$bitfield.name$ = $bitfield.spec.typecode.typeIdentifier$;
    CommonBitfield common_$bitfield.name$ = TypeObjectUtils::build_common_bitfield(position_$bitfield.name$, flags_$bitfield.name$, bitcount_$bitfield.name$, holder_type_$bitfield.name$);
    $empty_ann_builtin_complete_member_detail(member=bitfield, parent=parent, message=[parent.scopedname, " Bitset ", bitfield.name, " bitfield: no builtin annotation applies to bitfield declaration"], name=name)$
    CompleteBitfield bitfield_$bitfield.name$ = TypeObjectUtils::build_complete_bitfield(common_$bitfield.name$, detail_$bitfield.name$);
    TypeObjectUtils::add_complete_bitfield(field_seq_$parent.name$, bitfield_$bitfield.name$);
}
>>

register_sequence_type(sequence, name) ::= <<
$! TODO(jlbueno): annotated collections generate TypeObject instead of TypeIdentifier
                  pending implementation of annotated collection support !$
$plain_collection_header(type=sequence.contentTypeCode, message="Sequence element", name=name, collection_name=sequence_name(sequence))$
{
$if(sequence.isTypeIdentifierKindLarge)$
    LBound bound = $sequence.evaluatedMaxsize$;
    PlainSequenceLElemDefn seq_ldefn = TypeObjectUtils::build_plain_sequence_l_elem_defn(header_$sequence_name(sequence)$, bound,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$sequence_name(sequence)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_sequence_type_identifier(seq_ldefn, "$sequence_name(sequence)$", type_ids_$name$))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$sequence_name(sequence)$ already registered in TypeObjectRegistry for a different type.");
    }
$else$
    SBound bound = $if (sequence.unbound)$0$else$static_cast<SBound>($sequence.evaluatedMaxsize$)$endif$;
    PlainSequenceSElemDefn seq_sdefn = TypeObjectUtils::build_plain_sequence_s_elem_defn(header_$sequence_name(sequence)$, bound,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$sequence_name(sequence)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_sequence_type_identifier(seq_sdefn, "$sequence_name(sequence)$", type_ids_$name$))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$sequence_name(sequence)$ already registered in TypeObjectRegistry for a different type.");
    }
$endif$
}
>>

register_array_type(array, name) ::= <<
$! TODO(jlbueno): annotated collections generate TypeObject instead of TypeIdentifier
                  pending implementation of annotated collection support !$
$plain_collection_header(type=array.contentTypeCode, message="Array element", name=name, collection_name=array_name(array))$
{
$if(array.isTypeIdentifierKindLarge)$
    LBoundSeq array_bound_seq;
    $array.evaluatedDimensions: { dimension |
    TypeObjectUtils::add_array_dimension(array_bound_seq, static_cast<LBound>($dimension$));
    }; separator="\n"$
    PlainArrayLElemDefn array_ldefn = TypeObjectUtils::build_plain_array_l_elem_defn(header_$array_name(array)$, array_bound_seq,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$array_name(array)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_array_type_identifier(array_ldefn, "$array_name(array)$", type_ids_$name$))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$array_name(array)$ already registered in TypeObjectRegistry for a different type.");
    }
$else$
    SBoundSeq array_bound_seq;
    $array.evaluatedDimensions: { dimension |
    TypeObjectUtils::add_array_dimension(array_bound_seq, static_cast<SBound>($dimension$));
    }; separator="\n"$
    PlainArraySElemDefn array_sdefn = TypeObjectUtils::build_plain_array_s_elem_defn(header_$array_name(array)$, array_bound_seq,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$array_name(array)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_array_type_identifier(array_sdefn, "$array_name(array)$", type_ids_$name$))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$array_name(array)$ already registered in TypeObjectRegistry for a different type.");
    }
$endif$
}
>>

register_map_type(map, name) ::= <<
$! TODO(jlbueno): annotated collections generate TypeObject instead of TypeIdentifier
                  pending implementation of annotated collection support !$
$get_type_identifier(type=map.valueTypeCode, name=name)$
$check_register_type_identifier(type=map.valueTypeCode, message="Map element", name=[name])$
bool element_identifier_$map_name(map)$_ec {false};
TypeIdentifier* element_identifier_$map_name(map)$ {new TypeIdentifier(TypeObjectUtils::retrieve_complete_type_identifier(type_ids_$name$, element_identifier_$map_name(map)$_ec))};
if (!element_identifier_$map_name(map)$_ec)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$map_name(map)$ inconsistent element TypeIdentifier.");
    return;
}
$get_type_identifier(type=map.keyTypeCode, name=name)$
$check_register_type_identifier(type=map.keyTypeCode, message="Map key", name=[name])$
bool key_identifier_$map_name(map)$_ec {false};
TypeIdentifier* key_identifier_$map_name(map)$ {new TypeIdentifier(TypeObjectUtils::retrieve_complete_type_identifier(type_ids_$name$, key_identifier_$map_name(map)$_ec))};
if (!key_identifier_$map_name(map)$_ec)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$map_name(map)$ inconsistent key TypeIdentifier.");
    return;
}
EquivalenceKind equiv_kind_$map_name(map)$ = EK_BOTH;
if ((EK_COMPLETE == key_identifier_$map_name(map)$->_d() || EK_COMPLETE == element_identifier_$map_name(map)$->_d()) ||
        (TI_PLAIN_SEQUENCE_SMALL == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->seq_sdefn().header().equiv_kind()) ||
        (TI_PLAIN_SEQUENCE_LARGE == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->seq_ldefn().header().equiv_kind()) ||
        (TI_PLAIN_ARRAY_SMALL == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->array_sdefn().header().equiv_kind()) ||
        (TI_PLAIN_ARRAY_LARGE == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->array_ldefn().header().equiv_kind()) ||
        (TI_PLAIN_MAP_SMALL == element_identifier_$map_name(map)$->_d() && (EK_COMPLETE == element_identifier_$map_name(map)$->map_sdefn().key_identifier()->_d() || EK_COMPLETE == element_identifier_$map_name(map)$->map_sdefn().header().equiv_kind())) ||
        (TI_PLAIN_MAP_LARGE == element_identifier_$map_name(map)$->_d() && (EK_COMPLETE == element_identifier_$map_name(map)$->map_ldefn().key_identifier()->_d() || EK_COMPLETE == element_identifier_$map_name(map)$->map_ldefn().header().equiv_kind())))
{
    equiv_kind_$map_name(map)$ = EK_COMPLETE;
}
$! TODO(jlbueno) Annotated collections not yet supported !$
CollectionElementFlag element_flags_$map_name(map)$ = 0;
CollectionElementFlag key_flags_$map_name(map)$ = 0;
PlainCollectionHeader header_$map_name(map)$ = TypeObjectUtils::build_plain_collection_header(equiv_kind_$map_name(map)$, element_flags_$map_name(map)$);
{
$if(map.isTypeIdentifierKindLarge)$
    LBound bound = $map.evaluatedMaxsize$;
    PlainMapLTypeDefn map_ldefn = TypeObjectUtils::build_plain_map_l_type_defn(header_$map_name(map)$, bound,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$map_name(map)$), key_flags_$map_name(map)$,
                eprosima::fastcdr::external<TypeIdentifier>(key_identifier_$map_name(map)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_map_type_identifier(map_ldefn, "$map_name(map)$", type_ids_$name$))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$map_name(map)$ already registered in TypeObjectRegistry for a different type.");
    }
$else$
    SBound bound = $if (map.unbound)$0$else$static_cast<SBound>($map.evaluatedMaxsize$)$endif$;
    PlainMapSTypeDefn map_sdefn = TypeObjectUtils::build_plain_map_s_type_defn(header_$map_name(map)$, bound,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$map_name(map)$), key_flags_$map_name(map)$,
                eprosima::fastcdr::external<TypeIdentifier>(key_identifier_$map_name(map)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_map_type_identifier(map_sdefn, "$map_name(map)$", type_ids_$name$))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$map_name(map)$ already registered in TypeObjectRegistry for a different type.");
    }
$endif$
}
>>

enum_literal(literal, parent, name) ::= <<
{
    EnumeratedLiteralFlag flags_$literal.name$ = TypeObjectUtils::build_enumerated_literal_flag($literal.annotationDefaultLiteral$);
    CommonEnumeratedLiteral common_$literal.name$ = TypeObjectUtils::build_common_enumerated_literal($if(literal.annotationValue)$$literal.annotationValueValue$$else$$literal.index$$endif$, flags_$literal.name$);
    $empty_ann_builtin_complete_member_detail(member=literal, parent=parent, message=[parent.scopedname, " Enumerated ", literal.name, " literal: only @default_literal and @value builtin annotations apply to literals"], name=name)$
    CompleteEnumeratedLiteral literal_$literal.name$ = TypeObjectUtils::build_complete_enumerated_literal(common_$literal.name$, detail_$literal.name$);
    TypeObjectUtils::add_complete_enumerated_literal(literal_seq_$parent.name$, literal_$literal.name$);
}
>>

bitflag_member(bitflag, parent, name) ::= <<
{
    uint16_t position_$bitflag.name$ = $bitflag.position$;
    BitflagFlag flags_$bitflag.name$ = 0;
    CommonBitflag common_$bitflag.name$ = TypeObjectUtils::build_common_bitflag(position_$bitflag.name$, flags_$bitflag.name$);
    $empty_ann_builtin_complete_member_detail(member=bitflag, parent=parent, message=[parent.scopedname, " Bitmask ", bitflag.name, " bitflag: only @position builtin annotation apply to bitmask bitflags"], name=name)$
    CompleteBitflag bitflag_$bitflag.name$ = TypeObjectUtils::build_complete_bitflag(common_$bitflag.name$, detail_$bitflag.name$);
    TypeObjectUtils::add_complete_bitflag(flag_seq_$parent.name$, bitflag_$bitflag.name$);
}
>>

register_wstring_type(wstring, name) ::= <<
{
$if(wstring.isTypeIdentifierKindLarge)$
    LBound bound = $wstring.evaluatedMaxsize$;
    StringLTypeDefn string_ldefn = TypeObjectUtils::build_string_l_type_defn(bound);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_string_type_identifier(string_ldefn,
            "$wstring_name(wstring)$", type_ids_$name$, true))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$wstring_name(wstring)$ already registered in TypeObjectRegistry for a different type.");
    }
$else$
    SBound bound = $if (!wstring.isBounded)$0$else$static_cast<SBound>($wstring.evaluatedMaxsize$)$endif$;
    StringSTypeDefn string_sdefn = TypeObjectUtils::build_string_s_type_defn(bound);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_string_type_identifier(string_sdefn,
            "$wstring_name(wstring)$", type_ids_$name$, true))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$wstring_name(wstring)$ already registered in TypeObjectRegistry for a different type.");
    }
$endif$
}
>>

register_string_type(string, name) ::= <<
{
$if(string.isTypeIdentifierKindLarge)$
    LBound bound = $string.evaluatedMaxsize$;
    StringLTypeDefn string_ldefn = TypeObjectUtils::build_string_l_type_defn(bound);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_string_type_identifier(string_ldefn,
            "$string_name(string)$", type_ids_$name$))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$string_name(string)$ already registered in TypeObjectRegistry for a different type.");
    }
$else$
    SBound bound = $if (!string.isBounded)$0$else$static_cast<SBound>($string.evaluatedMaxsize$)$endif$;
    StringSTypeDefn string_sdefn = TypeObjectUtils::build_string_s_type_defn(bound);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_string_type_identifier(string_sdefn,
            "$string_name(string)$", type_ids_$name$))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$string_name(string)$ already registered in TypeObjectRegistry for a different type.");
    }
$endif$
}
>>

complete_type_detail(type, type_kind, name) ::= <<
$if (type.isStructType && ctx.GenerateTypesROS2)$
QualifiedTypeName type_name_$type.name$ = "$type.ROS2Scopedname$";
$else$
QualifiedTypeName type_name_$type.name$ = "$type.scopedname$";
$endif$
eprosima::fastcdr::optional<AppliedBuiltinTypeAnnotations> type_ann_builtin_$type.name$;
eprosima::fastcdr::optional<AppliedAnnotationSeq> ann_custom_$type.name$;
$type_annotations(type=type, type_kind=type_kind, name=name)$
CompleteTypeDetail detail_$type.name$ = TypeObjectUtils::build_complete_type_detail(type_ann_builtin_$type.name$, ann_custom_$type.name$, type_name_$type.name$.to_string());
>>

complete_member_detail(member, parent, type_kind, name) ::= <<
MemberName name_$member.name$ = "$member.name$";
eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_$member.name$;
ann_custom_$parent.name$.reset();
$if (member.annotationList)$
AppliedAnnotationSeq tmp_ann_custom_$member.name$;
eprosima::fastcdr::optional<std::string> unit_$member.name$;
eprosima::fastcdr::optional<AnnotationParameterValue> min_$member.name$;
eprosima::fastcdr::optional<AnnotationParameterValue> max_$member.name$;
eprosima::fastcdr::optional<std::string> hash_id_$member.name$;
$member.annotationList : { annotation |
$if (annotation.isUnit)$
unit_$member.name$ = $annotation.value$;
$elseif (annotation.isMin || annotation.isMax || annotation.isRange)$
EPROSIMA_LOG_WARNING(XTYPES_TYPE_REPRESENTATION,
        "$parent.scopedname$ $type_kind$ $member.name$ member: @min, @max, and @range builtin annotations not yet supported");
$elseif (annotation.isHashId)$
$if (annotation.value)$
hash_id_$member.name$ = "$annotation.value$";
$endif$
$elseif (!annotation.isBuiltin)$
$applied_annotation_sequence(annotation=annotation, typename=[parent.scopedname, " ", member.name, " member"], member=member, name=name)$
$endif$
}; separator="\n"$
if (unit_$member.name$.has_value() || min_$member.name$.has_value() || max_$member.name$.has_value() || hash_id_$member.name$.has_value())
{
    member_ann_builtin_$member.name$ = TypeObjectUtils::build_applied_builtin_member_annotations(unit_$member.name$, min_$member.name$, max_$member.name$, hash_id_$member.name$);
}
if (!tmp_ann_custom_$member.name$.empty())
{
    ann_custom_$parent.name$ = tmp_ann_custom_$member.name$;
}
$endif$
CompleteMemberDetail detail_$member.name$ = TypeObjectUtils::build_complete_member_detail(name_$member.name$, member_ann_builtin_$member.name$, ann_custom_$parent.name$);
>>

empty_ann_builtin_complete_member_detail(member, parent, message, name) ::= <<
eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_$member.name$;
ann_custom_$parent.name$.reset();
$if (member.annotationList)$
AppliedAnnotationSeq tmp_ann_custom_$member.name$;
$member.annotationList : { annotation |
$if (annotation.isUnit || annotation.isMin || annotation.isMax || annotation.isRange || annotation.isHashId)$
EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$message$");
return;
$elseif (!annotation.isBuiltin)$
$applied_annotation_sequence(annotation=annotation, typename=[parent.scopedname, " ", member.name, " member"], member=member, name=name)$
$endif$
}; separator="\n"$
if (!tmp_ann_custom_$member.name$.empty())
{
    ann_custom_$parent.name$ = tmp_ann_custom_$member.name$;
}
$endif$
MemberName name_$member.name$ = "$member.name$";
CompleteMemberDetail detail_$member.name$ = TypeObjectUtils::build_complete_member_detail(name_$member.name$, member_ann_builtin_$member.name$, ann_custom_$parent.name$);
>>

type_annotations(type, type_kind, name) ::= <<
$if (type.annotationList)$
AppliedAnnotationSeq tmp_ann_custom_$type.name$;
eprosima::fastcdr::optional<AppliedVerbatimAnnotation> verbatim_$type.name$;
$type.annotationList : { annotation |
$if (annotation.isVerbatim)$
$applied_verbatim_annotation(annotation=annotation, name=type.name)$
$elseif (!annotation.isBuiltin)$
$applied_annotation_sequence(annotation=annotation, typename=[type.scopedname, type_kind], member=type, name=name)$
$endif$
}; separator="\n"$
if (!tmp_ann_custom_$type.name$.empty())
{
    ann_custom_$name$ = tmp_ann_custom_$type.name$;
}
$endif$
>>

check_register_type_identifier(type, message, name) ::= <<
if (eprosima::fastdds::dds::RETCODE_OK != return_code_$name$)
{
    $if (type.isAliasType)$
    $type.scope$::register_$type.name$_type_identifier(type_ids_$name$);
    $elseif (type.isStructType)$
    $type.scope$::register_$type.name$_type_identifier(type_ids_$name$);
    $elseif (type.isUnionType)$
    $type.scope$::register_$type.name$_type_identifier(type_ids_$name$);
    $elseif (type.isBitsetType)$
    $type.scope$::register_$type.name$_type_identifier(type_ids_$name$);
    $elseif (type.isSequenceType)$
    $register_sequence_type(sequence=type, name=name)$
    $elseif (type.isArrayType)$
    $register_array_type(array=type, name=name)$
    $elseif (type.isMapType)$
    $register_map_type(map=type, name=name)$
    $elseif (type.isEnumType)$
    $type.scope$::register_$type.name$_type_identifier(type_ids_$name$);
    $elseif (type.isBitmaskType)$
    $type.scope$::register_$type.name$_type_identifier(type_ids_$name$);
    $elseif (type.isStringType)$
    $register_string_type(string=type, name=name)$
    $elseif (type.isWStringType)$
    $register_wstring_type(wstring=type, name=name)$
    $else$
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$message$ TypeIdentifier unknown to TypeObjectRegistry.");
    return;
    $endif$
}
>>

extensibility(object) ::= <%
$if (object.annotationAppendable)$
    eprosima::fastdds::dds::xtypes::ExtensibilityKind::APPENDABLE,
$elseif (object.annotationFinal)$
    eprosima::fastdds::dds::xtypes::ExtensibilityKind::FINAL,
$elseif (object.annotationMutable)$
    eprosima::fastdds::dds::xtypes::ExtensibilityKind::MUTABLE,
$endif$
%>

try_construct(object) ::= <%
$if (!object.annotationTryConstruct)$
    eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
$elseif (object.annotationDiscard)$
    eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
$elseif (object.annotationUseDefault)$
    eprosima::fastdds::dds::xtypes::TryConstructFailAction::USE_DEFAULT,
$elseif (object.annotationTrim)$
    eprosima::fastdds::dds::xtypes::TryConstructFailAction::TRIM,
$endif$
%>

plain_collection_header(type, message, name, collection_name) ::= <<
$get_type_identifier(type=type, name=name)$
$check_register_type_identifier(type=type, message=message, name=[name])$
bool element_identifier_$collection_name$_ec {false};
TypeIdentifier* element_identifier_$collection_name$ {new TypeIdentifier(TypeObjectUtils::retrieve_complete_type_identifier(type_ids_$name$, element_identifier_$collection_name$_ec))};
if (!element_identifier_$collection_name$_ec)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "$message$ TypeIdentifier inconsistent.");
    return;
}
EquivalenceKind equiv_kind_$collection_name$ = EK_COMPLETE;
if (TK_NONE == type_ids_$name$.type_identifier2()._d())
{
    equiv_kind_$collection_name$ = EK_BOTH;
}
$! TODO(jlbueno) Annotated collections not yet supported !$
CollectionElementFlag element_flags_$collection_name$ = 0;
PlainCollectionHeader header_$collection_name$ = TypeObjectUtils::build_plain_collection_header(equiv_kind_$collection_name$, element_flags_$collection_name$);
>>

//{ Fast DDS-Gen extensions
module_conversion(ctx, parent, modules, definition_list) ::= <<
$modules : { module |
namespace $module.name$ {
}; separator="\n"$

$definition_list$

$reverse(modules) : { module |
\} // namespace $module.name$
}; separator="\n"$
>>
//}
