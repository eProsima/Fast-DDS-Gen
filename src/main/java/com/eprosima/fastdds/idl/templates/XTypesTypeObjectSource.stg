// Copyright 2023 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group XTypesTypeObjectSource;

import "eprosima.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx, file=[ctx.filename, "TypeObjectSupport.cxx"], description=["Source file containing the implementation to register the TypeObject representation of the described types in the IDL file"])$

#include "$ctx.filename$TypeObjectSupport.hpp"

#include <mutex>
#include <string>

#include <fastcdr/xcdr/external.hpp>
#include <fastcdr/xcdr/optional.hpp>
#include <fastdds/dds/domain/DomainParticipantFactory.hpp>
#include <fastdds/dds/log/Log.hpp>
#include <fastdds/dds/xtypes/common.hpp>
#include <fastdds/dds/xtypes/type_representation/ITypeObjectRegistry.hpp>
#include <fastdds/dds/xtypes/type_representation/TypeObject.hpp>
#include <fastdds/dds/xtypes/type_representation/TypeObjectUtils.hpp>

#include "$ctx.filename$.hpp"

$ctx.directIncludeDependencies : {include | #include "$include$.hpp"}; separator="\n"$

using namespace eprosima::fastdds::dds::xtypes;

void register_$ctx.filename$_type_objects()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                $ctx.definitions: { def | $register_type(ctx=ctx, object=def)$}; separator=""$
            });
}

$definitions; separator=""$

>>

module(ctx, parent, module, definition_list) ::= <<
namespace $module.name$ {
$definition_list$
} // namespace $module.name$

>>

definition_list(definitions) ::= <%
$definitions; separator=""$
%>

annotation(ctx, annotation) ::= <<
void register_$annotation.CScopedname$_type_identifier()
{
    $register_annotation_type(annotation=annotation)$
}

>>

struct_type(ctx, parent, struct, member_list) ::= <<
void register_$struct.CScopedname$_type_identifier()
{
    $if (struct.nonForwardedContent)$
    $register_struct_type(struct)$
    $else$
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "$struct.CScopedname$ contains forward declarations (not yet supported).");
    $endif$
}

>>

union_type(ctx, parent, union, extensions, switch_type) ::= <<
void register_$union.CScopedname$_type_identifier()
{
    $if (union.nonForwardedContent)$
    $register_union_type(union)$
    $else$
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "$union.CScopedname$ contains forward declarations (not yet supported).");
    $endif$
}

>>

/***** Utils *****/
register_type(ctx, object) ::= <<
$if (object.isTypeDeclaration)$
$if ((object.typeCode.isStructType || object.typeCode.isUnionType) && !object.typeCode.forwarded)$
$if (!object.scope.empty)$$object.scope$::$endif$register_$object.CScopedname$_type_identifier();
$endif$
$elseif (object.isAnnotation)$
$if (!object.scope.empty)$$object.scope$::$endif$register_$object.CScopedname$_type_identifier();
$endif$
>>

get_type_identifier(type, name) ::= <<
$if (type.isAliasType)$
$get_type_identifier_registry(typename=type.scopedname, name=name)$
$elseif (type.isByteType)$
$get_type_identifier_registry(typename="_byte", name=name)$
$elseif (type.primitive && !type.isEnumType)$
$get_type_identifier_registry(typename=["_", type.cppTypenameForTypeId], name=name)$
$elseif (type.isStringType)$
$get_type_identifier_registry(typename=string_name(string=type), name=name)$
$elseif (type.isWStringType)$
$get_type_identifier_registry(typename=wstring_name(wstring=type), name=name)$
$elseif (type.isArrayType)$
$get_type_identifier_registry(typename=array_name(array=type), name=name)$
$elseif (type.isSequenceType)$
$get_type_identifier_registry(typename=sequence_name(sequence=type), name=name)$
$elseif (type.isMapType)$
$get_type_identifier_registry(typename=map_name(map=type), name=name)$
$else$
$get_type_identifier_registry(typename=type.scopedname, name=name)$
$endif$
>>

get_type_identifier_registry(typename, name) ::= <<
return_code_$name$ =
    eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
    "$typename$", type_ids_$name$);
>>

applied_annotation_sequence(annotation, typename, member, name) ::= <<
{
    eprosima::fastcdr::optional<AppliedAnnotationParameterSeq> applied_annotation_parameter_seq_$member.name$;
    AppliedAnnotationParameterSeq tmp_applied_annotation_parameter_seq_$member.name$;
    $if (annotation.valueList)$
$annotation.valueList : { param |
{
    NameHash paramname_hash_$param.name$ = TypeObjectUtils::name_hash("$param.name$");
    $annotation_parameter_value(param=param, type=param.typecode)$
    AppliedAnnotationParameter applied_param_$param.name$ = TypeObjectUtils::build_applied_annotation_parameter(paramname_hash_$param.name$,
            param_value_$param.name$);
    TypeObjectUtils::add_applied_annotation_parameter(tmp_applied_annotation_parameter_seq_$member.name$, applied_param_$param.name$);
\}
}; separator="\n"$
$endif$
    {
        AppliedAnnotation applied_annotation_$member.name$;
        $get_type_identifier_registry(typename=annotation.scopedname, name=name)$
        if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "$typename$: Given Annotation TypeIdentifier unknown to TypeObjectRegistry.");
            return;
        }
        if (!tmp_applied_annotation_parameter_seq_$member.name$.empty())
        {
            applied_annotation_parameter_seq_$member.name$ = tmp_applied_annotation_parameter_seq_$member.name$;
        }
        if (EK_COMPLETE == type_ids_$name$.type_identifier1()._d())
        {
            applied_annotation_$member.name$ = TypeObjectUtils::build_applied_annotation(type_ids_$name$.type_identifier1(), applied_annotation_parameter_seq_$member.name$);
        }
        else if (EK_COMPLETE == type_ids_$name$.type_identifier2()._d())
        {
            applied_annotation_$member.name$ = TypeObjectUtils::build_applied_annotation(type_ids_$name$.type_identifier2(), applied_annotation_parameter_seq_$member.name$);
        }
        else
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "$typename$: Given Annotation TypeIdentifier is inconsistent.");
            return;
        }
        TypeObjectUtils::add_applied_annotation(tmp_ann_custom_$member.name$, applied_annotation_$member.name$);
    \}
}
>>

annotation_parameter_value(param, type) ::= <<
$if (type.isAliasType)$
$annotation_parameter_value(param=param, type=param.typecode.typedefContentTypeCode)$
$elseif (type.isEnumType)$
AnnotationParameterValue param_value_$param.name$ = TypeObjectUtils::build_annotation_parameter_value_enum($param.value$);
$elseif (type.isByteType)$
AnnotationParameterValue param_value_$param.name$ = TypeObjectUtils::build_annotation_parameter_value_byte($param.value$);
$elseif (param.typecode.isStringType)$
AnnotationParameterValue param_value_$param.name$ = TypeObjectUtils::build_annotation_parameter_value(eprosima::fastcdr::fixed_string<128>("$param.value$"));
$else$
AnnotationParameterValue param_value_$param.name$ = TypeObjectUtils::build_annotation_parameter_value(static_cast<$type.cppTypename$>($param.value$));
$endif$
>>

applied_verbatim_annotation(annotation, name) ::= <<
PlacementKindValue placement_$name$ = BEFORE_DECLARATION;
eprosima::fastcdr::fixed_string<32> language_$name$ = "*";
std::string text_$name$;
$annotation.valueList : { verbatim_param |
$if (verbatim_param.isVerbatimPlacement)$
placement_$name$ = $verbatim_param.enumStringValue$;
$elseif (verbatim_param.isVerbatimLanguage)$
language_$name$ = "$verbatim_param.value$";
$elseif (verbatim_param.isVerbatimText)$
text_$name$ = "$verbatim_param.value$";
$endif$
}; separator="\n"$
verbatim_$name$ = TypeObjectUtils::build_applied_verbatim_annotation(placement_$name$, language_$name$, text_$name$);
type_ann_builtin_$annotation_name$ = TypeObjectUtils::build_applied_builtin_type_annotations(verbatim_$name$);
>>

register_alias_type(alias, name) ::= <<
$! TODO(jlbueno): annotated collections aliases are considered non-anonymous collections.
                  pending implementation of annotated collection support !$
AliasTypeFlag alias_flags_$alias.name$ = 0;
$complete_type_detail(type=alias, type_kind=" Alias", name=name)$
CompleteAliasHeader header_$alias.name$ = TypeObjectUtils::build_complete_alias_header(detail_$alias.name$);
AliasMemberFlag related_flags_$alias.name$ = 0;
$get_type_identifier(type=alias.typedefContentTypeCode, name=name)$
$check_register_type_identifier(type=alias.typedefContentTypeCode, message=[alias.scopedname, " related"], name=name)$
CommonAliasBody common_$alias.name$;
$check_first_returned_type_identifier_pair(name=name)$
{
    common_$alias.name$ = TypeObjectUtils::build_common_alias_body(related_flags_$alias.name$, type_ids_$name$.type_identifier1());
}
$check_second_returned_type_identifier_pair(name=name)$
{
    common_$alias.name$ = TypeObjectUtils::build_common_alias_body(related_flags_$alias.name$, type_ids_$name$.type_identifier2());
}
else
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$alias.scopedname$ related TypeIdentifier inconsistent.");
    return;
}
eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_$alias.name$;
ann_custom_$alias.name$.reset();
$if (alias.annotationList)$
eprosima::fastcdr::optional<std::string> unit_$alias.name$;
eprosima::fastcdr::optional<AnnotationParameterValue> min_$alias.name$;
eprosima::fastcdr::optional<AnnotationParameterValue> max_$alias.name$;
eprosima::fastcdr::optional<std::string> hash_id_$alias.name$;
$alias.annotationList : { annotation |
$if (annotation.isUnit)$
unit_$alias.name$ = $annotation.value$;
$elseif (annotation.isMin || annotation.isMax || annotation.isRange)$
EPROSIMA_LOG_WARNING(XTYPES_TYPE_REPRESENTATION,
        "$alias.scopedname$ Alias: @min, @max, and @range builtin annotations not yet supported");
$elseif (annotation.isHashId)$
EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$alias.scopedname$ Alias: @hashid builtin annotation does not apply to aliases");
return;
$endif$
}; separator="\n"$
if (unit_$alias.name$.has_value() || min_$alias.name$.has_value() || max_$alias.name$.has_value() || hash_id_$alias.name$.has_value())
{
    member_ann_builtin_$alias.name$ = TypeObjectUtils::build_applied_builtin_member_annotations(unit_$alias.name$, min_$alias.name$, max_$alias.name$, hash_id_$alias.name$);
}
$endif$
CompleteAliasBody body_$alias.name$ = TypeObjectUtils::build_complete_alias_body(common_$alias.name$, member_ann_builtin_$alias.name$, ann_custom_$alias.name$);
CompleteAliasType alias_type_$alias.name$ = TypeObjectUtils::build_complete_alias_type(alias_flags_$alias.name$, header_$alias.name$, body_$alias.name$);
if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
        TypeObjectUtils::build_and_register_alias_type_object(alias_type_$alias.name$, type_name_$alias.name$.to_string()))
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$alias.scopedname$ already registered in TypeObjectRegistry for a different type.");
}
$get_type_identifier_registry(typename=alias.scopedname, name=name)$
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$alias.scopedname$: Given Alias TypeIdentifier unknown to TypeObjectRegistry.");
    return;
}
>>

register_annotation_type(annotation) ::= <<
AnnotationTypeFlag annotation_flag_$annotation.name$ = 0;
QualifiedTypeName annotation_name_$annotation.name$ = "$annotation.scopedname$";
CompleteAnnotationHeader header_$annotation.name$ = TypeObjectUtils::build_complete_annotation_header(annotation_name_$annotation.name$);
CompleteAnnotationParameterSeq member_seq_$annotation.name$;
$if (annotation.members)$
$annotation.members: { member | $annotation_parameter(param=member, parent=annotation)$}; separator="\n"$
$endif$
CompleteAnnotationType annotation_type_$annotation.name$ = TypeObjectUtils::build_complete_annotation_type(annotation_flag_$annotation.name$, header_$annotation.name$,
        member_seq_$annotation.name$);
if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
        TypeObjectUtils::build_and_register_annotation_type_object(annotation_type_$annotation.name$, annotation_name_$annotation.name$.to_string()))
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$annotation.scopedname$ already registered in TypeObjectRegistry for a different type.");
}
>>

annotation_parameter(param, parent) ::= <<
{
    ReturnCode_t return_code_$param.name$;
    TypeIdentifierPair type_ids_$param.name$;
    AnnotationParameterFlag member_flags_$param.name$ = 0;
    $get_type_identifier(type=param.typecode, name=param.name)$
    if (return_code_$param.name$ != eprosima::fastdds::dds::RETCODE_OK)
    {
        $if (param.typecode.isAliasType)$
        $register_alias_type(alias=param.typecode, name=param.name)$
        $elseif (param.typecode.isEnumType)$
        $register_enum_type(enum=param.typecode, name=param.name)$
        $elseif (param.typecode.isStringType)$
        $register_string_type(string=param.typecode, name=param.name)$
        $elseif (param.typecode.isWStringType)$
        $register_wstring_type(wstring=param.typecode, name=param.name)$
        $else$
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$param.name$ annotation parameter TypeIdentifier unknown to TypeObjectRegistry.");
        return;
        $endif$
    }
    CommonAnnotationParameter common_$param.name$;
    if (EK_COMPLETE == type_ids_$param.name$.type_identifier1()._d() || TK_NONE == type_ids_$param.name$.type_identifier2()._d())
    {
        common_$param.name$ = TypeObjectUtils::build_common_annotation_parameter(member_flags_$param.name$, type_ids_$param.name$.type_identifier1());
    }
    else if (EK_COMPLETE == type_ids_$param.name$.type_identifier2()._d())
    {
        common_$param.name$ = TypeObjectUtils::build_common_annotation_parameter(member_flags_$param.name$, type_ids_$param.name$.type_identifier2());
    }
    else
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$param.name$ annotation parameter TypeIdentifier inconsistent.");
        return;
    }
    MemberName name_$param.name$ = "$param.name$";
    $annotation_parameter_value(param=param, type=param.typecode)$
    CompleteAnnotationParameter param_$param.name$ = TypeObjectUtils::build_complete_annotation_parameter(common_$param.name$, name_$param.name$, param_value_$param.name$);
    TypeObjectUtils::add_complete_annotation_parameter(member_seq_$parent.name$, param_$param.name$);
}
>>

register_struct_type(struct) ::= <<
{
    StructTypeFlag struct_flags_$struct.name$ = TypeObjectUtils::build_struct_type_flag($extensibility(object=struct)$
            $struct.annotationNested$, $struct.annotationAutoidHash$);
    ReturnCode_t return_code_$struct.name$;
    TypeIdentifierPair type_ids_$struct.name$;
    $if (struct.inheritance)$
    $get_type_identifier(type=struct.inheritance, name=struct.name)$
    if (return_code_$struct.name$ != eprosima::fastdds::dds::RETCODE_OK)
    {
        $register_struct_type(struct.inheritance)$
    }
    $endif$
    $complete_type_detail(type=struct, type_kind=" Structure", name=struct.name)$
    CompleteStructHeader header_$struct.name$;
    $if (struct.inheritance)$
    if (EK_COMPLETE == type_ids_$struct.name$.type_identifier1()._d() || TK_NONE == type_ids_$struct.name$.type_identifier1()._d())
    {
        header_$struct.name$ = TypeObjectUtils::build_complete_struct_header(type_ids_$struct.name$.type_identifier1(), detail_$struct.name$);
    }
    else if (EK_COMPLETE == type_ids_$struct.name$.type_identifier2()._d())
    {
        header_$struct.name$ = TypeObjectUtils::build_complete_struct_header(type_ids_$struct.name$.type_identifier2(), detail_$struct.name$);
    }
    else
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$struct.scopedname$ Structure: base_type TypeIdentifier registered in TypeObjectRegistry is inconsistent.");
        return;
    }
    $else$
    header_$struct.name$ = TypeObjectUtils::build_complete_struct_header(TypeIdentifier(), detail_$struct.name$);
    $endif$
    CompleteStructMemberSeq member_seq_$struct.name$;
    $if (struct.members)$
    $struct.members: { member | $struct_member(member=member, parent=struct)$}; separator="\n"$
    $endif$
    CompleteStructType struct_type_$struct.name$ = TypeObjectUtils::build_complete_struct_type(struct_flags_$struct.name$, header_$struct.name$, member_seq_$struct.name$);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_struct_type_object(struct_type_$struct.name$, type_name_$struct.name$.to_string()))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$struct.scopedname$ already registered in TypeObjectRegistry for a different type.");
    }
    $get_type_identifier_registry(typename=struct.scopedname, name=struct.name)$
    if (return_code_$struct.name$ != eprosima::fastdds::dds::RETCODE_OK)
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "$struct.scopedname$: Given Struct TypeIdentifier unknown to TypeObjectRegistry.");
        return;
    }
}
>>

struct_member(member, parent) ::= <<
{
    StructMemberFlag member_flags_$member.name$ = TypeObjectUtils::build_struct_member_flag($try_construct(object=member)$
            $member.annotationOptional$, $member.annotationMustUnderstand$, $member.annotationKey$, $member.annotationExternal$);
    $get_type_identifier(type=member.typecode, name=parent.name)$
    $check_register_type_identifier(type=member.typecode, message=[member.name, " Structure member"], name=parent.name)$
    CommonStructMember common_$member.name$;
    MemberId member_id_$member.name$ = $member.id$;
    $check_first_returned_type_identifier_pair(name=parent.name)$
    {
        common_$member.name$ = TypeObjectUtils::build_common_struct_member(member_id_$member.name$, member_flags_$member.name$, type_ids_$parent.name$.type_identifier1());
    }
    $check_second_returned_type_identifier_pair(name=parent.name)$
    {
        common_$member.name$ = TypeObjectUtils::build_common_struct_member(member_id_$member.name$, member_flags_$member.name$, type_ids_$parent.name$.type_identifier2());
    }
    else
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "Structure $member.name$ member TypeIdentifier inconsistent.");
        return;
    }
    $complete_member_detail(member=member, parent=parent, type_kind="Structure", name=parent.name)$
    CompleteStructMember member_$member.name$ = TypeObjectUtils::build_complete_struct_member(common_$member.name$, detail_$member.name$);
    TypeObjectUtils::add_complete_struct_member(member_seq_$parent.name$, member_$member.name$);
}
>>

register_union_type(union) ::= <<
{
    ReturnCode_t return_code_$union.name$;
    TypeIdentifierPair type_ids_$union.name$;
    UnionTypeFlag union_flags_$union.name$ = TypeObjectUtils::build_union_type_flag($extensibility(object=union)$
            $union.annotationNested$, $union.annotationAutoidHash$);
    $complete_type_detail(type=union, type_kind=" Union", name=union.name)$
    CompleteUnionHeader header_$union.name$ = TypeObjectUtils::build_complete_union_header(detail_$union.name$);
    UnionDiscriminatorFlag member_flags_$union.name$ = TypeObjectUtils::build_union_discriminator_flag($try_construct(object=union.discriminator)$
            $union.discriminator.annotationKey$);
    $get_type_identifier(type=union.discriminator.typecode, name=union.name)$
    if (return_code_$union.name$ != eprosima::fastdds::dds::RETCODE_OK)
    {
        $if (union.discriminator.typecode.isAliasType)$
        $register_alias_type(alias=union.discriminator.typecode, name=union.name)$
        $elseif (union.discriminator.typecode.isEnumType)$
        $register_enum_type(enum=union.discriminator.typecode, name=union.name)$
        $else$
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "Union discriminator TypeIdentifier unknown to TypeObjectRegistry.");
        return;
        $endif$
    }
    CommonDiscriminatorMember common_$union.name$;
    if (EK_COMPLETE == type_ids_$union.name$.type_identifier1()._d() || TK_NONE == type_ids_$union.name$.type_identifier2()._d())
    {
        common_$union.name$ = TypeObjectUtils::build_common_discriminator_member(member_flags_$union.name$, type_ids_$union.name$.type_identifier1());
    }
    else if (EK_COMPLETE == type_ids_$union.name$.type_identifier2()._d())
    {
        common_$union.name$ = TypeObjectUtils::build_common_discriminator_member(member_flags_$union.name$, type_ids_$union.name$.type_identifier2());
    }
    else
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$union.scopedname$ discriminator TypeIdentifier inconsistent.");
        return;
    }
    type_ann_builtin_$union.name$.reset();
    ann_custom_$union.name$.reset();
    $type_annotations(type=union.discriminator, type_kind=" Union Discriminator", name=union.name)$
    CompleteDiscriminatorMember discriminator_$union.name$ = TypeObjectUtils::build_complete_discriminator_member(common_$union.name$,
            type_ann_builtin_$union.name$, ann_custom_$union.name$);
    CompleteUnionMemberSeq member_seq_$union.name$;
    $union.members : { member | $union_member(member=member, parent=union)$}; separator="\n"$
    CompleteUnionType union_type_$union.name$ = TypeObjectUtils::build_complete_union_type(union_flags_$union.name$, header_$union.name$, discriminator_$union.name$,
            member_seq_$union.name$);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_union_type_object(union_type_$union.name$, type_name_$union.name$.to_string()))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$union.scopedname$ already registered in TypeObjectRegistry for a different type.");
    }
    $get_type_identifier_registry(typename=union.scopedname, name=union.name)$
    if (return_code_$union.name$ != eprosima::fastdds::dds::RETCODE_OK)
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "$union.scopedname$: Given Union TypeIdentifier unknown to TypeObjectRegistry.");
        return;
    }
}
>>

union_member(member, parent) ::= <<
{
    UnionMemberFlag member_flags_$member.name$ = TypeObjectUtils::build_union_member_flag($try_construct(object=member)$
            $member.default$, $member.annotationExternal$);
    $get_type_identifier(type=member.typecode, name=parent.name)$
    $check_register_type_identifier(type=member.typecode, message=[member.name, " Union member"], name=parent.name)$
    UnionCaseLabelSeq label_seq_$member.name$;
    $if (member.labels)$
    $member.labels : { label | TypeObjectUtils::add_union_case_label(label_seq_$member.name$, static_cast<int32_t>($label$));}; separator="\n"$
    $endif$
    CommonUnionMember common_$member.name$;
    MemberId member_id_$member.name$ = $member.id$;
    $check_first_returned_type_identifier_pair(name=parent.name)$
    {
        common_$member.name$ = TypeObjectUtils::build_common_union_member(member_id_$member.name$, member_flags_$member.name$, type_ids_$parent.name$.type_identifier1(),
                label_seq_$member.name$);
    }
    $check_second_returned_type_identifier_pair(name=parent.name)$
    {
        common_$member.name$ = TypeObjectUtils::build_common_union_member(member_id_$member.name$, member_flags_$member.name$, type_ids_$parent.name$.type_identifier2(),
                label_seq_$member.name$);
    }
    else
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "Union $member.name$ member TypeIdentifier inconsistent.");
        return;
    }
    $complete_member_detail(member=member, parent=parent, type_kind="Union", name=parent.name)$
    CompleteUnionMember member_$member.name$ = TypeObjectUtils::build_complete_union_member(common_$member.name$, detail_$member.name$);
    TypeObjectUtils::add_complete_union_member(member_seq_$parent.name$, member_$member.name$);
}
>>

register_bitset_type(bitset, name) ::= <<
BitsetTypeFlag bitset_flags_$bitset.name$ = 0;
$complete_type_detail(type=bitset, type_kind= " Bitset", name=name)$
CompleteBitsetHeader header_$bitset.name$ = TypeObjectUtils::build_complete_bitset_header(detail_$bitset.name$);
CompleteBitfieldSeq field_seq_$bitset.name$;
$bitset.bitfields: { bitfield | $bitfield_member(bitfield=bitfield, parent=bitset, name=name)$}; separator="\n"$
CompleteBitsetType bitset_type_$bitset.name$ = TypeObjectUtils::build_complete_bitset_type(bitset_flags_$bitset.name$, header_$bitset.name$, field_seq_$bitset.name$);
if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
        TypeObjectUtils::build_and_register_bitset_type_object(bitset_type_$bitset.name$, type_name_$bitset.name$.to_string()))
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$bitset.scopedname$ already registered in TypeObjectRegistry for a different type.");
}
$get_type_identifier_registry(typename=bitset.scopedname, name=name)$
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$bitset.scopedname$: Given Bitset TypeIdentifier unknown to TypeObjectRegistry.");
    return;
}
>>

bitfield_member(bitfield, parent, name) ::= <<
{
    uint16_t position_$bitfield.name$ = $bitfield.basePosition$;
    BitsetMemberFlag flags_$bitfield.name$ = 0;
    uint8_t bitcount_$bitfield.name$ = $bitfield.spec.bitSize$;
    TypeKind holder_type_$bitfield.name$ = $bitfield.spec.typecode.typeIdentifier$;
    CommonBitfield common_$bitfield.name$ = TypeObjectUtils::build_common_bitfield(position_$bitfield.name$, flags_$bitfield.name$, bitcount_$bitfield.name$, holder_type_$bitfield.name$);
    $empty_ann_builtin_complete_member_detail(member=bitfield, parent=parent, message=[parent.scopedname, " Bitset ", bitfield.name, " bitfield: no builtin annotation applies to bitfield declaration"], name=name)$
    CompleteBitfield bitfield_$bitfield.name$ = TypeObjectUtils::build_complete_bitfield(common_$bitfield.name$, detail_$bitfield.name$);
    TypeObjectUtils::add_complete_bitfield(field_seq_$parent.name$, bitfield_$bitfield.name$);
}
>>

register_sequence_type(sequence, name) ::= <<
$! TODO(jlbueno): annotated collections generate TypeObject instead of TypeIdentifier
                  pending implementation of annotated collection support !$
$plain_collection_header(type=sequence.contentTypeCode, message="Sequence element", name=name, collection_name=sequence_name(sequence))$
std::string type_id_kind_$sequence_name(sequence)$("$sequence.typeIdentifier$");
if (type_id_kind_$sequence_name(sequence)$ == "TI_PLAIN_SEQUENCE_SMALL")
{
    SBound bound = $if (!sequence.isBounded)$0$else$static_cast<SBound>($sequence.evaluatedMaxsize$)$endif$;
    PlainSequenceSElemDefn seq_sdefn = TypeObjectUtils::build_plain_sequence_s_elem_defn(header_$sequence_name(sequence)$, bound,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$sequence_name(sequence)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_sequence_type_identifier(seq_sdefn, "$sequence_name(sequence)$"))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$sequence_name(sequence)$ already registered in TypeObjectRegistry for a different type.");
    }
}
else
{
    LBound bound = $sequence.evaluatedMaxsize$;
    PlainSequenceLElemDefn seq_ldefn = TypeObjectUtils::build_plain_sequence_l_elem_defn(header_$sequence_name(sequence)$, bound,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$sequence_name(sequence)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_sequence_type_identifier(seq_ldefn, "$sequence_name(sequence)$"))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$sequence_name(sequence)$ already registered in TypeObjectRegistry for a different type.");
    }
}
$get_type_identifier_registry(typename=sequence_name(sequence), name=name)$
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$sequence_name(sequence)$: Given Sequence TypeIdentifier unknown to TypeObjectRegistry.");
    return;
}
>>

register_array_type(array, name) ::= <<
$! TODO(jlbueno): annotated collections generate TypeObject instead of TypeIdentifier
                  pending implementation of annotated collection support !$
$plain_collection_header(type=array.contentTypeCode, message="Array element", name=name, collection_name=array_name(array))$
std::string type_id_kind_$array_name(array)$("$array.typeIdentifier$");
if (type_id_kind_$array_name(array)$ == "TI_PLAIN_ARRAY_SMALL")
{
    SBoundSeq array_bound_seq;
    $array.evaluatedDimensions: { dimension |
    TypeObjectUtils::add_array_dimension(array_bound_seq, static_cast<SBound>($dimension$));
    }; separator="\n"$
    PlainArraySElemDefn array_sdefn = TypeObjectUtils::build_plain_array_s_elem_defn(header_$array_name(array)$, array_bound_seq,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$array_name(array)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_array_type_identifier(array_sdefn, "$array_name(array)$"))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$array_name(array)$ already registered in TypeObjectRegistry for a different type.");
    }
}
else
{
    LBoundSeq array_bound_seq;
    $array.evaluatedDimensions: { dimension |
    TypeObjectUtils::add_array_dimension(array_bound_seq, static_cast<LBound>($dimension$));
    }; separator="\n"$
    PlainArrayLElemDefn array_ldefn = TypeObjectUtils::build_plain_array_l_elem_defn(header_$array_name(array)$, array_bound_seq,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$array_name(array)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_array_type_identifier(array_ldefn, "$array_name(array)$"))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$array_name(array)$ already registered in TypeObjectRegistry for a different type.");
    }
}
$get_type_identifier_registry(typename=array_name(array), name=name)$
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$array_name(array)$: Given Array TypeIdentifier unknown to TypeObjectRegistry.");
    return;
}
>>

register_map_type(map, name) ::= <<
$! TODO(jlbueno): annotated collections generate TypeObject instead of TypeIdentifier
                  pending implementation of annotated collection support !$
$get_type_identifier(type=map.valueTypeCode, name=name)$
$check_register_type_identifier(type=map.valueTypeCode, message="Map element", name=name)$
TypeIdentifier* element_identifier_$map_name(map)$ {nullptr};
$check_first_returned_type_identifier_pair(name=name)$
{
    element_identifier_$map_name(map)$ = new TypeIdentifier(type_ids_$name$.type_identifier1());
}
$check_second_returned_type_identifier_pair(name=name)$
{
    element_identifier_$map_name(map)$ = new TypeIdentifier(type_ids_$name$.type_identifier2());
}
else
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$map_name(map)$ inconsistent element TypeIdentifier.");
    return;
}
$get_type_identifier(type=map.keyTypeCode, name=name)$
$check_register_type_identifier(type=map.keyTypeCode, message="Map key", name=name)$
TypeIdentifier* key_identifier_$map_name(map)$ {nullptr};
$check_first_returned_type_identifier_pair(name=name)$
{
    key_identifier_$map_name(map)$ = new TypeIdentifier(type_ids_$name$.type_identifier1());
}
$check_second_returned_type_identifier_pair(name=name)$
{
    key_identifier_$map_name(map)$ = new TypeIdentifier(type_ids_$name$.type_identifier2());
}
else
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$map_name(map)$ inconsistent key TypeIdentifier.");
    return;
}
EquivalenceKind equiv_kind_$map_name(map)$ = EK_BOTH;
if (EK_COMPLETE == element_identifier_$map_name(map)$->_d() ||
        (TI_PLAIN_SEQUENCE_SMALL == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->seq_sdefn().header().equiv_kind()) ||
        (TI_PLAIN_SEQUENCE_LARGE == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->seq_ldefn().header().equiv_kind()) ||
        (TI_PLAIN_ARRAY_SMALL == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->array_sdefn().header().equiv_kind()) ||
        (TI_PLAIN_ARRAY_LARGE == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->array_ldefn().header().equiv_kind()) ||
        (TI_PLAIN_MAP_SMALL == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->map_sdefn().header().equiv_kind()) ||
        (TI_PLAIN_MAP_LARGE == element_identifier_$map_name(map)$->_d() && EK_COMPLETE == element_identifier_$map_name(map)$->map_ldefn().header().equiv_kind()))
{
    equiv_kind_$map_name(map)$ = EK_COMPLETE;
}
$! TODO(jlbueno) Annotated collections not yet supported !$
CollectionElementFlag element_flags_$map_name(map)$ = 0;
CollectionElementFlag key_flags_$map_name(map)$ = 0;
PlainCollectionHeader header_$map_name(map)$ = TypeObjectUtils::build_plain_collection_header(equiv_kind_$map_name(map)$, element_flags_$map_name(map)$);
std::string type_id_kind_$map_name(map)$("$map.typeIdentifier$");
if (type_id_kind_$map_name(map)$ == "TI_PLAIN_MAP_SMALL")
{
    SBound bound = $if (!map.isBounded)$0$else$static_cast<SBound>($map.evaluatedMaxsize$)$endif$;
    PlainMapSTypeDefn map_sdefn = TypeObjectUtils::build_plain_map_s_type_defn(header_$map_name(map)$, bound,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$map_name(map)$), key_flags_$map_name(map)$,
                eprosima::fastcdr::external<TypeIdentifier>(key_identifier_$map_name(map)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_map_type_identifier(map_sdefn, "$map_name(map)$"))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$map_name(map)$ already registered in TypeObjectRegistry for a different type.");
    }
}
else
{
    LBound bound = $map.evaluatedMaxsize$;
    PlainMapLTypeDefn map_ldefn = TypeObjectUtils::build_plain_map_l_type_defn(header_$map_name(map)$, bound,
                eprosima::fastcdr::external<TypeIdentifier>(element_identifier_$map_name(map)$), key_flags_$map_name(map)$,
                eprosima::fastcdr::external<TypeIdentifier>(key_identifier_$map_name(map)$));
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_map_type_identifier(map_ldefn, "$map_name(map)$"))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$map_name(map)$ already registered in TypeObjectRegistry for a different type.");
    }
}
$get_type_identifier_registry(typename=map_name(map), name=name)$
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$map_name(map)$: Given Map TypeIdentifier unknown to TypeObjectRegistry.");
    return;
}
>>

register_enum_type(enum, name) ::= <<
EnumTypeFlag enum_flags_$enum.name$ = 0;
BitBound bit_bound_$enum.name$ = $enum.bitBound$;
CommonEnumeratedHeader common_$enum.name$ = TypeObjectUtils::build_common_enumerated_header(bit_bound_$enum.name$);
$complete_type_detail(type=enum, type_kind=" Enum", name=name)$
CompleteEnumeratedHeader header_$enum.name$ = TypeObjectUtils::build_complete_enumerated_header(common_$enum.name$, detail_$enum.name$);
CompleteEnumeratedLiteralSeq literal_seq_$enum.name$;
$enum.members: { member | $enum_literal(literal=member, parent=enum, name=name)$}; separator="\n"$
CompleteEnumeratedType enumerated_type_$enum.name$ = TypeObjectUtils::build_complete_enumerated_type(enum_flags_$enum.name$, header_$enum.name$,
        literal_seq_$enum.name$);
if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
        TypeObjectUtils::build_and_register_enumerated_type_object(enumerated_type_$enum.name$, type_name_$enum.name$.to_string()))
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$enum.scopedname$ already registered in TypeObjectRegistry for a different type.");
}
$get_type_identifier_registry(typename=enum.scopedname, name=name)$
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$enum.scopedname$: Given Enum TypeIdentifier unknown to TypeObjectRegistry.");
    return;
}
>>

enum_literal(literal, parent, name) ::= <<
{
    EnumeratedLiteralFlag flags_$literal.name$ = TypeObjectUtils::build_enumerated_literal_flag($literal.annotationDefaultLiteral$);
    CommonEnumeratedLiteral common_$literal.name$ = TypeObjectUtils::build_common_enumerated_literal($literal.index$, flags_$literal.name$);
    $empty_ann_builtin_complete_member_detail(member=literal, parent=parent, message=[parent.scopedname, " Enumerated ", literal.name, " literal: only @default_literal and @value builtin annotations apply to literals"], name=name)$
    CompleteEnumeratedLiteral literal_$literal.name$ = TypeObjectUtils::build_complete_enumerated_literal(common_$literal.name$, detail_$literal.name$);
    TypeObjectUtils::add_complete_enumerated_literal(literal_seq_$parent.name$, literal_$literal.name$);
}
>>

register_bitmask_type(bitmask, name) ::= <<
BitmaskTypeFlag bitmask_flags_$bitmask.name$ = 0;
BitBound bit_bound_$bitmask.name$ = $bitmask.bitBound$;
CommonEnumeratedHeader common_$bitmask.name$ = TypeObjectUtils::build_common_enumerated_header(bit_bound_$bitmask.name$, true);
$complete_type_detail(type=bitmask, type_kind=" Bitmask", name=name)$
CompleteEnumeratedHeader header_$bitmask.name$ = TypeObjectUtils::build_complete_enumerated_header(common_$bitmask.name$, detail_$bitmask.name$, true);
CompleteBitflagSeq flag_seq_$bitmask.name$;
$bitmask.bitmasks: { bitflag | $bitflag_member(bitflag=bitflag, parent=bitmask, name=name)$}; separator="\n"$
CompleteBitmaskType bitmask_type_$bitmask.name$ = TypeObjectUtils::build_complete_bitmask_type(bitmask_flags_$bitmask.name$, header_$bitmask.name$, flag_seq_$bitmask.name$);
if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
        TypeObjectUtils::build_and_register_bitmask_type_object(bitmask_type_$bitmask.name$, type_name_$bitmask.name$.to_string()))
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$bitmask.scopedname$ already registered in TypeObjectRegistry for a different type.");
}
$get_type_identifier_registry(typename=bitmask.scopedname, name=name)$
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$bitmask.scopedname$: Given Enum TypeIdentifier unknown to TypeObjectRegistry.");
    return;
}
>>

bitflag_member(bitflag, parent, name) ::= <<
{
    uint16_t position_$bitflag.name$ = $bitflag.position$;
    BitflagFlag flags_$bitflag.name$ = 0;
    CommonBitflag common_$bitflag.name$ = TypeObjectUtils::build_common_bitflag(position_$bitflag.name$, flags_$bitflag.name$);
    $empty_ann_builtin_complete_member_detail(member=bitflag, parent=parent, message=[parent.scopedname, " Bitmask ", bitflag.name, " bitflag: only @position builtin annotation apply to bitmask bitflags"], name=name)$
    CompleteBitflag bitflag_$bitflag.name$ = TypeObjectUtils::build_complete_bitflag(common_$bitflag.name$, detail_$bitflag.name$);
    TypeObjectUtils::add_complete_bitflag(flag_seq_$parent.name$, bitflag_$bitflag.name$);
}
>>

register_wstring_type(wstring, name) ::= <<
std::string type_id_kind_$wstring_name(wstring)$("$wstring.typeIdentifier$");
if (type_id_kind_$wstring_name(wstring)$ == "TI_STRING16_SMALL")
{
    SBound bound = $if (!wstring.isBounded)$0$else$static_cast<SBound>($wstring.evaluatedMaxsize$)$endif$;
    StringSTypeDefn string_sdefn = TypeObjectUtils::build_string_s_type_defn(bound);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_string_type_identifier(string_sdefn,
            "$wstring_name(wstring)$", true))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$wstring_name(wstring)$ already registered in TypeObjectRegistry for a different type.");
    }
}
else if (type_id_kind_$wstring_name(wstring)$ == "TI_STRING16_LARGE")
{
    LBound bound = $wstring.evaluatedMaxsize$;
    StringLTypeDefn string_ldefn = TypeObjectUtils::build_string_l_type_defn(bound);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_string_type_identifier(string_ldefn,
            "$wstring_name(wstring)$", true))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$wstring_name(wstring)$ already registered in TypeObjectRegistry for a different type.");
    }
}
else
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$wstring_name(wstring)$: Unknown WString kind.");
    return;
}
$get_type_identifier_registry(typename=wstring_name(wstring), name=name)$
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$wstring_name(wstring)$: Given WString TypeIdentifier unknown to TypeObjectRegistry.");
    return;
}
>>

register_string_type(string, name) ::= <<
std::string type_id_kind_$string_name(string)$("$string.typeIdentifier$");
if (type_id_kind_$string_name(string)$ == "TI_STRING8_SMALL")
{
    SBound bound = $if (!string.isBounded)$0$else$static_cast<SBound>($string.evaluatedMaxsize$)$endif$;
    StringSTypeDefn string_sdefn = TypeObjectUtils::build_string_s_type_defn(bound);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_s_string_type_identifier(string_sdefn,
            "$string_name(string)$"))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$string_name(string)$ already registered in TypeObjectRegistry for a different type.");
    }
}
else if (type_id_kind_$string_name(string)$ == "TI_STRING8_LARGE")
{
    LBound bound = $string.evaluatedMaxsize$;
    StringLTypeDefn string_ldefn = TypeObjectUtils::build_string_l_type_defn(bound);
    if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
            TypeObjectUtils::build_and_register_l_string_type_identifier(string_ldefn,
            "$string_name(string)$"))
    {
        EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$string_name(string)$ already registered in TypeObjectRegistry for a different type.");
    }
}
else
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$string_name(string)$: Unknown String kind.");
    return;
}
$get_type_identifier_registry(typename=string_name(string), name=name)$
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "$string_name(string)$: Given String TypeIdentifier unknown to TypeObjectRegistry.");
    return;
}
>>

complete_type_detail(type, type_kind, name) ::= <<
QualifiedTypeName type_name_$type.name$ = "$type.scopedname$";
eprosima::fastcdr::optional<AppliedBuiltinTypeAnnotations> type_ann_builtin_$type.name$;
eprosima::fastcdr::optional<AppliedAnnotationSeq> ann_custom_$type.name$;
$type_annotations(type=type, type_kind=type_kind, name=name)$
CompleteTypeDetail detail_$type.name$ = TypeObjectUtils::build_complete_type_detail(type_ann_builtin_$type.name$, ann_custom_$type.name$, type_name_$type.name$.to_string());
>>

complete_member_detail(member, parent, type_kind, name) ::= <<
MemberName name_$member.name$ = "$member.name$";
eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_$member.name$;
ann_custom_$parent.name$.reset();
$if (member.annotationList)$
AppliedAnnotationSeq tmp_ann_custom_$member.name$;
eprosima::fastcdr::optional<std::string> unit_$member.name$;
eprosima::fastcdr::optional<AnnotationParameterValue> min_$member.name$;
eprosima::fastcdr::optional<AnnotationParameterValue> max_$member.name$;
eprosima::fastcdr::optional<std::string> hash_id_$member.name$;
$member.annotationList : { annotation |
$if (annotation.isUnit)$
unit_$member.name$ = $annotation.value$;
$elseif (annotation.isMin || annotation.isMax || annotation.isRange)$
EPROSIMA_LOG_WARNING(XTYPES_TYPE_REPRESENTATION,
        "$parent.scopedname$ $type_kind$ $member.name$ member: @min, @max, and @range builtin annotations not yet supported");
$elseif (annotation.isHashId)$
$if (annotation.value)$
hash_id_$member.name$ = "$annotation.value$";
$endif$
$elseif (!annotation.isBuiltin)$
$applied_annotation_sequence(annotation=annotation, typename=[parent.scopedname, " ", member.name, " member"], member=member, name=name)$
$endif$
}; separator="\n"$
if (unit_$member.name$.has_value() || min_$member.name$.has_value() || max_$member.name$.has_value() || hash_id_$member.name$.has_value())
{
    member_ann_builtin_$member.name$ = TypeObjectUtils::build_applied_builtin_member_annotations(unit_$member.name$, min_$member.name$, max_$member.name$, hash_id_$member.name$);
}
if (!tmp_ann_custom_$member.name$.empty())
{
    ann_custom_$parent.name$ = tmp_ann_custom_$member.name$;
}
$endif$
CompleteMemberDetail detail_$member.name$ = TypeObjectUtils::build_complete_member_detail(name_$member.name$, member_ann_builtin_$member.name$, ann_custom_$parent.name$);
>>

empty_ann_builtin_complete_member_detail(member, parent, message, name) ::= <<
eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_$member.name$;
ann_custom_$parent.name$.reset();
$if (member.annotationList)$
AppliedAnnotationSeq tmp_ann_custom_$member.name$;
$member.annotationList : { annotation |
$if (annotation.isUnit || annotation.isMin || annotation.isMax || annotation.isRange || annotation.isHashId)$
EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$message$");
return;
$elseif (!annotation.isBuiltin)$
$applied_annotation_sequence(annotation=annotation, typename=[parent.scopedname, " ", member.name, " member"], member=member, name=name)$
$endif$
}; separator="\n"$
if (!tmp_ann_custom_$member.name$.empty())
{
    ann_custom_$parent.name$ = tmp_ann_custom_$member.name$;
}
$endif$
MemberName name_$member.name$ = "$member.name$";
CompleteMemberDetail detail_$member.name$ = TypeObjectUtils::build_complete_member_detail(name_$member.name$, member_ann_builtin_$member.name$, ann_custom_$parent.name$);
>>

type_annotations(type, type_kind, name) ::= <<
$if (type.annotationList)$
AppliedAnnotationSeq tmp_ann_custom_$type.name$;
eprosima::fastcdr::optional<AppliedVerbatimAnnotation> verbatim_$type.name$;
$type.annotationList : { annotation |
$if (annotation.isVerbatim)$
$applied_verbatim_annotation(annotation=annotation, name=type.name)$
$elseif (!annotation.isBuiltin)$
$applied_annotation_sequence(annotation=annotation, typename=[type.scopedname, type_kind], member=type, name=name)$
$endif$
}; separator="\n"$
if (!tmp_ann_custom_$type.name$.empty())
{
    ann_custom_$type.name$ = tmp_ann_custom_$type.name$;
}
$endif$
>>

check_first_returned_type_identifier_pair(name) ::= <<
if (EK_COMPLETE == type_ids_$name$.type_identifier1()._d() || TK_NONE == type_ids_$name$.type_identifier2()._d() ||
        (TI_PLAIN_SEQUENCE_SMALL == type_ids_$name$.type_identifier1()._d() &&
        EK_COMPLETE == type_ids_$name$.type_identifier1().seq_sdefn().header().equiv_kind()) ||
        (TI_PLAIN_SEQUENCE_LARGE == type_ids_$name$.type_identifier1()._d() &&
        EK_COMPLETE == type_ids_$name$.type_identifier1().seq_ldefn().header().equiv_kind()) ||
        (TI_PLAIN_ARRAY_SMALL == type_ids_$name$.type_identifier1()._d() &&
        EK_COMPLETE == type_ids_$name$.type_identifier1().array_sdefn().header().equiv_kind()) ||
        (TI_PLAIN_ARRAY_LARGE == type_ids_$name$.type_identifier1()._d() &&
        EK_COMPLETE == type_ids_$name$.type_identifier1().array_ldefn().header().equiv_kind()) ||
        (TI_PLAIN_MAP_SMALL == type_ids_$name$.type_identifier1()._d() &&
        (EK_COMPLETE == type_ids_$name$.type_identifier1().map_sdefn().header().equiv_kind() ||
        EK_COMPLETE == type_ids_$name$.type_identifier1().map_sdefn().key_identifier()->_d())) ||
        (TI_PLAIN_MAP_LARGE == type_ids_$name$.type_identifier1()._d() &&
        (EK_COMPLETE == type_ids_$name$.type_identifier1().map_ldefn().header().equiv_kind() ||
        EK_COMPLETE == type_ids_$name$.type_identifier1().map_ldefn().key_identifier()->_d())))
>>

check_second_returned_type_identifier_pair(name) ::= <<
else if (EK_COMPLETE == type_ids_$name$.type_identifier2()._d() ||
        (TI_PLAIN_SEQUENCE_SMALL == type_ids_$name$.type_identifier2()._d() &&
        EK_COMPLETE == type_ids_$name$.type_identifier2().seq_sdefn().header().equiv_kind()) ||
        (TI_PLAIN_SEQUENCE_LARGE == type_ids_$name$.type_identifier2()._d() &&
        EK_COMPLETE == type_ids_$name$.type_identifier2().seq_ldefn().header().equiv_kind()) ||
        (TI_PLAIN_ARRAY_SMALL == type_ids_$name$.type_identifier2()._d() &&
        EK_COMPLETE == type_ids_$name$.type_identifier2().array_sdefn().header().equiv_kind()) ||
        (TI_PLAIN_ARRAY_LARGE == type_ids_$name$.type_identifier2()._d() &&
        EK_COMPLETE == type_ids_$name$.type_identifier2().array_ldefn().header().equiv_kind()) ||
        (TI_PLAIN_MAP_SMALL == type_ids_$name$.type_identifier2()._d() &&
        (EK_COMPLETE == type_ids_$name$.type_identifier2().map_sdefn().header().equiv_kind() ||
        EK_COMPLETE == type_ids_$name$.type_identifier2().map_sdefn().key_identifier()->_d())) ||
        (TI_PLAIN_MAP_LARGE == type_ids_$name$.type_identifier2()._d() &&
        (EK_COMPLETE == type_ids_$name$.type_identifier2().map_ldefn().header().equiv_kind() ||
        EK_COMPLETE == type_ids_$name$.type_identifier2().map_ldefn().key_identifier()->_d())))
>>

check_register_type_identifier(type, message, name) ::= <<
if (return_code_$name$ != eprosima::fastdds::dds::RETCODE_OK)
{
    $if (type.isAliasType)$
    $register_alias_type(alias=type, name=name)$
    $elseif (type.isStructType)$
    $register_struct_type(struct=type)$
    $elseif (type.isUnionType)$
    $register_union_type(union=type)$
    $elseif (type.isBitsetType)$
    $register_bitset_type(bitset=type, name=name)$
    $elseif (type.isSequenceType)$
    $register_sequence_type(sequence=type, name=name)$
    $elseif (type.isArrayType)$
    $register_array_type(array=type, name=name)$
    $elseif (type.isMapType)$
    $register_map_type(map=type, name=name)$
    $elseif (type.isEnumType)$
    $register_enum_type(enum=type, name=name)$
    $elseif (type.isBitmaskType)$
    $register_bitmask_type(bitmask=type, name=name)$
    $elseif (type.isStringType)$
    $register_string_type(string=type, name=name)$
    $elseif (type.isWStringType)$
    $register_wstring_type(wstring=type, name=name)$
    $else$
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
            "$message$ TypeIdentifier unknown to TypeObjectRegistry.");
    return;
    $endif$
}
>>

extensibility(object) ::= <%
$if (object.annotationExtensibilityNotApplied)$
    eprosima::fastdds::dds::xtypes::ExtensibilityKind::NOT_APPLIED,
$elseif (object.annotationAppendable)$
    eprosima::fastdds::dds::xtypes::ExtensibilityKind::APPENDABLE,
$elseif (object.annotationFinal)$
    eprosima::fastdds::dds::xtypes::ExtensibilityKind::FINAL,
$elseif (object.annotationMutable)$
    eprosima::fastdds::dds::xtypes::ExtensibilityKind::MUTABLE,
$endif$
%>

try_construct(object) ::= <%
$if (!object.annotationTryConstruct)$
    eprosima::fastdds::dds::xtypes::TryConstructKind::NOT_APPLIED,
$elseif (object.annotationDiscard)$
    eprosima::fastdds::dds::xtypes::TryConstructKind::DISCARD,
$elseif (object.annotationUseDefault)$
    eprosima::fastdds::dds::xtypes::TryConstructKind::USE_DEFAULT,
$elseif (object.annotationTrim)$
    eprosima::fastdds::dds::xtypes::TryConstructKind::TRIM,
$endif$
%>

plain_collection_header(type, message, name, collection_name) ::= <<
$get_type_identifier(type=type, name=name)$
$check_register_type_identifier(type=type, message=message, name=name)$
TypeIdentifier* element_identifier_$collection_name$ {nullptr};
$check_first_returned_type_identifier_pair(name=name)$
{
    element_identifier_$collection_name$ = new TypeIdentifier(type_ids_$name$.type_identifier1());
}
$check_second_returned_type_identifier_pair(name=name)$
{
    element_identifier_$collection_name$ = new TypeIdentifier(type_ids_$name$.type_identifier2());
}
else
{
    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
        "$message$ TypeIdentifier inconsistent.");
    return;
}
EquivalenceKind equiv_kind_$collection_name$ = EK_COMPLETE;
if (TK_NONE == type_ids_$name$.type_identifier2()._d())
{
    equiv_kind_$collection_name$ = EK_BOTH;
}
$! TODO(jlbueno) Annotated collections not yet supported !$
CollectionElementFlag element_flags_$collection_name$ = 0;
PlainCollectionHeader header_$collection_name$ = TypeObjectUtils::build_plain_collection_header(equiv_kind_$collection_name$, element_flags_$collection_name$);
>>

//{ Fast DDS-Gen extensions
module_conversion(ctx, parent, modules, definition_list) ::= <<
$modules : { module |
namespace $module.name$ {
}; separator="\n"$

$definition_list$

$reverse(modules) : { module |
\} // namespace $module.name$
}; separator="\n"$
>>
//}
