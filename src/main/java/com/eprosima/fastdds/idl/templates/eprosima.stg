// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group eprosima;

fileHeader(ctx, file, description) ::= <<
// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file $file$
 * $description$
 *
 * This file was generated by the tool $ctx.product$gen.
 */
>>

varDel(variable) ::= <<>>

struct_inherit_default_init(parent) ::= <<$parent.scopedname$()>>

struct_inherit_copy_init(parent) ::= <<$parent.scopedname$(x)>>

struct_inherit_move_init(parent) ::= <<$parent.scopedname$(std::move(x))>>

bitset_inherit_default_init(parent) ::= <<$parent.scopedname$()>>

bitset_inherit_copy_init(parent) ::= <<$parent.scopedname$(x)>>

bitset_inherit_move_init(parent) ::= <<$parent.scopedname$(std::move(x))>>

indexName(name, loopvar) ::= <<$name$[$loopvar$]>>

//{ IDL-parser templates
annotation(ctx, annotation) ::= <<>>

array_declarator(ctx, array) ::= <<>>

bitmask_type(ctx, parent, bitmask) ::= <<>>

bitset_type(ctx, parent, bitset, extensions) ::= <<>>

const_decl(ctx, parent, const, const_type) ::= <<
$const_type$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

element_type(ctx, element, type_element, declarator) ::= <%
$type_element$
$declarator$
%>

enum_type(ctx, parent, enum) ::= <<>>

exception(ctx, parent, exception) ::= <<>>

export_list(exports) ::= <%
$exports; separator="\n"$
%>

fwd_decl(ctx, parent, type) ::= <<>>

interface(ctx, parent, interface, export_list) ::= <<
$export_list$
>>

map_type(ctx, map, key_type, value_type) ::= <%
$key_type$
$value_type$
%>

member_type(ctx, member, type_member, declarators) ::= <%
$type_member$
$declarators$
%>

module(ctx, parent, module, definition_list) ::= <%
$definition_list$
%>

operation(ctx, parent, operation, param_list, operation_type) ::= <%
$operation_type$
$param_list$
%>

param_list(parameters) ::= <<>>

param(parameter, parameter_type) ::= <%
$parameter_type$
%>

sequence_type(ctx, sequence, type_sequence) ::= <%
$type_sequence$
%>

string_type(ctx, string) ::= <<>>

struct_type(ctx, parent, struct, member_list) ::= <%
$member_list$
%>

typedef_decl(ctx, parent, typedefs, typedefs_type, declarator_type) ::= <%
$declarator_type$
$typedefs_type$
%>

union_type(ctx, parent, union, extensions, switch_type) ::= <%
$switch_type$
%>

wide_string_type(ctx, wstring) ::= <<>>
//}

//{ Fast DDS-Gen extensions
module_conversion(ctx, parent, modules, definition_list) ::= <%
$definition_list$
%>
//}

//{ Anonymous collections generator name
sequence_name(sequence) ::= <%
$if(sequence.contentTypeCode.primitive && !sequence.contentTypeCode.isEnumType)$
anonymous_sequence_$sequence.contentTypeCode.cppTypenameForTypeId$_$if(sequence.unbound)$unbounded$else$$sequence.evaluatedMaxsize$$endif$
$elseif (sequence.contentTypeCode.isStringType)$
anonymous_sequence_$string_name(string=sequence.contentTypeCode)$_$if(sequence.unbound)$unbounded$else$$sequence.evaluatedMaxsize$$endif$
$elseif (sequence.contentTypeCode.isWStringType)$
anonymous_sequence_$wstring_name(wstring=sequence.contentTypeCode)$_$if(sequence.unbound)$unbounded$else$$sequence.evaluatedMaxsize$$endif$
$elseif (sequence.contentTypeCode.isArrayType)$
anonymous_sequence_$array_name(array=sequence.contentTypeCode)$_$if(sequence.unbound)$unbounded$else$$sequence.evaluatedMaxsize$$endif$
$elseif (sequence.contentTypeCode.isSequenceType)$
anonymous_sequence_$sequence_name(sequence=sequence.contentTypeCode)$_$if(sequence.unbound)$unbounded$else$$sequence.evaluatedMaxsize$$endif$
$elseif (sequence.contentTypeCode.isMapType)$
anonymous_sequence_$map_name(map=sequence.contentTypeCode)$_$if(sequence.unbound)$unbounded$else$$sequence.evaluatedMaxsize$$endif$
$else$
anonymous_sequence_$sequence.contentTypeCode.CScopedname$_$if(sequence.unbound)$unbounded$else$$sequence.evaluatedMaxsize$$endif$
$endif$
%>

map_name(map) ::= <%
$if(map.keyTypeCode.primitive && !map.keyTypeCode.isEnumType && map.valueTypeCode.primitive && !map.valueTypeCode.isEnumType)$
anonymous_map_$map.keyTypeCode.cppTypenameForTypeId$_$map.valueTypeCode.cppTypenameForTypeId$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.primitive && !map.keyTypeCode.isEnumType && map.valueTypeCode.isStringType)$
anonymous_map_$map.keyTypeCode.cppTypenameForTypeId$_$string_name(string=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.primitive && !map.keyTypeCode.isEnumType && map.valueTypeCode.isWStringType)$
anonymous_map_$map.keyTypeCode.cppTypenameForTypeId$_$wstring_name(wstring=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.primitive && !map.keyTypeCode.isEnumType && map.valueTypeCode.isArrayType)$
anonymous_map_$map.keyTypeCode.cppTypenameForTypeId$_$array_name(array=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.primitive && !map.keyTypeCode.isEnumType && map.valueTypeCode.isSequenceType)$
anonymous_map_$map.keyTypeCode.cppTypenameForTypeId$_$sequence_name(sequence=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.primitive && !map.keyTypeCode.isEnumType && map.valueTypeCode.isMapType)$
anonymous_map_$map.keyTypeCode.cppTypenameForTypeId$_$map_name(map=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.primitive && !map.keyTypeCode.isEnumType)$
anonymous_map_$map.keyTypeCode.cppTypenameForTypeId$_$map.valueTypeCode.CScopedname$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif(map.keyTypeCode.isStringType && map.valueTypeCode.primitive && !map.valueTypeCode.isEnumType)$
anonymous_map_$string_name(string=map.keyTypeCode)$_$map.valueTypeCode.cppTypenameForTypeId$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isStringType && map.valueTypeCode.isStringType)$
anonymous_map_$string_name(string=map.keyTypeCode)$_$string_name(string=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isStringType && map.valueTypeCode.isWStringType)$
anonymous_map_$string_name(string=map.keyTypeCode)$_$wstring_name(wstring=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isStringType && map.valueTypeCode.isArrayType)$
anonymous_map_$string_name(string=map.keyTypeCode)$_$array_name(array=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isStringType && map.valueTypeCode.isSequenceType)$
anonymous_map_$string_name(string=map.keyTypeCode)$_$sequence_name(sequence=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isStringType && map.valueTypeCode.isMapType)$
anonymous_map_$string_name(string=map.keyTypeCode)$_$map_name(map=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isStringType)$
anonymous_map_$string_name(string=map.keyTypeCode)$_$map.valueTypeCode.CScopedname$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif(map.keyTypeCode.isWStringType && map.valueTypeCode.primitive && !map.valueTypeCode.isEnumType)$
anonymous_map_$wstring_name(wstring=map.keyTypeCode)$_$map.valueTypeCode.cppTypenameForTypeId$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isWStringType && map.valueTypeCode.isStringType)$
anonymous_map_$wstring_name(wstring=map.keyTypeCode)$_$string_name(string=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isWStringType && map.valueTypeCode.isWStringType)$
anonymous_map_$wstring_name(wstring=map.keyTypeCode)$_$wstring_name(wstring=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isWStringType && map.valueTypeCode.isArrayType)$
anonymous_map_$wstring_name(wstring=map.keyTypeCode)$_$array_name(array=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isWStringType && map.valueTypeCode.isSequenceType)$
anonymous_map_$wstring_name(wstring=map.keyTypeCode)$_$sequence_name(sequence=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isWStringType && map.valueTypeCode.isMapType)$
anonymous_map_$wstring_name(wstring=map.keyTypeCode)$_$map_name(map=map.valueTypeCode)$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$elseif (map.keyTypeCode.isWStringType)$
anonymous_map_$wstring_name(wstring=map.keyTypeCode)$_$map.valueTypeCode.CScopedname$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$else$
anonymous_map_$map.keyTypeCode.CScopedname$_$map.valueTypeCode.CScopedname$_$if(!map.unbound)$$map.evaluatedMaxsize$$else$unbounded$endif$
$endif$
%>

array_name(array) ::= <%
$if(array.contentTypeCode.primitive && !array.contentTypeCode.isEnumType)$
anonymous_array_$array.contentTypeCode.cppTypenameForTypeId$$array.evaluatedDimensions : { dimension | _$dimension$}$
$elseif (array.contentTypeCode.isStringType)$
anonymous_array_$string_name(string=array.contentTypeCode)$$array.evaluatedDimensions : { dimension | _$dimension$}$
$elseif (array.contentTypeCode.isWStringType)$
anonymous_array_$wstring_name(wstring=array.contentTypeCode)$$array.evaluatedDimensions : { dimension | _$dimension$}$
$elseif (array.contentTypeCode.isArrayType)$
anonymous_array_$array_name(array=array.contentTypeCode)$$array.evaluatedDimensions : { dimension | _$dimension$}$
$elseif (array.contentTypeCode.isSequenceType)$
anonymous_array_$sequence_name(sequence=array.contentTypeCode)$$array.evaluatedDimensions : { dimension | _$dimension$}$
$elseif (array.contentTypeCode.isMapType)$
anonymous_array_$map_name(map=array.contentTypeCode)$$array.evaluatedDimensions : { dimension | _$dimension$}$
$else$
anonymous_array_$array.contentTypeCode.CScopedname$$array.evaluatedDimensions : { dimension | _$dimension$}$
$endif$
%>

string_name(string) ::= <<
anonymous_string_$if(string.isBounded)$$string.evaluatedMaxsize$$else$unbounded$endif$
>>

wstring_name(wstring) ::= <<
anonymous_wstring_$if(wstring.isBounded)$$wstring.evaluatedMaxsize$$else$unbounded$endif$
>>
//}
