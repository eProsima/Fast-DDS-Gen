// Copyright 2025 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

import "eprosima.stg"
import "com/eprosima/fastcdr/idl/templates/FastCdrCommon.stg"

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "Client.cxx"], description=["Client implementation for interfaces"])$

#include "$ctx.filename$Client.hpp"

#include <atomic>
#include <exception>
#include <future>
#include <map>
#include <memory>
#include <mutex>
#include <stdexcept>
#include <string>
#include <thread>

#include <fastdds/dds/domain/DomainParticipant.hpp>
#include <fastdds/dds/domain/qos/RequesterQos.hpp>
#include <fastdds/dds/rpc/exceptions.hpp>
#include <fastdds/dds/rpc/interfaces.hpp>
#include <fastdds/dds/rpc/RequestInfo.hpp>
#include <fastdds/dds/rpc/Requester.hpp>
#include <fastdds/dds/rpc/Service.hpp>
#include <fastdds/dds/rpc/ServiceTypeSupport.hpp>
#include <fastdds/dds/subscriber/DataReader.hpp>

#include "$ctx.filename$.hpp"
#include "$ctx.filename$_details.hpp"
#include "$ctx.filename$PubSubTypes.hpp"

$definitions; separator="\n"$
>>

module(ctx, parent, module, definition_list) ::= <<
namespace $module.name$ {

$definition_list$

} // namespace $module.name$

>>

interface(ctx, parent, interface, export_list) ::= <<
//{ interface $interface.name$

namespace detail {

namespace fdds = eprosima::fastdds::dds;
namespace frpc = eprosima::fastdds::dds::rpc;
namespace frtps = eprosima::fastdds::rtps;

class $interface.name$Client : public $interface.name$
{

    using RequestType = $interface.name$_Request;
    using ReplyType = $interface.name$_Reply;

public:

    $interface.name$Client(
            fdds::DomainParticipant& part,
            const char* service_name,
            const fdds::RequesterQos& qos)
        : $interface.name$()
        , participant_(part)
    {
        // Register the service type support
        auto service_type = create_$interface.name$_service_type_support();
        auto ret = service_type.register_service_type(&participant_, "$interface.scopedname$");
        if (ret != fdds::RETCODE_OK)
        {
            throw std::runtime_error("Error registering service type");
        }

        // Create the service
        service_ = participant_.create_service(service_name, "$interface.scopedname$");
        if (nullptr == service_)
        {
            throw std::runtime_error("Error creating service");
        }

        // Create the requester
        requester_ = participant_.create_service_requester(service_, qos);
        if (nullptr == requester_)
        {
            throw std::runtime_error("Error creating requester");
        }

        // Start the processing thread
        start_thread();
    }

    ~$interface.name$Client() override
    {
        // Stop the processing thread
        stop_thread();

        // Destroy the requester
        if (nullptr != requester_)
        {
            participant_.delete_service_requester(service_->get_service_name(), requester_);
            requester_ = nullptr;
        }

        // Destroy the service
        if (nullptr != service_)
        {
            participant_.delete_service(service_);
            service_ = nullptr;
        }
    }

private:

    void start_thread()
    {
        stop_thread_ = false;
        processing_thread_ = std::thread(&$interface.name$Client::run, this);
    }

    void stop_thread()
    {
        stop_thread_ = true;
        if (processing_thread_.joinable())
        {
            processing_thread_.join();
        }
    }

    void run()
    {
        while (!stop_thread_)
        {
            // Wait for a reply
            if (requester_->get_requester_reader()->wait_for_unread_message({ 0, 100000000 }))
            {
                // Take and process the reply
                frpc::RequestInfo req_info;
                ReplyType reply;
                auto ret = requester_->take_reply(&reply, req_info);
                if (ret == fdds::RETCODE_OK)
                {
                    process_reply(reply, req_info);
                }
            }
        }
    }

    void process_reply(
            const ReplyType& reply,
            const frpc::RequestInfo& req_info)
    {
        auto sample_id = req_info.related_sample_identity;
        {
            std::lock_guard<std::mutex> _(mtx_);
            auto it = pending_results_.find(sample_id);
            if (it != pending_results_.end())
            {
                bool should_erase = false;
                it->second->process_reply(reply, req_info, should_erase);
                if (should_erase)
                {
                    pending_results_.erase(it);
                }
            }
        }
    }

    struct IReplyProcessor
    {
        frpc::RequestInfo info;

        virtual ~IReplyProcessor() = default;

        virtual void process_reply(
                const ReplyType& reply,
                const frpc::RequestInfo& req_info,
                bool& should_remove) = 0;

    };

    fdds::DomainParticipant& participant_;
    frpc::Service* service_ = nullptr;
    frpc::Requester* requester_ = nullptr;
    std::atomic<bool> stop_thread_ = false;
    std::thread processing_thread_;
    std::mutex mtx_;
    std::map<frtps::SampleIdentity, std::shared_ptr<IReplyProcessor> > pending_results_;

    //{ request helpers

    template<typename T>
    auto send_request_with_promise(
            const RequestType& request,
            std::shared_ptr<T> result)
    {
        if (fdds::RETCODE_OK == requester_->send_request((void*)&request, result->info))
        {
            std::lock_guard<std::mutex> _ (mtx_);
            pending_results_[result->info.related_sample_identity] = result;
        }
        else
        {
            result->promise.set_exception(
                std::make_exception_ptr(frpc::RpcBrokenPipeException(false)));
        }

        return result->promise.get_future();
    }

    //} request helpers

$export_list$

};

}  // namespace detail

std::shared_ptr<$interface.name$> create_$interface.name$Client(
        eprosima::fastdds::dds::DomainParticipant& part,
        const char* service_name,
        const eprosima::fastdds::dds::RequesterQos& qos)
{
    return std::make_shared<detail::$interface.name$Client>(part, service_name, qos);
}

//} interface $interface.name$Client

>>

operation(ctx, parent, operation, param_list, operation_type) ::= <<
//{ operation $operation.name$
$if(operation.annotationFeed)$
public:

    $operationRetType(operation)$ $operation.name$(
            $paramDeclarations(params=operation.parameters)$) override
    {
        throw frpc::RemoteUnsupportedError("Not implemented");
    }
$else$
public:

    $operationRetType(operation)$ $operation.name$(
            $paramDeclarations(params=operation.parameters)$) override
    {
        // Create a promise to hold the result
        auto result = std::make_shared<$operation.name$_promise>();
        $if(operation.outputparam)$
        $operation.outputparam:{param | result->$param.name$ = &$param.name$;}; separator="\n"$
        $endif$

        // Create and send the request
        RequestType request;
        request.$operation.name$ = $parent.name$_$operation.name$_In{};
        $if(operation.inputparam)$
        $operation.inputparam:{param | $fill_input_param(operation, param)$}; separator="\n"$
        $endif$

        return send_request_with_promise(request, result);
    }

private:

    struct $operation.name$_promise : public IReplyProcessor
    {
        std::promise<$paramRetType(operation.rettype)$> promise;
        $if(operation.outputparam)$
        $operation.outputparam:{param | $param.typecode.cppTypename$* $param.name$ = nullptr;}; separator="\n"$
        $endif$

        void process_reply(
                const ReplyType& reply,
                const frpc::RequestInfo& req_info,
                bool& should_remove) override
        {
            should_remove = false;
            if (req_info.related_sample_identity != info.related_sample_identity)
            {
                return;
            }

            should_remove = true;
            promise.set_exception(
                std::make_exception_ptr(frpc::RemoteUnsupportedError("Not implemented")));
        }
    };
$endif$

//} operation $operation.name$

>>

operationRetType(operation) ::= <%
$if(operation.annotationFeed)$
std::shared_ptr<eprosima::fastdds::dds::rpc::RpcClientReader<$paramRetType(operation.rettype)$> >
$else$
eprosima::fastdds::dds::rpc::RpcFuture<$paramRetType(operation.rettype)$>
$endif$
%>

fill_input_param(operation, param) ::= <%
$if(param.annotationFeed)$
// TODO: Create RpcClientWriter for '$param.name$'
$else$
request.$operation.name$->$param.name$ = $param.name$;
$endif$
%>
